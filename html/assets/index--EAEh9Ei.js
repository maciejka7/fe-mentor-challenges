const H_ = Object.defineProperty; const q_ = (e, t, r) => t in e ? H_(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; const ls = (e, t, r) => q_(e, typeof t != 'symbol' ? `${t}` : t, r); (function () {
  const t = document.createElement('link').relList; if (t && t.supports && t.supports('modulepreload'))
    return; for (const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s); new MutationObserver((s) => {
    for (const c of s) {
      if (c.type === 'childList') {
        for (const f of c.addedNodes)f.tagName === 'LINK' && f.rel === 'modulepreload' && o(f)
      }
    }
  }).observe(document, { childList: !0, subtree: !0 }); function r(s) { const c = {}; return s.integrity && (c.integrity = s.integrity), s.referrerPolicy && (c.referrerPolicy = s.referrerPolicy), s.crossOrigin === 'use-credentials' ? c.credentials = 'include' : s.crossOrigin === 'anonymous' ? c.credentials = 'omit' : c.credentials = 'same-origin', c } function o(s) {
    if (s.ep)
      return; s.ep = !0; const c = r(s); fetch(s.href, c)
  }
})()/**
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr * @vue/shared v3.4.33
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr * (c) 2018-present Yuxi (Evan) You and Vue contributors
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr * @license MIT
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr *
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}}
}}}} *//*! #__NO_SIDE_EFFECTS__ */function oh(e, t) { const r = new Set(e.split(',')); return o => r.has(o) } const St = {}; const ds = []; function Jn() {} const B_ = () => !1; const cu = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97); const sh = e => e.startsWith('onUpdate:'); const Gt = Object.assign; function lh(e, t) { const r = e.indexOf(t); r > -1 && e.splice(r, 1) } const W_ = Object.prototype.hasOwnProperty; const ct = (e, t) => W_.call(e, t); const Ie = Array.isArray; const hs = e => ia(e) === '[object Map]'; const uu = e => ia(e) === '[object Set]'; const cv = e => ia(e) === '[object Date]'; const Xe = e => typeof e == 'function'; const $t = e => typeof e == 'string'; const Dr = e => typeof e == 'symbol'; const xt = e => e !== null && typeof e == 'object'; const P0 = e => (xt(e) || Xe(e)) && Xe(e.then) && Xe(e.catch); const R0 = Object.prototype.toString; const ia = e => R0.call(e); const U_ = e => ia(e).slice(8, -1); const D0 = e => ia(e) === '[object Object]'; const ah = e => $t(e) && e !== 'NaN' && e[0] !== '-' && `${Number.parseInt(e, 10)}` === e; const _l = oh(',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'); function fu(e) { const t = Object.create(null); return r => t[r] || (t[r] = e(r)) } const V_ = /-(\w)/g; const nr = fu(e => e.replace(V_, (t, r) => r ? r.toUpperCase() : '')); const j_ = /\B([A-Z])/g; const ui = fu(e => e.replace(j_, '-$1').toLowerCase()); const du = fu(e => e.charAt(0).toUpperCase() + e.slice(1)); const mc = fu(e => e ? `on${du(e)}` : ''); const zr = (e, t) => !Object.is(e, t); function yc(e, ...t) { for (let r = 0; r < e.length; r++)e[r](...t) } function z0(e, t, r, o = !1) { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: o, value: r }) } function cd(e) { const t = Number.parseFloat(e); return isNaN(t) ? e : t } function I0(e) { const t = $t(e) ? Number(e) : Number.NaN; return isNaN(t) ? e : t } let uv; const F0 = () => uv || (uv = typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : typeof global < 'u' ? global : {}); function Zt(e) {
  if (Ie(e)) {
    const t = {}; for (let r = 0; r < e.length; r++) {
      const o = e[r]; const s = $t(o) ? Y_(o) : Zt(o); if (s) {
        for (const c in s)t[c] = s[c]
      }
    } return t
  }
  else if ($t(e) || xt(e)) {
    return e
  }
} const G_ = /;(?![^(]*\))/g; const K_ = /:([\s\S]+)/; const X_ = /\/\*[\s\S]*?\*\//g; function Y_(e) { const t = {}; return e.replace(X_, '').split(G_).forEach((r) => { if (r) { const o = r.split(K_); o.length > 1 && (t[o[0].trim()] = o[1].trim()) } }), t } function lt(e) {
  let t = ''; if ($t(e)) {
    t = e
  }
  else if (Ie(e)) {
    for (let r = 0; r < e.length; r++) { const o = lt(e[r]); o && (t += `${o} `) }
  }
  else if (xt(e)) {
    for (const r in e)e[r] && (t += `${r} `)
  } return t.trim()
} function Z_(e) {
  if (!e)
    return null; const { class: t, style: r } = e; return t && !$t(t) && (e.class = lt(t)), r && (e.style = Zt(r)), e
} const J_ = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly'; const Q_ = oh(J_); function H0(e) { return !!e || e === '' } function eS(e, t) {
  if (e.length !== t.length)
    return !1; let r = !0; for (let o = 0; r && o < e.length; o++)r = hu(e[o], t[o]); return r
} function hu(e, t) {
  if (e === t)
    return !0; let r = cv(e); let o = cv(t); if (r || o)
    return r && o ? e.getTime() === t.getTime() : !1; if (r = Dr(e), o = Dr(t), r || o)
    return e === t; if (r = Ie(e), o = Ie(t), r || o)
    return r && o ? eS(e, t) : !1; if (r = xt(e), o = xt(t), r || o) {
    if (!r || !o)
      return !1; const s = Object.keys(e).length; const c = Object.keys(t).length; if (s !== c)
      return !1; for (const f in e) {
      const d = e.hasOwnProperty(f); const h = t.hasOwnProperty(f); if (d && !h || !d && h || !hu(e[f], t[f]))
        return !1
    }
  } return String(e) === String(t)
} function q0(e, t) { return e.findIndex(r => hu(r, t)) } const B0 = e => !!(e && e.__v_isRef === !0); const qe = e => $t(e) ? e : e == null ? '' : Ie(e) || xt(e) && (e.toString === R0 || !Xe(e.toString)) ? B0(e) ? qe(e.value) : JSON.stringify(e, W0, 2) : String(e); const W0 = (e, t) => B0(t) ? W0(e, t.value) : hs(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((r, [o, s], c) => (r[`${If(o, c)} =>`] = s, r), {}) } : uu(t) ? { [`Set(${t.size})`]: [...t.values()].map(r => If(r)) } : Dr(t) ? If(t) : xt(t) && !Ie(t) && !D0(t) ? String(t) : t; function If(e, t = '') { let r; return Dr(e) ? `Symbol(${(r = e.description) != null ? r : t})` : e }/**
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************** * @vue/reactivity v3.4.33
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************** * (c) 2018-present Yuxi (Evan) You and Vue contributors
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************** * @license MIT
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} **************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************** *
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} */let Wn; class tS {
  constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Wn, !t && Wn && (this.index = (Wn.scopes || (Wn.scopes = [])).push(this) - 1) } get active() { return this._active }run(t) {
    if (this._active) {
      const r = Wn; try { return Wn = this, t() }
      finally { Wn = r }
    }
  }

  on() { Wn = this }off() { Wn = this.parent }stop(t) {
    if (this._active) {
      let r, o; for (r = 0, o = this.effects.length; r < o; r++) this.effects[r].stop(); for (r = 0, o = this.cleanups.length; r < o; r++) this.cleanups[r](); if (this.scopes) {
        for (r = 0, o = this.scopes.length; r < o; r++) this.scopes[r].stop(!0)
      } if (!this.detached && this.parent && !t) { const s = this.parent.scopes.pop(); s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index) } this.parent = void 0, this._active = !1
    }
  }
} function nS(e, t = Wn) { t && t.active && t.effects.push(e) } function U0() { return Wn } function rS(e) { Wn && Wn.cleanups.push(e) } let Co; class ch {
  constructor(t, r, o, s) { this.fn = t, this.trigger = r, this.scheduler = o, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, nS(this, s) } get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, eo(); for (let t = 0; t < this._depsLength; t++) {
        const r = this.deps[t]; if (r.computed && (iS(r.computed), this._dirtyLevel >= 4))
          break
      } this._dirtyLevel === 1 && (this._dirtyLevel = 0), to()
    } return this._dirtyLevel >= 4
  }

  set dirty(t) { this._dirtyLevel = t ? 4 : 0 }run() {
    if (this._dirtyLevel = 0, !this.active)
      return this.fn(); const t = Ui; const r = Co; try { return Ui = !0, Co = this, this._runnings++, fv(this), this.fn() }
    finally { dv(this), this._runnings--, Co = r, Ui = t }
  }

  stop() { this.active && (fv(this), dv(this), this.onStop && this.onStop(), this.active = !1) }
} function iS(e) { return e.value } function fv(e) { e._trackId++, e._depsLength = 0 } function dv(e) { if (e.deps.length > e._depsLength) { for (let t = e._depsLength; t < e.deps.length; t++)V0(e.deps[t], e); e.deps.length = e._depsLength } } function V0(e, t) { const r = e.get(t); r !== void 0 && t._trackId !== r && (e.delete(t), e.size === 0 && e.cleanup()) } let Ui = !0; let ud = 0; const j0 = []; function eo() { j0.push(Ui), Ui = !1 } function to() { const e = j0.pop(); Ui = e === void 0 ? !0 : e } function uh() { ud++ } function fh() { for (ud--; !ud && fd.length;)fd.shift()() } function G0(e, t, r) { if (t.get(e) !== e._trackId) { t.set(e, e._trackId); const o = e.deps[e._depsLength]; o !== t ? (o && V0(o, e), e.deps[e._depsLength++] = t) : e._depsLength++ } } const fd = []; function K0(e, t, r) { uh(); for (const o of e.keys()) { let s; o._dirtyLevel < t && (s ?? (s = e.get(o) === o._trackId)) && (o._shouldSchedule || (o._shouldSchedule = o._dirtyLevel === 0), o._dirtyLevel = t), o._shouldSchedule && (s ?? (s = e.get(o) === o._trackId)) && (o.trigger(), (!o._runnings || o.allowRecurse) && o._dirtyLevel !== 2 && (o._shouldSchedule = !1, o.scheduler && fd.push(o.scheduler))) }fh() } function X0(e, t) { const r = new Map(); return r.cleanup = e, r.computed = t, r } const Pc = new WeakMap(); const To = Symbol(''); const dd = Symbol(''); function zn(e, t, r) { if (Ui && Co) { let o = Pc.get(e); o || Pc.set(e, o = new Map()); let s = o.get(r); s || o.set(r, s = X0(() => o.delete(r))), G0(Co, s) } } function ni(e, t, r, o, s, c) {
  const f = Pc.get(e); if (!f)
    return; let d = []; if (t === 'clear') {
    d = [...f.values()]
  }
  else if (r === 'length' && Ie(e)) { const h = Number(o); f.forEach((g, v) => { (v === 'length' || !Dr(v) && v >= h) && d.push(g) }) }
  else {
    switch (r !== void 0 && d.push(f.get(r)), t) { case 'add':Ie(e) ? ah(r) && d.push(f.get('length')) : (d.push(f.get(To)), hs(e) && d.push(f.get(dd))); break; case 'delete':Ie(e) || (d.push(f.get(To)), hs(e) && d.push(f.get(dd))); break; case 'set':hs(e) && d.push(f.get(To)); break }
  }uh(); for (const h of d)h && K0(h, 4); fh()
} function oS(e, t) { const r = Pc.get(e); return r && r.get(t) } const sS = oh('__proto__,__v_isRef,__isVue'); const Y0 = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== 'arguments' && e !== 'caller').map(e => Symbol[e]).filter(Dr)); const hv = lS(); function lS() { const e = {}; return ['includes', 'indexOf', 'lastIndexOf'].forEach((t) => { e[t] = function (...r) { const o = pt(this); for (let c = 0, f = this.length; c < f; c++)zn(o, 'get', `${c}`); const s = o[t](...r); return s === -1 || s === !1 ? o[t](...r.map(pt)) : s } }), ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((t) => { e[t] = function (...r) { eo(), uh(); const o = pt(this)[t].apply(this, r); return fh(), to(), o } }), e } function aS(e) { Dr(e) || (e = String(e)); const t = pt(this); return zn(t, 'has', e), t.hasOwnProperty(e) } class Z0 {
  constructor(t = !1, r = !1) { this._isReadonly = t, this._isShallow = r }get(t, r, o) {
    const s = this._isReadonly; const c = this._isShallow; if (r === '__v_isReactive')
      return !s; if (r === '__v_isReadonly')
      return s; if (r === '__v_isShallow')
      return c; if (r === '__v_raw')
      return o === (s ? c ? xS : ty : c ? ey : Q0).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(o) ? t : void 0; const f = Ie(t); if (!s) {
      if (f && ct(hv, r))
        return Reflect.get(hv, r, o); if (r === 'hasOwnProperty')
        return aS
    } const d = Reflect.get(t, r, o); return (Dr(r) ? Y0.has(r) : sS(r)) || (s || zn(t, 'get', r), c) ? d : Ot(d) ? f && ah(r) ? d : d.value : xt(d) ? s ? oa(d) : er(d) : d
  }
} class J0 extends Z0 {
  constructor(t = !1) { super(!1, t) }set(t, r, o, s) {
    let c = t[r]; if (!this._isShallow) {
      const h = Lo(c); if (!_s(o) && !Lo(o) && (c = pt(c), o = pt(o)), !Ie(t) && Ot(c) && !Ot(o))
        return h ? !1 : (c.value = o, !0)
    } const f = Ie(t) && ah(r) ? Number(r) < t.length : ct(t, r); const d = Reflect.set(t, r, o, s); return t === pt(s) && (f ? zr(o, c) && ni(t, 'set', r, o) : ni(t, 'add', r, o)), d
  }

  deleteProperty(t, r) { const o = ct(t, r); t[r]; const s = Reflect.deleteProperty(t, r); return s && o && ni(t, 'delete', r, void 0), s }has(t, r) { const o = Reflect.has(t, r); return (!Dr(r) || !Y0.has(r)) && zn(t, 'has', r), o }ownKeys(t) { return zn(t, 'iterate', Ie(t) ? 'length' : To), Reflect.ownKeys(t) }
} class cS extends Z0 {constructor(t = !1) { super(!0, t) }set(t, r) { return !0 }deleteProperty(t, r) { return !0 }} const uS = new J0(); const fS = new cS(); const dS = new J0(!0); const dh = e => e; const pu = e => Reflect.getPrototypeOf(e); function Za(e, t, r = !1, o = !1) {
  e = e.__v_raw; const s = pt(e); const c = pt(t); r || (zr(t, c) && zn(s, 'get', t), zn(s, 'get', c)); const { has: f } = pu(s); const d = o ? dh : r ? mh : zl; if (f.call(s, t))
    return d(e.get(t)); if (f.call(s, c))
    return d(e.get(c)); e !== s && e.get(t)
} function Ja(e, t = !1) { const r = this.__v_raw; const o = pt(r); const s = pt(e); return t || (zr(e, s) && zn(o, 'has', e), zn(o, 'has', s)), e === s ? r.has(e) : r.has(e) || r.has(s) } function Qa(e, t = !1) { return e = e.__v_raw, !t && zn(pt(e), 'iterate', To), Reflect.get(e, 'size', e) } function pv(e, t = !1) { !t && !_s(e) && !Lo(e) && (e = pt(e)); const r = pt(this); return pu(r).has.call(r, e) || (r.add(e), ni(r, 'add', e, e)), this } function gv(e, t, r = !1) { !r && !_s(t) && !Lo(t) && (t = pt(t)); const o = pt(this); const { has: s, get: c } = pu(o); let f = s.call(o, e); f || (e = pt(e), f = s.call(o, e)); const d = c.call(o, e); return o.set(e, t), f ? zr(t, d) && ni(o, 'set', e, t) : ni(o, 'add', e, t), this } function vv(e) { const t = pt(this); const { has: r, get: o } = pu(t); let s = r.call(t, e); s || (e = pt(e), s = r.call(t, e)), o && o.call(t, e); const c = t.delete(e); return s && ni(t, 'delete', e, void 0), c } function mv() { const e = pt(this); const t = e.size !== 0; const r = e.clear(); return t && ni(e, 'clear', void 0, void 0), r } function ec(e, t) { return function (o, s) { const c = this; const f = c.__v_raw; const d = pt(f); const h = t ? dh : e ? mh : zl; return !e && zn(d, 'iterate', To), f.forEach((g, v) => o.call(s, h(g), h(v), c)) } } function tc(e, t, r) { return function (...o) { const s = this.__v_raw; const c = pt(s); const f = hs(c); const d = e === 'entries' || e === Symbol.iterator && f; const h = e === 'keys' && f; const g = s[e](...o); const v = r ? dh : t ? mh : zl; return !t && zn(c, 'iterate', h ? dd : To), { next() { const { value: y, done: b } = g.next(); return b ? { value: y, done: b } : { value: d ? [v(y[0]), v(y[1])] : v(y), done: b } }, [Symbol.iterator]() { return this } } } } function Ei(e) { return function (...t) { return e === 'delete' ? !1 : e === 'clear' ? void 0 : this } } function hS() { const e = { get(c) { return Za(this, c) }, get size() { return Qa(this) }, has: Ja, add: pv, set: gv, delete: vv, clear: mv, forEach: ec(!1, !1) }; const t = { get(c) { return Za(this, c, !1, !0) }, get size() { return Qa(this) }, has: Ja, add(c) { return pv.call(this, c, !0) }, set(c, f) { return gv.call(this, c, f, !0) }, delete: vv, clear: mv, forEach: ec(!1, !0) }; const r = { get(c) { return Za(this, c, !0) }, get size() { return Qa(this, !0) }, has(c) { return Ja.call(this, c, !0) }, add: Ei('add'), set: Ei('set'), delete: Ei('delete'), clear: Ei('clear'), forEach: ec(!0, !1) }; const o = { get(c) { return Za(this, c, !0, !0) }, get size() { return Qa(this, !0) }, has(c) { return Ja.call(this, c, !0) }, add: Ei('add'), set: Ei('set'), delete: Ei('delete'), clear: Ei('clear'), forEach: ec(!0, !0) }; return ['keys', 'values', 'entries', Symbol.iterator].forEach((c) => { e[c] = tc(c, !1, !1), r[c] = tc(c, !0, !1), t[c] = tc(c, !1, !0), o[c] = tc(c, !0, !0) }), [e, r, t, o] } const [pS, gS, vS, mS] = hS(); function hh(e, t) { const r = t ? e ? mS : vS : e ? gS : pS; return (o, s, c) => s === '__v_isReactive' ? !e : s === '__v_isReadonly' ? e : s === '__v_raw' ? o : Reflect.get(ct(r, s) && s in o ? r : o, s, c) } const yS = { get: hh(!1, !1) }; const bS = { get: hh(!1, !0) }; const wS = { get: hh(!0, !1) }; const Q0 = new WeakMap(); const ey = new WeakMap(); const ty = new WeakMap(); const xS = new WeakMap(); function _S(e) { switch (e) { case 'Object':case 'Array':return 1; case 'Map':case 'Set':case 'WeakMap':case 'WeakSet':return 2; default:return 0 } } function SS(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : _S(U_(e)) } function er(e) { return Lo(e) ? e : gh(e, !1, uS, yS, Q0) } function ph(e) { return gh(e, !1, dS, bS, ey) } function oa(e) { return gh(e, !0, fS, wS, ty) } function gh(e, t, r, o, s) {
  if (!xt(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e; const c = s.get(e); if (c)
    return c; const f = SS(e); if (f === 0)
    return e; const d = new Proxy(e, f === 2 ? o : r); return s.set(e, d), d
} function Sl(e) { return Lo(e) ? Sl(e.__v_raw) : !!(e && e.__v_isReactive) } function Lo(e) { return !!(e && e.__v_isReadonly) } function _s(e) { return !!(e && e.__v_isShallow) } function ny(e) { return e ? !!e.__v_raw : !1 } function pt(e) { const t = e && e.__v_raw; return t ? pt(t) : e } function vh(e) { return Object.isExtensible(e) && z0(e, '__v_skip', !0), e } const zl = e => xt(e) ? er(e) : e; const mh = e => xt(e) ? oa(e) : e; class ry {constructor(t, r, o, s) { this.getter = t, this._setter = r, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new ch(() => t(this._value), () => kl(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = o } get value() { const t = pt(this); return (!t._cacheable || t.effect.dirty) && zr(t._value, t._value = t.effect.run()) && kl(t, 4), yh(t), t.effect._dirtyLevel >= 2 && kl(t, 2), t._value } set value(t) { this._setter(t) } get _dirty() { return this.effect.dirty } set _dirty(t) { this.effect.dirty = t }} function kS(e, t, r = !1) { let o, s; const c = Xe(e); return c ? (o = e, s = Jn) : (o = e.get, s = e.set), new ry(o, s, c || !s, r) } function yh(e) { let t; Ui && Co && (e = pt(e), G0(Co, (t = e.dep) != null ? t : e.dep = X0(() => e.dep = void 0, e instanceof ry ? e : void 0))) } function kl(e, t = 4, r, o) { e = pt(e); const s = e.dep; s && K0(s, t) } function Ot(e) { return !!(e && e.__v_isRef === !0) } function Be(e) { return iy(e, !1) } function Fr(e) { return iy(e, !0) } function iy(e, t) { return Ot(e) ? e : new CS(e, t) } class CS {constructor(t, r) { this.__v_isShallow = r, this.dep = void 0, this.__v_isRef = !0, this._rawValue = r ? t : pt(t), this._value = r ? t : zl(t) } get value() { return yh(this), this._value } set value(t) { const r = this.__v_isShallow || _s(t) || Lo(t); t = r ? t : pt(t), zr(t, this._rawValue) && (this._rawValue, this._rawValue = t, this._value = r ? t : zl(t), kl(this, 4)) }} function q(e) { return Ot(e) ? e.value : e } const TS = { get: (e, t, r) => q(Reflect.get(e, t, r)), set: (e, t, r, o) => { const s = e[t]; return Ot(s) && !Ot(r) ? (s.value = r, !0) : Reflect.set(e, t, r, o) } }; function oy(e) { return Sl(e) ? e : new Proxy(e, TS) } class ES {constructor(t) { this.dep = void 0, this.__v_isRef = !0; const { get: r, set: o } = t(() => yh(this), () => kl(this)); this._get = r, this._set = o } get value() { return this._get() } set value(t) { this._set(t) }} function sy(e) { return new ES(e) } function LS(e) { const t = Ie(e) ? Array.from({ length: e.length }) : {}; for (const r in e)t[r] = ly(e, r); return t } class AS {constructor(t, r, o) { this._object = t, this._key = r, this._defaultValue = o, this.__v_isRef = !0 } get value() { const t = this._object[this._key]; return t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return oS(pt(this._object), this._key) }} class MS {constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0 } get value() { return this._getter() }} function gu(e, t, r) { return Ot(e) ? e : Xe(e) ? new MS(e) : xt(e) && arguments.length > 1 ? ly(e, t, r) : Be(e) } function ly(e, t, r) { const o = e[t]; return Ot(o) ? o : new AS(e, t, r) }/**
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************ * @vue/runtime-core v3.4.33
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************ * (c) 2018-present Yuxi (Evan) You and Vue contributors
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************ * @license MIT
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************ *
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
*/function Vi(e, t, r, o) {
  try { return o ? e(...o) : e() }
  catch (s) { sa(s, t, r) }
} function tr(e, t, r, o) { if (Xe(e)) { const s = Vi(e, t, r, o); return s && P0(s) && s.catch((c) => { sa(c, t, r) }), s } if (Ie(e)) { const s = []; for (let c = 0; c < e.length; c++)s.push(tr(e[c], t, r, o)); return s } } function sa(e, t, r, o = !0) {
  const s = t ? t.vnode : null; if (t) {
    let c = t.parent; const f = t.proxy; const d = `https://vuejs.org/error-reference/#runtime-${r}`; for (;c;) {
      const g = c.ec; if (g) {
        for (let v = 0; v < g.length; v++) {
          if (g[v](e, f, d) === !1)
            return
        }
      }c = c.parent
    } const h = t.appContext.config.errorHandler; if (h) { eo(), Vi(h, null, 10, [e, f, d]), to(); return }
  }NS(e, r, s, o)
} function NS(e, t, r, o = !0) { console.error(e) } let Il = !1; let hd = !1; const un = []; let Mr = 0; const ps = []; let Pi = null; let xo = 0; const ay = Promise.resolve(); let bh = null; function ln(e) { const t = bh || ay; return e ? t.then(this ? e.bind(this) : e) : t } function $S(e) { let t = Mr + 1; let r = un.length; for (;t < r;) { const o = t + r >>> 1; const s = un[o]; const c = Fl(s); c < e || c === e && s.pre ? t = o + 1 : r = o } return t } function wh(e) { (!un.length || !un.includes(e, Il && e.allowRecurse ? Mr + 1 : Mr)) && (e.id == null ? un.push(e) : un.splice($S(e.id), 0, e), cy()) } function cy() { !Il && !hd && (hd = !0, bh = ay.then(fy)) } function OS(e) { const t = un.indexOf(e); t > Mr && un.splice(t, 1) } function pd(e) { Ie(e) ? ps.push(...e) : (!Pi || !Pi.includes(e, e.allowRecurse ? xo + 1 : xo)) && ps.push(e), cy() } function yv(e, t, r = Il ? Mr + 1 : 0) {
  for (;r < un.length; r++) {
    const o = un[r]; if (o && o.pre) {
      if (e && o.id !== e.uid)
        continue; un.splice(r, 1), r--, o()
    }
  }
} function uy(e) { if (ps.length) { const t = [...new Set(ps)].sort((r, o) => Fl(r) - Fl(o)); if (ps.length = 0, Pi) { Pi.push(...t); return } for (Pi = t, xo = 0; xo < Pi.length; xo++) { const r = Pi[xo]; r.active !== !1 && r() }Pi = null, xo = 0 } } const Fl = e => e.id == null ? 1 / 0 : e.id; function PS(e, t) {
  const r = Fl(e) - Fl(t); if (r === 0) {
    if (e.pre && !t.pre)
      return -1; if (t.pre && !e.pre)
      return 1
  } return r
} function fy(e) {
  hd = !1, Il = !0, un.sort(PS); try { for (Mr = 0; Mr < un.length; Mr++) { const t = un[Mr]; t && t.active !== !1 && Vi(t, t.i, t.i ? 15 : 14) } }
  finally { Mr = 0, un.length = 0, uy(), Il = !1, bh = null, (un.length || ps.length) && fy() }
} let Yt = null; let vu = null; function Rc(e) { const t = Yt; return Yt = e, vu = e && e.type.__scopeId || null, t } function la(e) { vu = e } function aa() { vu = null } const dy = e => st; function st(e, t = Yt, r) {
  if (!t || e._n)
    return e; const o = (...s) => {
    o._d && Hc(-1); const c = Rc(t); let f; try { f = e(...s) }
    finally { Rc(c), o._d && Hc(1) } return f
  }; return o._n = !0, o._c = !0, o._d = !0, o
} function _t(e, t) {
  if (Yt === null)
    return e; const r = ku(Yt); const o = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [c, f, d, h = St] = t[s]; c && (Xe(c) && (c = { mounted: c, updated: c }), c.deep && Hi(f), o.push({ dir: c, instance: r, value: f, oldValue: void 0, arg: d, modifiers: h })) } return e
} function go(e, t, r, o) { const s = e.dirs; const c = t && t.dirs; for (let f = 0; f < s.length; f++) { const d = s[f]; c && (d.oldValue = c[f].value); const h = d.dir[o]; h && (eo(), tr(h, r, 8, [e.el, d, e, t]), to()) } } const Ri = Symbol('_leaveCb'); const nc = Symbol('_enterCb'); function RS() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }; return Os(() => { e.isMounted = !0 }), yy(() => { e.isUnmounting = !0 }), e } const Yn = [Function, Array]; const hy = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Yn, onEnter: Yn, onAfterEnter: Yn, onEnterCancelled: Yn, onBeforeLeave: Yn, onLeave: Yn, onAfterLeave: Yn, onLeaveCancelled: Yn, onBeforeAppear: Yn, onAppear: Yn, onAfterAppear: Yn, onAppearCancelled: Yn }; function py(e) { const t = e.subTree; return t.component ? py(t.component) : t } const DS = { name: 'BaseTransition', props: hy, setup(e, { slots: t }) {
  const r = ca(); const o = RS(); return () => {
    const s = t.default && vy(t.default(), !0); if (!s || !s.length)
      return; let c = s[0]; if (s.length > 1) {
      for (const b of s) {
        if (b.type !== fn) { c = b; break }
      }
    } const f = pt(e); const { mode: d } = f; if (o.isLeaving)
      return Ff(c); const h = bv(c); if (!h)
      return Ff(c); let g = gd(h, f, o, r, b => g = b); Dc(h, g); const v = r.subTree; const y = v && bv(v); if (y && y.type !== fn && !Nr(h, y) && py(r).type !== fn) {
      const b = gd(y, f, o, r); if (Dc(y, b), d === 'out-in' && h.type !== fn)
        return o.isLeaving = !0, b.afterLeave = () => { o.isLeaving = !1, r.update.active !== !1 && (r.effect.dirty = !0, r.update()) }, Ff(c); d === 'in-out' && h.type !== fn && (b.delayLeave = (x, T, E) => { const M = gy(o, y); M[String(y.key)] = y, x[Ri] = () => { T(), x[Ri] = void 0, delete g.delayedLeave }, g.delayedLeave = E })
    } return c
  }
} }; const zS = DS; function gy(e, t) { const { leavingVNodes: r } = e; let o = r.get(t.type); return o || (o = Object.create(null), r.set(t.type, o)), o } function gd(e, t, r, o, s) {
  const { appear: c, mode: f, persisted: d = !1, onBeforeEnter: h, onEnter: g, onAfterEnter: v, onEnterCancelled: y, onBeforeLeave: b, onLeave: x, onAfterLeave: T, onLeaveCancelled: E, onBeforeAppear: M, onAppear: N, onAfterAppear: L, onAppearCancelled: O } = t; const A = String(e.key); const H = gy(r, e); const z = (te, j) => { te && tr(te, o, 9, j) }; const J = (te, j) => { const ne = j[1]; z(te, j), Ie(te) ? te.every(K => K.length <= 1) && ne() : te.length <= 1 && ne() }; const re = { mode: f, persisted: d, beforeEnter(te) {
    let j = h; if (!r.isMounted) {
      if (c)
        j = M || h; else return
    } te[Ri] && te[Ri](!0); const ne = H[A]; ne && Nr(e, ne) && ne.el[Ri] && ne.el[Ri](), z(j, [te])
  }, enter(te) {
    let j = g; let ne = v; let K = y; if (!r.isMounted) {
      if (c)
        j = N || g, ne = L || v, K = O || y; else return
    } let V = !1; const I = te[nc] = (k) => { V || (V = !0, k ? z(K, [te]) : z(ne, [te]), re.delayedLeave && re.delayedLeave(), te[nc] = void 0) }; j ? J(j, [te, I]) : I()
  }, leave(te, j) {
    const ne = String(e.key); if (te[nc] && te[nc](!0), r.isUnmounting)
      return j(); z(b, [te]); let K = !1; const V = te[Ri] = (I) => { K || (K = !0, j(), I ? z(E, [te]) : z(T, [te]), te[Ri] = void 0, H[ne] === e && delete H[ne]) }; H[ne] = e, x ? J(x, [te, V]) : V()
  }, clone(te) { const j = gd(te, t, r, o, s); return s && s(j), j } }; return re
} function Ff(e) {
  if (mu(e))
    return e = Ki(e), e.children = null, e
} function bv(e) {
  if (!mu(e))
    return e; const { shapeFlag: t, children: r } = e; if (r) {
    if (t & 16)
      return r[0]; if (t & 32 && Xe(r.default))
      return r.default()
  }
} function Dc(e, t) { e.shapeFlag & 6 && e.component ? Dc(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function vy(e, t = !1, r) {
  let o = []; let s = 0; for (let c = 0; c < e.length; c++) { const f = e[c]; const d = r == null ? f.key : String(r) + String(f.key != null ? f.key : c); f.type === ut ? (f.patchFlag & 128 && s++, o = o.concat(vy(f.children, t, d))) : (t || f.type !== fn) && o.push(d != null ? Ki(f, { key: d }) : f) } if (s > 1) {
    for (let c = 0; c < o.length; c++)o[c].patchFlag = -2
  } return o
}/*! #__NO_SIDE_EFFECTS__ */ function ft(e, t) { return Xe(e) ? Gt({ name: e.name }, t, { setup: e }) : e } const Cl = e => !!e.type.__asyncLoader; const mu = e => e.type.__isKeepAlive; function IS(e, t) { my(e, 'a', t) } function FS(e, t) { my(e, 'da', t) } function my(e, t, r = sn) {
  const o = e.__wdc || (e.__wdc = () => {
    let s = r; for (;s;) {
      if (s.isDeactivated)
        return; s = s.parent
    } return e()
  }); if (yu(t, o, r), r) { let s = r.parent; for (;s && s.parent;)mu(s.parent.vnode) && HS(o, t, r, s), s = s.parent }
} function HS(e, t, r, o) { const s = yu(t, e, o, !0); bu(() => { lh(o[t], s) }, r) } function yu(e, t, r = sn, o = !1) { if (r) { const s = r[e] || (r[e] = []); const c = t.__weh || (t.__weh = (...f) => { eo(); const d = ua(r); const h = tr(t, r, e, f); return d(), to(), h }); return o ? s.unshift(c) : s.push(c), c } } const fi = e => (t, r = sn) => { (!Su || e === 'sp') && yu(e, (...o) => t(...o), r) }; const qS = fi('bm'); const Os = fi('m'); const BS = fi('bu'); const WS = fi('u'); const yy = fi('bum'); const bu = fi('um'); const US = fi('sp'); const VS = fi('rtg'); const jS = fi('rtc'); function GS(e, t = sn) { yu('ec', e, t) } const xh = 'components'; const KS = 'directives'; function Ao(e, t) { return _h(xh, e, !0, t) || e } const by = Symbol.for('v-ndc'); function wv(e) { return $t(e) ? _h(xh, e, !1) || e : e || by } function Hr(e) { return _h(KS, e) } function _h(e, t, r = !0, o = !1) {
  const s = Yt || sn; if (s) {
    const c = s.type; if (e === xh) {
      const d = Wk(c, !1); if (d && (d === t || d === nr(t) || d === du(nr(t))))
        return c
    } const f = xv(s[e] || c[e], t) || xv(s.appContext[e], t); return !f && o ? c : f
  }
} function xv(e, t) { return e && (e[t] || e[nr(t)] || e[du(nr(t))]) } function si(e, t, r, o) {
  let s; const c = r; if (Ie(e) || $t(e)) { s = Array.from({ length: e.length }); for (let f = 0, d = e.length; f < d; f++)s[f] = t(e[f], f, void 0, c) }
  else if (typeof e == 'number') { s = new Array(e); for (let f = 0; f < e; f++)s[f] = t(f + 1, f, void 0, c) }
  else if (xt(e)) {
    if (e[Symbol.iterator]) {
      s = Array.from(e, (f, d) => t(f, d, void 0, c))
    }
    else { const f = Object.keys(e); s = Array.from({ length: f.length }); for (let d = 0, h = f.length; d < h; d++) { const g = f[d]; s[d] = t(e[g], g, d, c) } }
  }
  else {
    s = []
  } return s
} function XS(e, t) {
  for (let r = 0; r < t.length; r++) {
    const o = t[r]; if (Ie(o)) {
      for (let s = 0; s < o.length; s++)e[o[s].name] = o[s].fn
    }
    else {
      o && (e[o.name] = o.key ? (...s) => { const c = o.fn(...s); return c && (c.key = o.key), c } : o.fn)
    }
  } return e
} function dn(e, t, r = {}, o, s) {
  if (Yt.isCE || Yt.parent && Cl(Yt.parent) && Yt.parent.isCE)
    return t !== 'default' && (r.name = t), Oe('slot', r, o && o()); const c = e[t]; c && c._c && (c._d = !1), oe(); const f = c && wy(c(r)); const d = ot(ut, { key: (r.key || f && f.key || `_${t}`) + (!f && o ? '_fb' : '') }, f || (o ? o() : []), f && e._ === 1 ? 64 : -2); return d.scopeId && (d.slotScopeIds = [`${d.scopeId}-s`]), c && c._c && (c._d = !0), d
} function wy(e) { return e.some(t => ql(t) ? !(t.type === fn || t.type === ut && !wy(t.children)) : !0) ? e : null } function YS(e, t) { const r = {}; for (const o in e)r[mc(o)] = e[o]; return r } const vd = e => e ? Wy(e) ? ku(e) : vd(e.parent) : null; const Tl = Gt(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => vd(e.parent), $root: e => vd(e.root), $emit: e => e.emit, $options: e => Sh(e), $forceUpdate: e => e.f || (e.f = () => { e.effect.dirty = !0, wh(e.update) }), $nextTick: e => e.n || (e.n = ln.bind(e.proxy)), $watch: e => _k.bind(e) }); const Hf = (e, t) => e !== St && !e.__isScriptSetup && ct(e, t); const ZS = { get({ _: e }, t) {
  if (t === '__v_skip')
    return !0; const { ctx: r, setupState: o, data: s, props: c, accessCache: f, type: d, appContext: h } = e; let g; if (t[0] !== '$') {
    const x = f[t]; if (x !== void 0) {
      switch (x) { case 1:return o[t]; case 2:return s[t]; case 4:return r[t]; case 3:return c[t] }
    }
    else {
      if (Hf(o, t))
        return f[t] = 1, o[t]; if (s !== St && ct(s, t))
        return f[t] = 2, s[t]; if ((g = e.propsOptions[0]) && ct(g, t))
        return f[t] = 3, c[t]; if (r !== St && ct(r, t))
        return f[t] = 4, r[t]; md && (f[t] = 0)
    }
  } const v = Tl[t]; let y, b; if (v)
    return t === '$attrs' && zn(e.attrs, 'get', ''), v(e); if ((y = d.__cssModules) && (y = y[t]))
    return y; if (r !== St && ct(r, t))
    return f[t] = 4, r[t]; if (b = h.config.globalProperties, ct(b, t))
    return b[t]
}, set({ _: e }, t, r) { const { data: o, setupState: s, ctx: c } = e; return Hf(s, t) ? (s[t] = r, !0) : o !== St && ct(o, t) ? (o[t] = r, !0) : ct(e.props, t) || t[0] === '$' && t.slice(1) in e ? !1 : (c[t] = r, !0) }, has({ _: { data: e, setupState: t, accessCache: r, ctx: o, appContext: s, propsOptions: c } }, f) { let d; return !!r[f] || e !== St && ct(e, f) || Hf(t, f) || (d = c[0]) && ct(d, f) || ct(o, f) || ct(Tl, f) || ct(s.config.globalProperties, f) }, defineProperty(e, t, r) { return r.get != null ? e._.accessCache[t] = 0 : ct(r, 'value') && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r) } }; function JS() { return QS().attrs } function QS() { const e = ca(); return e.setupContext || (e.setupContext = Vy(e)) } function zc(e) { return Ie(e) ? e.reduce((t, r) => (t[r] = null, t), {}) : e } function Ic(e, t) { return !e || !t ? e || t : Ie(e) && Ie(t) ? e.concat(t) : Gt({}, zc(e), zc(t)) } let md = !0; function ek(e) {
  const t = Sh(e); const r = e.proxy; const o = e.ctx; md = !1, t.beforeCreate && _v(t.beforeCreate, e, 'bc'); const { data: s, computed: c, methods: f, watch: d, provide: h, inject: g, created: v, beforeMount: y, mounted: b, beforeUpdate: x, updated: T, activated: E, deactivated: M, beforeDestroy: N, beforeUnmount: L, destroyed: O, unmounted: A, render: H, renderTracked: z, renderTriggered: J, errorCaptured: re, serverPrefetch: te, expose: j, inheritAttrs: ne, components: K, directives: V, filters: I } = t; if (g && tk(g, o, null), f) {
    for (const W in f) { const ie = f[W]; Xe(ie) && (o[W] = ie.bind(r)) }
  } if (s) { const W = s.call(r, r); xt(W) && (e.data = er(W)) } if (md = !0, c) {
    for (const W in c) { const ie = c[W]; const ye = Xe(ie) ? ie.bind(r, r) : Xe(ie.get) ? ie.get.bind(r, r) : Jn; const Ne = !Xe(ie) && Xe(ie.set) ? ie.set.bind(r) : Jn; const We = Me({ get: ye, set: Ne }); Object.defineProperty(o, W, { enumerable: !0, configurable: !0, get: () => We.value, set: je => We.value = je }) }
  } if (d) {
    for (const W in d)xy(d[W], o, r, W)
  } if (h) { const W = Xe(h) ? h.call(r) : h; Reflect.ownKeys(W).forEach((ie) => { bc(ie, W[ie]) }) }v && _v(v, e, 'c'); function B(W, ie) { Ie(ie) ? ie.forEach(ye => W(ye.bind(r))) : ie && W(ie.bind(r)) } if (B(qS, y), B(Os, b), B(BS, x), B(WS, T), B(IS, E), B(FS, M), B(GS, re), B(jS, z), B(VS, J), B(yy, L), B(bu, A), B(US, te), Ie(j)) {
    if (j.length) { const W = e.exposed || (e.exposed = {}); j.forEach((ie) => { Object.defineProperty(W, ie, { get: () => r[ie], set: ye => r[ie] = ye }) }) }
    else {
      e.exposed || (e.exposed = {})
    }
  }H && e.render === Jn && (e.render = H), ne != null && (e.inheritAttrs = ne), K && (e.components = K), V && (e.directives = V)
} function tk(e, t, r = Jn) { Ie(e) && (e = yd(e)); for (const o in e) { const s = e[o]; let c; xt(s) ? 'default' in s ? c = ri(s.from || o, s.default, !0) : c = ri(s.from || o) : c = ri(s), Ot(c) ? Object.defineProperty(t, o, { enumerable: !0, configurable: !0, get: () => c.value, set: f => c.value = f }) : t[o] = c } } function _v(e, t, r) { tr(Ie(e) ? e.map(o => o.bind(t.proxy)) : e.bind(t.proxy), t, r) } function xy(e, t, r, o) {
  const s = o.includes('.') ? Py(r, o) : () => r[o]; if ($t(e)) { const c = t[e]; Xe(c) && Ht(s, c) }
  else if (Xe(e)) {
    Ht(s, e.bind(r))
  }
  else if (xt(e)) {
    if (Ie(e)) {
      e.forEach(c => xy(c, t, r, o))
    }
    else { const c = Xe(e.handler) ? e.handler.bind(r) : t[e.handler]; Xe(c) && Ht(s, c, e) }
  }
} function Sh(e) { const t = e.type; const { mixins: r, extends: o } = t; const { mixins: s, optionsCache: c, config: { optionMergeStrategies: f } } = e.appContext; const d = c.get(t); let h; return d ? h = d : !s.length && !r && !o ? h = t : (h = {}, s.length && s.forEach(g => Fc(h, g, f, !0)), Fc(h, t, f)), xt(t) && c.set(t, h), h } function Fc(e, t, r, o = !1) {
  const { mixins: s, extends: c } = t; c && Fc(e, c, r, !0), s && s.forEach(f => Fc(e, f, r, !0)); for (const f in t) {
    if (!(o && f === 'expose')) { const d = nk[f] || r && r[f]; e[f] = d ? d(e[f], t[f]) : t[f] }
  } return e
} const nk = { data: Sv, props: kv, emits: kv, methods: yl, computed: yl, beforeCreate: xn, created: xn, beforeMount: xn, mounted: xn, beforeUpdate: xn, updated: xn, beforeDestroy: xn, beforeUnmount: xn, destroyed: xn, unmounted: xn, activated: xn, deactivated: xn, errorCaptured: xn, serverPrefetch: xn, components: yl, directives: yl, watch: ik, provide: Sv, inject: rk }; function Sv(e, t) { return t ? e ? function () { return Gt(Xe(e) ? e.call(this, this) : e, Xe(t) ? t.call(this, this) : t) } : t : e } function rk(e, t) { return yl(yd(e), yd(t)) } function yd(e) { if (Ie(e)) { const t = {}; for (let r = 0; r < e.length; r++)t[e[r]] = e[r]; return t } return e } function xn(e, t) { return e ? [...new Set([].concat(e, t))] : t } function yl(e, t) { return e ? Gt(Object.create(null), e, t) : t } function kv(e, t) { return e ? Ie(e) && Ie(t) ? [...new Set([...e, ...t])] : Gt(Object.create(null), zc(e), zc(t ?? {})) : t } function ik(e, t) {
  if (!e)
    return t; if (!t)
    return e; const r = Gt(Object.create(null), e); for (const o in t)r[o] = xn(e[o], t[o]); return r
} function _y() { return { app: null, config: { isNativeTag: B_, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap(), propsCache: new WeakMap(), emitsCache: new WeakMap() } } let ok = 0; function sk(e, t) {
  return function (o, s = null) {
    Xe(o) || (o = Gt({}, o)), s != null && !xt(s) && (s = null); const c = _y(); const f = new WeakSet(); let d = !1; const h = c.app = { _uid: ok++, _component: o, _props: s, _container: null, _context: c, _instance: null, version: Vk, get config() { return c.config }, set config(g) {}, use(g, ...v) { return f.has(g) || (g && Xe(g.install) ? (f.add(g), g.install(h, ...v)) : Xe(g) && (f.add(g), g(h, ...v))), h }, mixin(g) { return c.mixins.includes(g) || c.mixins.push(g), h }, component(g, v) { return v ? (c.components[g] = v, h) : c.components[g] }, directive(g, v) { return v ? (c.directives[g] = v, h) : c.directives[g] }, mount(g, v, y) { if (!d) { const b = Oe(o, s); return b.appContext = c, y === !0 ? y = 'svg' : y === !1 && (y = void 0), v && t ? t(b, g) : e(b, g, y), d = !0, h._container = g, g.__vue_app__ = h, ku(b.component) } }, unmount() { d && (e(null, h._container), delete h._container.__vue_app__) }, provide(g, v) { return c.provides[g] = v, h }, runWithContext(g) {
      const v = El; El = h; try { return g() }
      finally { El = v }
    } }; return h
  }
} let El = null; function bc(e, t) { if (sn) { let r = sn.provides; const o = sn.parent && sn.parent.provides; o === r && (r = sn.provides = Object.create(o)), r[e] = t } } function ri(e, t, r = !1) {
  const o = sn || Yt; if (o || El) {
    const s = o ? o.parent == null ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : El._context.provides; if (s && e in s)
      return s[e]; if (arguments.length > 1)
      return r && Xe(t) ? t.call(o && o.proxy) : t
  }
} const Sy = {}; const ky = () => Object.create(Sy); const Cy = e => Object.getPrototypeOf(e) === Sy; function lk(e, t, r, o = !1) { const s = {}; const c = ky(); e.propsDefaults = Object.create(null), Ty(e, t, s, c); for (const f in e.propsOptions[0])f in s || (s[f] = void 0); r ? e.props = o ? s : ph(s) : e.type.props ? e.props = s : e.props = c, e.attrs = c } function ak(e, t, r, o) {
  const { props: s, attrs: c, vnode: { patchFlag: f } } = e; const d = pt(s); const [h] = e.propsOptions; let g = !1; if ((o || f > 0) && !(f & 16)) {
    if (f & 8) {
      const v = e.vnode.dynamicProps; for (let y = 0; y < v.length; y++) {
        const b = v[y]; if (xu(e.emitsOptions, b))
          continue; const x = t[b]; if (h) {
          if (ct(c, b)) {
            x !== c[b] && (c[b] = x, g = !0)
          }
          else { const T = nr(b); s[T] = bd(h, d, T, x, e, !1) }
        }
        else {
          x !== c[b] && (c[b] = x, g = !0)
        }
      }
    }
  }
  else {
    Ty(e, t, s, c) && (g = !0); let v; for (const y in d)(!t || !ct(t, y) && ((v = ui(y)) === y || !ct(t, v))) && (h ? r && (r[y] !== void 0 || r[v] !== void 0) && (s[y] = bd(h, d, y, void 0, e, !0)) : delete s[y]); if (c !== d) {
      for (const y in c)(!t || !ct(t, y)) && (delete c[y], g = !0)
    }
  }g && ni(e.attrs, 'set', '')
} function Ty(e, t, r, o) {
  const [s, c] = e.propsOptions; let f = !1; let d; if (t) {
    for (const h in t) {
      if (_l(h))
        continue; const g = t[h]; let v; s && ct(s, v = nr(h)) ? !c || !c.includes(v) ? r[v] = g : (d || (d = {}))[v] = g : xu(e.emitsOptions, h) || (!(h in o) || g !== o[h]) && (o[h] = g, f = !0)
    }
  } if (c) { const h = pt(r); const g = d || St; for (let v = 0; v < c.length; v++) { const y = c[v]; r[y] = bd(s, h, y, g[y], e, !ct(g, y)) } } return f
} function bd(e, t, r, o, s, c) {
  const f = e[r]; if (f != null) {
    const d = ct(f, 'default'); if (d && o === void 0) {
      const h = f.default; if (f.type !== Function && !f.skipFactory && Xe(h)) {
        const { propsDefaults: g } = s; if (r in g) {
          o = g[r]
        }
        else { const v = ua(s); o = g[r] = h.call(null, t), v() }
      }
      else {
        o = h
      }
    }f[0] && (c && !d ? o = !1 : f[1] && (o === '' || o === ui(r)) && (o = !0))
  } return o
} const ck = new WeakMap(); function Ey(e, t, r = !1) {
  const o = r ? ck : t.propsCache; const s = o.get(e); if (s)
    return s; const c = e.props; const f = {}; const d = []; let h = !1; if (!Xe(e)) { const v = (y) => { h = !0; const [b, x] = Ey(y, t, !0); Gt(f, b), x && d.push(...x) }; !r && t.mixins.length && t.mixins.forEach(v), e.extends && v(e.extends), e.mixins && e.mixins.forEach(v) } if (!c && !h)
    return xt(e) && o.set(e, ds), ds; if (Ie(c)) {
    for (let v = 0; v < c.length; v++) { const y = nr(c[v]); Cv(y) && (f[y] = St) }
  }
  else if (c) {
    for (const v in c) { const y = nr(v); if (Cv(y)) { const b = c[v]; const x = f[y] = Ie(b) || Xe(b) ? { type: b } : Gt({}, b); if (x) { const T = Lv(Boolean, x.type); const E = Lv(String, x.type); x[0] = T > -1, x[1] = E < 0 || T < E, (T > -1 || ct(x, 'default')) && d.push(y) } } }
  } const g = [f, d]; return xt(e) && o.set(e, g), g
} function Cv(e) { return e[0] !== '$' && !_l(e) } function Tv(e) { return e === null ? 'null' : typeof e == 'function' ? e.name || '' : typeof e == 'object' && e.constructor && e.constructor.name || '' } function Ev(e, t) { return Tv(e) === Tv(t) } function Lv(e, t) { return Ie(t) ? t.findIndex(r => Ev(r, e)) : Xe(t) && Ev(t, e) ? 0 : -1 } const Ly = e => e[0] === '_' || e === '$stable'; const kh = e => Ie(e) ? e.map(mr) : [mr(e)]; function uk(e, t, r) {
  if (t._n)
    return t; const o = st((...s) => kh(t(...s)), r); return o._c = !1, o
} function Ay(e, t, r) {
  const o = e._ctx; for (const s in e) {
    if (Ly(s))
      continue; const c = e[s]; if (Xe(c)) {
      t[s] = uk(s, c, o)
    }
    else if (c != null) { const f = kh(c); t[s] = () => f }
  }
} function My(e, t) { const r = kh(t); e.slots.default = () => r } function Ny(e, t, r) { for (const o in t)(r || o !== '_') && (e[o] = t[o]) } function fk(e, t, r) {
  const o = e.slots = ky(); if (e.vnode.shapeFlag & 32) { const s = t._; s ? (Ny(o, t, r), r && z0(o, '_', s, !0)) : Ay(t, o) }
  else {
    t && My(e, t)
  }
} function dk(e, t, r) {
  const { vnode: o, slots: s } = e; let c = !0; let f = St; if (o.shapeFlag & 32) { const d = t._; d ? r && d === 1 ? c = !1 : Ny(s, t, r) : (c = !t.$stable, Ay(t, s)), f = t }
  else {
    t && (My(e, t), f = { default: 1 })
  } if (c) {
    for (const d in s)!Ly(d) && f[d] == null && delete s[d]
  }
} function wd(e, t, r, o, s = !1) {
  if (Ie(e)) { e.forEach((b, x) => wd(b, t && (Ie(t) ? t[x] : t), r, o, s)); return } if (Cl(o) && !s)
    return; const c = o.shapeFlag & 4 ? ku(o.component) : o.el; const f = s ? null : c; const { i: d, r: h } = e; const g = t && t.r; const v = d.refs === St ? d.refs = {} : d.refs; const y = d.setupState; if (g != null && g !== h && ($t(g) ? (v[g] = null, ct(y, g) && (y[g] = null)) : Ot(g) && (g.value = null)), Xe(h)) {
    Vi(h, d, 12, [f, v])
  }
  else {
    const b = $t(h); const x = Ot(h); if (b || x) {
      const T = () => {
        if (e.f) { const E = b ? ct(y, h) ? y[h] : v[h] : h.value; s ? Ie(E) && lh(E, c) : Ie(E) ? E.includes(c) || E.push(c) : b ? (v[h] = [c], ct(y, h) && (y[h] = v[h])) : (h.value = [c], e.k && (v[e.k] = h.value)) }
        else {
          b ? (v[h] = f, ct(y, h) && (y[h] = f)) : x && (h.value = f, e.k && (v[e.k] = f))
        }
      }; f ? (T.id = -1, Nn(T, r)) : T()
    }
  }
} const hk = Symbol('_vte'); const pk = e => e.__isTeleport; const Nn = Pk; function gk(e) { return vk(e) } function vk(e, t) {
  const r = F0(); r.__VUE__ = !0; const { insert: o, remove: s, patchProp: c, createElement: f, createText: d, createComment: h, setText: g, setElementText: v, parentNode: y, nextSibling: b, setScopeId: x = Jn, insertStaticContent: T } = e; const E = (P, F, Z, ue = null, le = null, he = null, Se = void 0, fe = null, xe = !!F.dynamicChildren) => {
    if (P === F)
      return; P && !Nr(P, F) && (ue = X(P), je(P, le, he, !0), P = null), F.patchFlag === -2 && (xe = !1, F.dynamicChildren = null); const { type: pe, ref: Ae, shapeFlag: ze } = F; switch (pe) { case _u:M(P, F, Z, ue); break; case fn:N(P, F, Z, ue); break; case Wf:P == null && L(F, Z, ue, Se); break; case ut:K(P, F, Z, ue, le, he, Se, fe, xe); break; default:ze & 1 ? H(P, F, Z, ue, le, he, Se, fe, xe) : ze & 6 ? V(P, F, Z, ue, le, he, Se, fe, xe) : (ze & 64 || ze & 128) && pe.process(P, F, Z, ue, le, he, Se, fe, xe, $e) }Ae != null && le && wd(Ae, P && P.ref, he, F || P, !F)
  }; const M = (P, F, Z, ue) => {
    if (P == null) {
      o(F.el = d(F.children), Z, ue)
    }
    else { const le = F.el = P.el; F.children !== P.children && g(le, F.children) }
  }; const N = (P, F, Z, ue) => { P == null ? o(F.el = h(F.children || ''), Z, ue) : F.el = P.el }; const L = (P, F, Z, ue) => { [P.el, P.anchor] = T(P.children, F, Z, ue, P.el, P.anchor) }; const O = ({ el: P, anchor: F }, Z, ue) => { let le; for (;P && P !== F;)le = b(P), o(P, Z, ue), P = le; o(F, Z, ue) }; const A = ({ el: P, anchor: F }) => { let Z; for (;P && P !== F;)Z = b(P), s(P), P = Z; s(F) }; const H = (P, F, Z, ue, le, he, Se, fe, xe) => { F.type === 'svg' ? Se = 'svg' : F.type === 'math' && (Se = 'mathml'), P == null ? z(F, Z, ue, le, he, Se, fe, xe) : te(P, F, le, he, Se, fe, xe) }; const z = (P, F, Z, ue, le, he, Se, fe) => { let xe, pe; const { props: Ae, shapeFlag: ze, transition: Re, dirs: Ue } = P; if (xe = P.el = f(P.type, he, Ae && Ae.is, Ae), ze & 8 ? v(xe, P.children) : ze & 16 && re(P.children, xe, null, ue, le, qf(P, he), Se, fe), Ue && go(P, null, ue, 'created'), J(xe, P, P.scopeId, Se, ue), Ae) { for (const vt in Ae)vt !== 'value' && !_l(vt) && c(xe, vt, null, Ae[vt], he, ue); 'value' in Ae && c(xe, 'value', null, Ae.value, he), (pe = Ae.onVnodeBeforeMount) && Ar(pe, ue, P) }Ue && go(P, null, ue, 'beforeMount'); const Ge = mk(le, Re); Ge && Re.beforeEnter(xe), o(xe, F, Z), ((pe = Ae && Ae.onVnodeMounted) || Ge || Ue) && Nn(() => { pe && Ar(pe, ue, P), Ge && Re.enter(xe), Ue && go(P, null, ue, 'mounted') }, le) }; const J = (P, F, Z, ue, le) => {
    if (Z && x(P, Z), ue) {
      for (let he = 0; he < ue.length; he++)x(P, ue[he])
    } if (le) { const he = le.subTree; if (F === he) { const Se = le.vnode; J(P, Se, Se.scopeId, Se.slotScopeIds, le.parent) } }
  }; const re = (P, F, Z, ue, le, he, Se, fe, xe = 0) => { for (let pe = xe; pe < P.length; pe++) { const Ae = P[pe] = fe ? Di(P[pe]) : mr(P[pe]); E(null, Ae, F, Z, ue, le, he, Se, fe) } }; const te = (P, F, Z, ue, le, he, Se) => {
    const fe = F.el = P.el; let { patchFlag: xe, dynamicChildren: pe, dirs: Ae } = F; xe |= P.patchFlag & 16; const ze = P.props || St; const Re = F.props || St; let Ue; if (Z && vo(Z, !1), (Ue = Re.onVnodeBeforeUpdate) && Ar(Ue, Z, F, P), Ae && go(F, P, Z, 'beforeUpdate'), Z && vo(Z, !0), (ze.innerHTML && Re.innerHTML == null || ze.textContent && Re.textContent == null) && v(fe, ''), pe ? j(P.dynamicChildren, pe, fe, Z, ue, qf(F, le), he) : Se || ie(P, F, fe, null, Z, ue, qf(F, le), he, !1), xe > 0) {
      if (xe & 16) {
        ne(fe, ze, Re, Z, le)
      }
      else if (xe & 2 && ze.class !== Re.class && c(fe, 'class', null, Re.class, le), xe & 4 && c(fe, 'style', ze.style, Re.style, le), xe & 8) { const Ge = F.dynamicProps; for (let vt = 0; vt < Ge.length; vt++) { const tt = Ge[vt]; const nt = ze[tt]; const It = Re[tt]; (It !== nt || tt === 'value') && c(fe, tt, nt, It, le, Z) } }xe & 1 && P.children !== F.children && v(fe, F.children)
    }
    else {
      !Se && pe == null && ne(fe, ze, Re, Z, le)
    } ((Ue = Re.onVnodeUpdated) || Ae) && Nn(() => { Ue && Ar(Ue, Z, F, P), Ae && go(F, P, Z, 'updated') }, ue)
  }; const j = (P, F, Z, ue, le, he, Se) => { for (let fe = 0; fe < F.length; fe++) { const xe = P[fe]; const pe = F[fe]; const Ae = xe.el && (xe.type === ut || !Nr(xe, pe) || xe.shapeFlag & 70) ? y(xe.el) : Z; E(xe, pe, Ae, null, ue, le, he, Se, !0) } }; const ne = (P, F, Z, ue, le) => {
    if (F !== Z) {
      if (F !== St) {
        for (const he in F)!_l(he) && !(he in Z) && c(P, he, F[he], null, le, ue)
      } for (const he in Z) {
        if (_l(he))
          continue; const Se = Z[he]; const fe = F[he]; Se !== fe && he !== 'value' && c(P, he, fe, Se, le, ue)
      }'value' in Z && c(P, 'value', F.value, Z.value, le)
    }
  }; const K = (P, F, Z, ue, le, he, Se, fe, xe) => { const pe = F.el = P ? P.el : d(''); const Ae = F.anchor = P ? P.anchor : d(''); const { patchFlag: ze, dynamicChildren: Re, slotScopeIds: Ue } = F; Ue && (fe = fe ? fe.concat(Ue) : Ue), P == null ? (o(pe, Z, ue), o(Ae, Z, ue), re(F.children || [], Z, Ae, le, he, Se, fe, xe)) : ze > 0 && ze & 64 && Re && P.dynamicChildren ? (j(P.dynamicChildren, Re, Z, le, he, Se, fe), (F.key != null || le && F === le.subTree) && $y(P, F, !0)) : ie(P, F, Z, Ae, le, he, Se, fe, xe) }; const V = (P, F, Z, ue, le, he, Se, fe, xe) => { F.slotScopeIds = fe, P == null ? F.shapeFlag & 512 ? le.ctx.activate(F, Z, ue, Se, xe) : I(F, Z, ue, le, he, Se, xe) : k(P, F, xe) }; const I = (P, F, Z, ue, le, he, Se) => {
    const fe = P.component = Fk(P, ue, le); if (mu(P) && (fe.ctx.renderer = $e), Hk(fe, !1, Se), fe.asyncDep) { if (le && le.registerDep(fe, B, Se), !P.el) { const xe = fe.subTree = Oe(fn); N(null, xe, F, Z) } }
    else {
      B(fe, P, F, Z, le, he, Se)
    }
  }; const k = (P, F, Z) => {
    const ue = F.component = P.component; if (Ek(P, F, Z)) {
      if (ue.asyncDep && !ue.asyncResolved) { W(ue, F, Z) }
      else {
        ue.next = F, OS(ue.update), ue.effect.dirty = !0, ue.update()
      }
    }
    else {
      F.el = P.el, ue.vnode = F
    }
  }; const B = (P, F, Z, ue, le, he, Se) => {
    const fe = () => {
      if (P.isMounted) { let { next: Ae, bu: ze, u: Re, parent: Ue, vnode: Ge } = P; { const Jt = Oy(P); if (Jt) { Ae && (Ae.el = Ge.el, W(P, Ae, Se)), Jt.asyncDep.then(() => { P.isUnmounted || fe() }); return } } const vt = Ae; let tt; vo(P, !1), Ae ? (Ae.el = Ge.el, W(P, Ae, Se)) : Ae = Ge, ze && yc(ze), (tt = Ae.props && Ae.props.onVnodeBeforeUpdate) && Ar(tt, Ue, Ae, Ge), vo(P, !0); const nt = Bf(P); const It = P.subTree; P.subTree = nt, E(It, nt, y(It.el), X(It), P, le, he), Ae.el = nt.el, vt === null && Eh(P, nt.el), Re && Nn(Re, le), (tt = Ae.props && Ae.props.onVnodeUpdated) && Nn(() => Ar(tt, Ue, Ae, Ge), le) }
      else {
        let Ae; const { el: ze, props: Re } = F; const { bm: Ue, m: Ge, parent: vt } = P; const tt = Cl(F); if (vo(P, !1), Ue && yc(Ue), !tt && (Ae = Re && Re.onVnodeBeforeMount) && Ar(Ae, vt, F), vo(P, !0), ze && Ye) { const nt = () => { P.subTree = Bf(P), Ye(ze, P.subTree, P, le, null) }; tt ? F.type.__asyncLoader().then(() => !P.isUnmounted && nt()) : nt() }
        else { const nt = P.subTree = Bf(P); E(null, nt, Z, ue, P, le, he), F.el = nt.el } if (Ge && Nn(Ge, le), !tt && (Ae = Re && Re.onVnodeMounted)) { const nt = F; Nn(() => Ar(Ae, vt, nt), le) }(F.shapeFlag & 256 || vt && Cl(vt.vnode) && vt.vnode.shapeFlag & 256) && P.a && Nn(P.a, le), P.isMounted = !0, F = Z = ue = null
      }
    }; const xe = P.effect = new ch(fe, Jn, () => wh(pe), P.scope); const pe = P.update = () => { xe.dirty && xe.run() }; pe.i = P, pe.id = P.uid, vo(P, !0), pe()
  }; const W = (P, F, Z) => { F.component = P; const ue = P.vnode.props; P.vnode = F, P.next = null, ak(P, F.props, ue, Z), dk(P, F.children, Z), eo(), yv(P), to() }; const ie = (P, F, Z, ue, le, he, Se, fe, xe = !1) => {
    const pe = P && P.children; const Ae = P ? P.shapeFlag : 0; const ze = F.children; const { patchFlag: Re, shapeFlag: Ue } = F; if (Re > 0) {
      if (Re & 128) { Ne(pe, ze, Z, ue, le, he, Se, fe, xe); return }
      else if (Re & 256) { ye(pe, ze, Z, ue, le, he, Se, fe, xe); return }
    }Ue & 8 ? (Ae & 16 && Ee(pe, le, he), ze !== pe && v(Z, ze)) : Ae & 16 ? Ue & 16 ? Ne(pe, ze, Z, ue, le, he, Se, fe, xe) : Ee(pe, le, he, !0) : (Ae & 8 && v(Z, ''), Ue & 16 && re(ze, Z, ue, le, he, Se, fe, xe))
  }; const ye = (P, F, Z, ue, le, he, Se, fe, xe) => { P = P || ds, F = F || ds; const pe = P.length; const Ae = F.length; const ze = Math.min(pe, Ae); let Re; for (Re = 0; Re < ze; Re++) { const Ue = F[Re] = xe ? Di(F[Re]) : mr(F[Re]); E(P[Re], Ue, Z, null, le, he, Se, fe, xe) }pe > Ae ? Ee(P, le, he, !0, !1, ze) : re(F, Z, ue, le, he, Se, fe, xe, ze) }; const Ne = (P, F, Z, ue, le, he, Se, fe, xe) => {
    let pe = 0; const Ae = F.length; let ze = P.length - 1; let Re = Ae - 1; for (;pe <= ze && pe <= Re;) {
      const Ue = P[pe]; const Ge = F[pe] = xe ? Di(F[pe]) : mr(F[pe]); if (Nr(Ue, Ge))
        E(Ue, Ge, Z, null, le, he, Se, fe, xe); else break; pe++
    } for (;pe <= ze && pe <= Re;) {
      const Ue = P[ze]; const Ge = F[Re] = xe ? Di(F[Re]) : mr(F[Re]); if (Nr(Ue, Ge))
        E(Ue, Ge, Z, null, le, he, Se, fe, xe); else break; ze--, Re--
    } if (pe > ze) { if (pe <= Re) { const Ue = Re + 1; const Ge = Ue < Ae ? F[Ue].el : ue; for (;pe <= Re;)E(null, F[pe] = xe ? Di(F[pe]) : mr(F[pe]), Z, Ge, le, he, Se, fe, xe), pe++ } }
    else if (pe > Re) {
      for (;pe <= ze;)je(P[pe], le, he, !0), pe++
    }
    else {
      const Ue = pe; const Ge = pe; const vt = new Map(); for (pe = Ge; pe <= Re; pe++) { const Qt = F[pe] = xe ? Di(F[pe]) : mr(F[pe]); Qt.key != null && vt.set(Qt.key, pe) } let tt; let nt = 0; const It = Re - Ge + 1; let Jt = !1; let or = 0; const Fn = new Array(It); for (pe = 0; pe < It; pe++)Fn[pe] = 0; for (pe = Ue; pe <= ze; pe++) {
        const Qt = P[pe]; if (nt >= It) { je(Qt, le, he, !0); continue } let Ve; if (Qt.key != null) {
          Ve = vt.get(Qt.key)
        }
        else {
          for (tt = Ge; tt <= Re; tt++) {
            if (Fn[tt - Ge] === 0 && Nr(Qt, F[tt])) { Ve = tt; break }
          }
        }Ve === void 0 ? je(Qt, le, he, !0) : (Fn[Ve - Ge] = pe + 1, Ve >= or ? or = Ve : Jt = !0, E(Qt, F[Ve], Z, null, le, he, Se, fe, xe), nt++)
      } const sr = Jt ? yk(Fn) : ds; for (tt = sr.length - 1, pe = It - 1; pe >= 0; pe--) { const Qt = Ge + pe; const Ve = F[Qt]; const no = Qt + 1 < Ae ? F[Qt + 1].el : ue; Fn[pe] === 0 ? E(null, Ve, Z, no, le, he, Se, fe, xe) : Jt && (tt < 0 || pe !== sr[tt] ? We(Ve, Z, no, 2) : tt--) }
    }
  }; const We = (P, F, Z, ue, le = null) => {
    const { el: he, type: Se, transition: fe, children: xe, shapeFlag: pe } = P; if (pe & 6) { We(P.component.subTree, F, Z, ue); return } if (pe & 128) { P.suspense.move(F, Z, ue); return } if (pe & 64) { Se.move(P, F, Z, $e); return } if (Se === ut) { o(he, F, Z); for (let ze = 0; ze < xe.length; ze++)We(xe[ze], F, Z, ue); o(P.anchor, F, Z); return } if (Se === Wf) { O(P, F, Z); return } if (ue !== 2 && pe & 1 && fe) {
      if (ue === 0) {
        fe.beforeEnter(he), o(he, F, Z), Nn(() => fe.enter(he), le)
      }
      else { const { leave: ze, delayLeave: Re, afterLeave: Ue } = fe; const Ge = () => o(he, F, Z); const vt = () => { ze(he, () => { Ge(), Ue && Ue() }) }; Re ? Re(he, Ge, vt) : vt() }
    }
    else {
      o(he, F, Z)
    }
  }; const je = (P, F, Z, ue = !1, le = !1) => {
    const { type: he, props: Se, ref: fe, children: xe, dynamicChildren: pe, shapeFlag: Ae, patchFlag: ze, dirs: Re, cacheIndex: Ue } = P; if (ze === -2 && (le = !1), fe != null && wd(fe, null, Z, P, !0), Ue != null && (F.renderCache[Ue] = void 0), Ae & 256) { F.ctx.deactivate(P); return } const Ge = Ae & 1 && Re; const vt = !Cl(P); let tt; if (vt && (tt = Se && Se.onVnodeBeforeUnmount) && Ar(tt, F, P), Ae & 6) {
      Ze(P.component, Z, ue)
    }
    else { if (Ae & 128) { P.suspense.unmount(Z, ue); return }Ge && go(P, null, F, 'beforeUnmount'), Ae & 64 ? P.type.remove(P, F, Z, $e, ue) : pe && !pe.hasOnce && (he !== ut || ze > 0 && ze & 64) ? Ee(pe, F, Z, !1, !0) : (he === ut && ze & 384 || !le && Ae & 16) && Ee(xe, F, Z), ue && it(P) }(vt && (tt = Se && Se.onVnodeUnmounted) || Ge) && Nn(() => { tt && Ar(tt, F, P), Ge && go(P, null, F, 'unmounted') }, Z)
  }; const it = (P) => {
    const { type: F, el: Z, anchor: ue, transition: le } = P; if (F === ut) { rt(Z, ue); return } if (F === Wf) { A(P); return } const he = () => { s(Z), le && !le.persisted && le.afterLeave && le.afterLeave() }; if (P.shapeFlag & 1 && le && !le.persisted) { const { leave: Se, delayLeave: fe } = le; const xe = () => Se(Z, he); fe ? fe(P.el, he, xe) : xe() }
    else {
      he()
    }
  }; const rt = (P, F) => { let Z; for (;P !== F;)Z = b(P), s(P), P = Z; s(F) }; const Ze = (P, F, Z) => { const { bum: ue, scope: le, update: he, subTree: Se, um: fe, m: xe, a: pe } = P; Av(xe), Av(pe), ue && yc(ue), le.stop(), he && (he.active = !1, je(Se, P, F, Z)), fe && Nn(fe, F), Nn(() => { P.isUnmounted = !0 }, F), F && F.pendingBranch && !F.isUnmounted && P.asyncDep && !P.asyncResolved && P.suspenseId === F.pendingId && (F.deps--, F.deps === 0 && F.resolve()) }; const Ee = (P, F, Z, ue = !1, le = !1, he = 0) => { for (let Se = he; Se < P.length; Se++)je(P[Se], F, Z, ue, le) }; const X = (P) => {
    if (P.shapeFlag & 6)
      return X(P.component.subTree); if (P.shapeFlag & 128)
      return P.suspense.next(); const F = b(P.anchor || P.el); const Z = F && F[hk]; return Z ? b(Z) : F
  }; let ae = !1; const de = (P, F, Z) => { P == null ? F._vnode && je(F._vnode, null, null, !0) : E(F._vnode || null, P, F, null, null, null, Z), ae || (ae = !0, yv(), uy(), ae = !1), F._vnode = P }; const $e = { p: E, um: je, m: We, r: it, mt: I, mc: re, pc: ie, pbc: j, n: X, o: e }; let Te, Ye; return { render: de, hydrate: Te, createApp: sk(de, Te) }
} function qf({ type: e, props: t }, r) { return r === 'svg' && e === 'foreignObject' || r === 'mathml' && e === 'annotation-xml' && t && t.encoding && t.encoding.includes('html') ? void 0 : r } function vo({ effect: e, update: t }, r) { e.allowRecurse = t.allowRecurse = r } function mk(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function $y(e, t, r = !1) {
  const o = e.children; const s = t.children; if (Ie(o) && Ie(s)) {
    for (let c = 0; c < o.length; c++) { const f = o[c]; let d = s[c]; d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = s[c] = Di(s[c]), d.el = f.el), !r && d.patchFlag !== -2 && $y(f, d)), d.type === _u && (d.el = f.el) }
  }
} function yk(e) { const t = e.slice(); const r = [0]; let o, s, c, f, d; const h = e.length; for (o = 0; o < h; o++) { const g = e[o]; if (g !== 0) { if (s = r[r.length - 1], e[s] < g) { t[o] = s, r.push(o); continue } for (c = 0, f = r.length - 1; c < f;)d = c + f >> 1, e[r[d]] < g ? c = d + 1 : f = d; g < e[r[c]] && (c > 0 && (t[o] = r[c - 1]), r[c] = o) } } for (c = r.length, f = r[c - 1]; c-- > 0;)r[c] = f, f = t[f]; return r } function Oy(e) {
  const t = e.subTree.component; if (t)
    return t.asyncDep && !t.asyncResolved ? t : Oy(t)
} function Av(e) {
  if (e) {
    for (let t = 0; t < e.length; t++)e[t].active = !1
  }
} const bk = Symbol.for('v-scx'); const wk = () => ri(bk); function Ch(e, t) { return wu(e, null, t) } function xk(e, t) { return wu(e, null, { flush: 'sync' }) } const rc = {}; function Ht(e, t, r) { return wu(e, t, r) } function wu(e, t, { immediate: r, deep: o, flush: s, once: c, onTrack: f, onTrigger: d } = St) {
  if (t && c) { const z = t; t = (...J) => { z(...J), H() } } const h = sn; const g = z => o === !0 ? z : Hi(z, o === !1 ? 1 : void 0); let v; let y = !1; let b = !1; if (Ot(e)
    ? (v = () => e.value, y = _s(e))
    : Sl(e)
      ? (v = () => g(e), y = !0)
      : Ie(e)
        ? (b = !0, y = e.some(z => Sl(z) || _s(z)), v = () => e.map((z) => {
            if (Ot(z))
              return z.value; if (Sl(z))
              return g(z); if (Xe(z))
              return Vi(z, h, 2)
          }))
        : Xe(e) ? t ? v = () => Vi(e, h, 2) : v = () => (x && x(), tr(e, h, 3, [T])) : v = Jn, t && o) { const z = v; v = () => Hi(z()) } let x; let T = (z) => { x = O.onStop = () => { Vi(z, h, 4), x = O.onStop = void 0 } }; let E; if (Su) {
    if (T = Jn, t ? r && tr(t, h, 3, [v(), b ? [] : void 0, T]) : v(), s === 'sync') { const z = wk(); E = z.__watcherHandles || (z.__watcherHandles = []) }
    else {
      return Jn
    }
  } let M = b ? Array.from({ length: e.length }).fill(rc) : rc; const N = () => {
    if (!(!O.active || !O.dirty)) {
      if (t) { const z = O.run(); (o || y || (b ? z.some((J, re) => zr(J, M[re])) : zr(z, M))) && (x && x(), tr(t, h, 3, [z, M === rc ? void 0 : b && M[0] === rc ? [] : M, T]), M = z) }
      else {
        O.run()
      }
    }
  }; N.allowRecurse = !!t; let L; s === 'sync' ? L = N : s === 'post' ? L = () => Nn(N, h && h.suspense) : (N.pre = !0, h && (N.id = h.uid), L = () => wh(N)); const O = new ch(v, Jn, L); const A = U0(); const H = () => { O.stop(), A && lh(A.effects, O) }; return t ? r ? N() : M = O.run() : s === 'post' ? Nn(O.run.bind(O), h && h.suspense) : O.run(), E && E.push(H), H
} function _k(e, t, r) { const o = this.proxy; const s = $t(e) ? e.includes('.') ? Py(o, e) : () => o[e] : e.bind(o, o); let c; Xe(t) ? c = t : (c = t.handler, r = t); const f = ua(this); const d = wu(s, c.bind(o), r); return f(), d } function Py(e, t) { const r = t.split('.'); return () => { let o = e; for (let s = 0; s < r.length && o; s++)o = o[r[s]]; return o } } function Hi(e, t = 1 / 0, r) {
  if (t <= 0 || !xt(e) || e.__v_skip || (r = r || new Set(), r.has(e)))
    return e; if (r.add(e), t--, Ot(e)) {
    Hi(e.value, t, r)
  }
  else if (Ie(e)) {
    for (let o = 0; o < e.length; o++)Hi(e[o], t, r)
  }
  else if (uu(e) || hs(e)) {
    e.forEach((o) => { Hi(o, t, r) })
  }
  else if (D0(e)) { for (const o in e)Hi(e[o], t, r); for (const o of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e, o) && Hi(e[o], t, r) } return e
} function Th(e, t, r = St) {
  const o = ca(); const s = nr(t); const c = ui(t); const f = Ry(e, t); const d = sy((h, g) => {
    let v, y, b; return xk(() => { const x = e[t]; zr(v, x) && (v = x, g()) }), { get() { return h(), r.get ? r.get(v) : v }, set(x) {
      if (!zr(x, v))
        return; const T = o.vnode.props; T && (t in T || s in T || c in T) && (`onUpdate:${t}` in T || `onUpdate:${s}` in T || `onUpdate:${c}` in T) || (v = x, g()); const E = r.set ? r.set(x) : x; o.emit(`update:${t}`, E), x !== E && x !== y && E === b && g(), y = x, b = E
    } }
  }); return d[Symbol.iterator] = () => { let h = 0; return { next() { return h < 2 ? { value: h++ ? f || St : d, done: !1 } : { done: !0 } } } }, d
} const Ry = (e, t) => t === 'modelValue' || t === 'model-value' ? e.modelModifiers : e[`${t}Modifiers`] || e[`${nr(t)}Modifiers`] || e[`${ui(t)}Modifiers`]; function Sk(e, t, ...r) {
  if (e.isUnmounted)
    return; const o = e.vnode.props || St; let s = r; const c = t.startsWith('update:'); const f = c && Ry(o, t.slice(7)); f && (f.trim && (s = r.map(v => $t(v) ? v.trim() : v)), f.number && (s = r.map(cd))); let d; let h = o[d = mc(t)] || o[d = mc(nr(t))]; !h && c && (h = o[d = mc(ui(t))]), h && tr(h, e, 6, s); const g = o[`${d}Once`]; if (g) {
    if (!e.emitted)
      e.emitted = {}; else if (e.emitted[d])
      return; e.emitted[d] = !0, tr(g, e, 6, s)
  }
} function Dy(e, t, r = !1) {
  const o = t.emitsCache; const s = o.get(e); if (s !== void 0)
    return s; const c = e.emits; const f = {}; let d = !1; if (!Xe(e)) { const h = (g) => { const v = Dy(g, t, !0); v && (d = !0, Gt(f, v)) }; !r && t.mixins.length && t.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h) } return !c && !d ? (xt(e) && o.set(e, null), null) : (Ie(c) ? c.forEach(h => f[h] = null) : Gt(f, c), xt(e) && o.set(e, f), f)
} function xu(e, t) { return !e || !cu(t) ? !1 : (t = t.slice(2).replace(/Once$/, ''), ct(e, t[0].toLowerCase() + t.slice(1)) || ct(e, ui(t)) || ct(e, t)) } function Bf(e) {
  const { type: t, vnode: r, proxy: o, withProxy: s, propsOptions: [c], slots: f, attrs: d, emit: h, render: g, renderCache: v, props: y, data: b, setupState: x, ctx: T, inheritAttrs: E } = e; const M = Rc(e); let N, L; try {
    if (r.shapeFlag & 4) { const A = s || o; const H = A; N = mr(g.call(H, A, v, y, x, b, T)), L = d }
    else { const A = t; N = mr(A.length > 1 ? A(y, { attrs: d, slots: f, emit: h }) : A(y, null)), L = t.props ? d : Ck(d) }
  }
  catch (A) { Ll.length = 0, sa(A, e, 1), N = Oe(fn) } let O = N; if (L && E !== !1) { const A = Object.keys(L); const { shapeFlag: H } = O; A.length && H & 7 && (c && A.some(sh) && (L = Tk(L, c)), O = Ki(O, L, !1, !0)) } return r.dirs && (O = Ki(O, null, !1, !0), O.dirs = O.dirs ? O.dirs.concat(r.dirs) : r.dirs), r.transition && (O.transition = r.transition), N = O, Rc(M), N
} function kk(e, t = !0) {
  let r; for (let o = 0; o < e.length; o++) {
    const s = e[o]; if (ql(s)) {
      if (s.type !== fn || s.children === 'v-if') {
        if (r)
          return; r = s
      }
    }
    else {
      return
    }
  } return r
} function Ck(e) { let t; for (const r in e)(r === 'class' || r === 'style' || cu(r)) && ((t || (t = {}))[r] = e[r]); return t } function Tk(e, t) { const r = {}; for (const o in e)(!sh(o) || !(o.slice(9) in t)) && (r[o] = e[o]); return r } function Ek(e, t, r) {
  const { props: o, children: s, component: c } = e; const { props: f, children: d, patchFlag: h } = t; const g = c.emitsOptions; if (t.dirs || t.transition)
    return !0; if (r && h >= 0) {
    if (h & 1024)
      return !0; if (h & 16)
      return o ? Mv(o, f, g) : !!f; if (h & 8) {
      const v = t.dynamicProps; for (let y = 0; y < v.length; y++) {
        const b = v[y]; if (f[b] !== o[b] && !xu(g, b))
          return !0
      }
    }
  }
  else {
    return (s || d) && (!d || !d.$stable) ? !0 : o === f ? !1 : o ? f ? Mv(o, f, g) : !0 : !!f
  } return !1
} function Mv(e, t, r) {
  const o = Object.keys(t); if (o.length !== Object.keys(e).length)
    return !0; for (let s = 0; s < o.length; s++) {
    const c = o[s]; if (t[c] !== e[c] && !xu(r, c))
      return !0
  } return !1
} function Eh({ vnode: e, parent: t }, r) {
  for (;t;) {
    const o = t.subTree; if (o.suspense && o.suspense.activeBranch === e && (o.el = e.el), o === e)
      (e = t.vnode).el = r, t = t.parent; else break
  }
} const Lk = e => e.__isSuspense; let xd = 0; const Ak = { name: 'Suspense', __isSuspense: !0, process(e, t, r, o, s, c, f, d, h, g) {
  if (e == null) {
    Mk(t, r, o, s, c, f, d, h, g)
  }
  else { if (c && c.deps > 0 && !e.suspense.isInFallback) { t.suspense = e.suspense, t.suspense.vnode = t, t.el = e.el; return }Nk(e, t, r, o, s, f, d, h, g) }
}, hydrate: $k, normalize: Ok }; const zy = Ak; function Hl(e, t) { const r = e.props && e.props[t]; Xe(r) && r() } function Mk(e, t, r, o, s, c, f, d, h) { const { p: g, o: { createElement: v } } = h; const y = v('div'); const b = e.suspense = Iy(e, s, o, t, y, r, c, f, d, h); g(null, b.pendingBranch = e.ssContent, y, null, o, b, c, f), b.deps > 0 ? (Hl(e, 'onPending'), Hl(e, 'onFallback'), g(null, e.ssFallback, t, r, o, null, c, f), gs(b, e.ssFallback)) : b.resolve(!1, !0) } function Nk(e, t, r, o, s, c, f, d, { p: h, um: g, o: { createElement: v } }) {
  const y = t.suspense = e.suspense; y.vnode = t, t.el = e.el; const b = t.ssContent; const x = t.ssFallback; const { activeBranch: T, pendingBranch: E, isInFallback: M, isHydrating: N } = y; if (E) {
    y.pendingBranch = b, Nr(b, E) ? (h(E, b, y.hiddenContainer, null, s, y, c, f, d), y.deps <= 0 ? y.resolve() : M && (N || (h(T, x, r, o, s, null, c, f, d), gs(y, x)))) : (y.pendingId = xd++, N ? (y.isHydrating = !1, y.activeBranch = E) : g(E, s, y), y.deps = 0, y.effects.length = 0, y.hiddenContainer = v('div'), M ? (h(null, b, y.hiddenContainer, null, s, y, c, f, d), y.deps <= 0 ? y.resolve() : (h(T, x, r, o, s, null, c, f, d), gs(y, x))) : T && Nr(b, T) ? (h(T, b, r, o, s, y, c, f, d), y.resolve(!0)) : (h(null, b, y.hiddenContainer, null, s, y, c, f, d), y.deps <= 0 && y.resolve()))
  }
  else if (T && Nr(b, T)) {
    h(T, b, r, o, s, y, c, f, d), gs(y, b)
  }
  else if (Hl(t, 'onPending'), y.pendingBranch = b, b.shapeFlag & 512 ? y.pendingId = b.component.suspenseId : y.pendingId = xd++, h(null, b, y.hiddenContainer, null, s, y, c, f, d), y.deps <= 0) {
    y.resolve()
  }
  else { const { timeout: L, pendingId: O } = y; L > 0 ? setTimeout(() => { y.pendingId === O && y.fallback(x) }, L) : L === 0 && y.fallback(x) }
} function Iy(e, t, r, o, s, c, f, d, h, g, v = !1) {
  const { p: y, m: b, um: x, n: T, o: { parentNode: E, remove: M } } = g; let N; const L = Rk(e); L && t && t.pendingBranch && (N = t.pendingId, t.deps++); const O = e.props ? I0(e.props.timeout) : void 0; const A = c; const H = { vnode: e, parent: t, parentComponent: r, namespace: f, container: o, hiddenContainer: s, deps: 0, pendingId: xd++, timeout: typeof O == 'number' ? O : -1, activeBranch: null, pendingBranch: null, isInFallback: !v, isHydrating: v, isUnmounted: !1, effects: [], resolve(z = !1, J = !1) { const { vnode: re, activeBranch: te, pendingBranch: j, pendingId: ne, effects: K, parentComponent: V, container: I } = H; let k = !1; H.isHydrating ? H.isHydrating = !1 : z || (k = te && j.transition && j.transition.mode === 'out-in', k && (te.transition.afterLeave = () => { ne === H.pendingId && (b(j, I, c === A ? T(te) : c, 0), pd(K)) }), te && (E(te.el) !== H.hiddenContainer && (c = T(te)), x(te, V, H, !0)), k || b(j, I, c, 0)), gs(H, j), H.pendingBranch = null, H.isInFallback = !1; let B = H.parent; let W = !1; for (;B;) { if (B.pendingBranch) { B.effects.push(...K), W = !0; break }B = B.parent }!W && !k && pd(K), H.effects = [], L && t && t.pendingBranch && N === t.pendingId && (t.deps--, t.deps === 0 && !J && t.resolve()), Hl(re, 'onResolve') }, fallback(z) {
    if (!H.pendingBranch)
      return; const { vnode: J, activeBranch: re, parentComponent: te, container: j, namespace: ne } = H; Hl(J, 'onFallback'); const K = T(re); const V = () => { H.isInFallback && (y(null, z, j, K, te, null, ne, d, h), gs(H, z)) }; const I = z.transition && z.transition.mode === 'out-in'; I && (re.transition.afterLeave = V), H.isInFallback = !0, x(re, te, null, !0), I || V()
  }, move(z, J, re) { H.activeBranch && b(H.activeBranch, z, J, re), H.container = z }, next() { return H.activeBranch && T(H.activeBranch) }, registerDep(z, J, re) {
    const te = !!H.pendingBranch; te && H.deps++; const j = z.vnode.el; z.asyncDep.catch((ne) => { sa(ne, z, 0) }).then((ne) => {
      if (z.isUnmounted || H.isUnmounted || H.pendingId !== z.suspenseId)
        return; z.asyncResolved = !0; const { vnode: K } = z; Sd(z, ne, !1), j && (K.el = j); const V = !j && z.subTree.el; J(z, K, E(j || z.subTree.el), j ? null : T(z.subTree), H, f, re), V && M(V), Eh(z, K.el), te && --H.deps === 0 && H.resolve()
    })
  }, unmount(z, J) { H.isUnmounted = !0, H.activeBranch && x(H.activeBranch, r, z, J), H.pendingBranch && x(H.pendingBranch, r, z, J) } }; return H
} function $k(e, t, r, o, s, c, f, d, h) { const g = t.suspense = Iy(t, o, r, e.parentNode, document.createElement('div'), null, s, c, f, d, !0); const v = h(e, g.pendingBranch = t.ssContent, r, g, c, f); return g.deps === 0 && g.resolve(!1, !0), v } function Ok(e) { const { shapeFlag: t, children: r } = e; const o = t & 32; e.ssContent = Nv(o ? r.default : r), e.ssFallback = o ? Nv(r.fallback) : Oe(fn) } function Nv(e) { let t; if (Xe(e)) { const r = Ss && e._c; r && (e._d = !1, oe()), e = e(), r && (e._d = !0, t = Rn, Fy()) } return Ie(e) && (e = kk(e)), e = mr(e), t && !e.dynamicChildren && (e.dynamicChildren = t.filter(r => r !== e)), e } function Pk(e, t) { t && t.pendingBranch ? Ie(e) ? t.effects.push(...e) : t.effects.push(e) : pd(e) } function gs(e, t) { e.activeBranch = t; const { vnode: r, parentComponent: o } = e; let s = t.el; for (;!s && t.component;)t = t.component.subTree, s = t.el; r.el = s, o && o.subTree === r && (o.vnode.el = s, Eh(o, s)) } function Rk(e) { const t = e.props && e.props.suspensible; return t != null && t !== !1 } const ut = Symbol.for('v-fgt'); const _u = Symbol.for('v-txt'); const fn = Symbol.for('v-cmt'); const Wf = Symbol.for('v-stc'); const Ll = []; let Rn = null; function oe(e = !1) { Ll.push(Rn = e ? null : []) } function Fy() { Ll.pop(), Rn = Ll[Ll.length - 1] || null } let Ss = 1; function Hc(e) { Ss += e, e < 0 && Rn && (Rn.hasOnce = !0) } function Hy(e) { return e.dynamicChildren = Ss > 0 ? Rn || ds : null, Fy(), Ss > 0 && Rn && Rn.push(e), e } function me(e, t, r, o, s, c) { return Hy(Y(e, t, r, o, s, c, !0)) } function ot(e, t, r, o, s) { return Hy(Oe(e, t, r, o, s, !0)) } function ql(e) { return e ? e.__v_isVNode === !0 : !1 } function Nr(e, t) { return e.type === t.type && e.key === t.key } const qy = ({ key: e }) => e ?? null; const wc = ({ ref: e, ref_key: t, ref_for: r }) => (typeof e == 'number' && (e = `${e}`), e != null ? $t(e) || Ot(e) || Xe(e) ? { i: Yt, r: e, k: t, f: !!r } : e : null); function Y(e, t = null, r = null, o = 0, s = null, c = e === ut ? 0 : 1, f = !1, d = !1) { const h = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && qy(t), ref: t && wc(t), scopeId: vu, slotScopeIds: null, children: r, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: c, patchFlag: o, dynamicProps: s, dynamicChildren: null, appContext: null, ctx: Yt }; return d ? (Lh(h, r), c & 128 && e.normalize(h)) : r && (h.shapeFlag |= $t(r) ? 8 : 16), Ss > 0 && !f && Rn && (h.patchFlag > 0 || c & 6) && h.patchFlag !== 32 && Rn.push(h), h } const Oe = Dk; function Dk(e, t = null, r = null, o = 0, s = null, c = !1) { if ((!e || e === by) && (e = fn), ql(e)) { const d = Ki(e, t, !0); return r && Lh(d, r), Ss > 0 && !c && Rn && (d.shapeFlag & 6 ? Rn[Rn.indexOf(e)] = d : Rn.push(d)), d.patchFlag = -2, d } if (Uk(e) && (e = e.__vccOpts), t) { t = By(t); let { class: d, style: h } = t; d && !$t(d) && (t.class = lt(d)), xt(h) && (ny(h) && !Ie(h) && (h = Gt({}, h)), t.style = Zt(h)) } const f = $t(e) ? 1 : Lk(e) ? 128 : pk(e) ? 64 : xt(e) ? 4 : Xe(e) ? 2 : 0; return Y(e, t, r, o, s, f, c, !0) } function By(e) { return e ? ny(e) || Cy(e) ? Gt({}, e) : e : null } function Ki(e, t, r = !1, o = !1) { const { props: s, ref: c, patchFlag: f, children: d, transition: h } = e; const g = t ? ii(s || {}, t) : s; const v = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: g, key: g && qy(g), ref: t && t.ref ? r && c ? Ie(c) ? c.concat(wc(t)) : [c, wc(t)] : wc(t) : c, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: d, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== ut ? f === -1 ? 16 : f | 16 : f, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: h, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Ki(e.ssContent), ssFallback: e.ssFallback && Ki(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return h && o && Dc(v, h.clone(v)), v } function gt(e = ' ', t = 0) { return Oe(_u, null, e, t) } function et(e = '', t = !1) { return t ? (oe(), ot(fn, null, e)) : Oe(fn, null, e) } function mr(e) { return e == null || typeof e == 'boolean' ? Oe(fn) : Ie(e) ? Oe(ut, null, e.slice()) : typeof e == 'object' ? Di(e) : Oe(_u, null, String(e)) } function Di(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Ki(e) } function Lh(e, t) {
  let r = 0; const { shapeFlag: o } = e; if (t == null) {
    t = null
  }
  else if (Ie(t)) {
    r = 16
  }
  else if (typeof t == 'object') {
    if (o & 65) { const s = t.default; s && (s._c && (s._d = !1), Lh(e, s()), s._c && (s._d = !0)); return }
    else { r = 32; const s = t._; !s && !Cy(t) ? t._ctx = Yt : s === 3 && Yt && (Yt.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) }
  }
  else {
    Xe(t) ? (t = { default: t, _ctx: Yt }, r = 32) : (t = String(t), o & 64 ? (r = 16, t = [gt(t)]) : r = 8)
  }e.children = t, e.shapeFlag |= r
} function ii(...e) {
  const t = {}; for (let r = 0; r < e.length; r++) {
    const o = e[r]; for (const s in o) {
      if (s === 'class') {
        t.class !== o.class && (t.class = lt([t.class, o.class]))
      }
      else if (s === 'style') {
        t.style = Zt([t.style, o.style])
      }
      else if (cu(s)) { const c = t[s]; const f = o[s]; f && c !== f && !(Ie(c) && c.includes(f)) && (t[s] = c ? [].concat(c, f) : f) }
      else {
        s !== '' && (t[s] = o[s])
      }
    }
  } return t
} function Ar(e, t, r, o = null) { tr(e, t, 7, [r, o]) } const zk = _y(); let Ik = 0; function Fk(e, t, r) { const o = e.type; const s = (t ? t.appContext : e.appContext) || zk; const c = { uid: Ik++, vnode: e, type: o, parent: t, appContext: s, root: null, next: null, subTree: null, effect: null, update: null, scope: new tS(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(s.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: Ey(o, s), emitsOptions: Dy(o, s), emit: null, emitted: null, propsDefaults: St, inheritAttrs: o.inheritAttrs, ctx: St, data: St, props: St, attrs: St, slots: St, refs: St, setupState: St, setupContext: null, suspense: r, suspenseId: r ? r.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return c.ctx = { _: c }, c.root = t ? t.root : c, c.emit = Sk.bind(null, c), e.ce && e.ce(c), c } let sn = null; const ca = () => sn || Yt; let qc, _d; { const e = F0(); const t = (r, o) => { let s; return (s = e[r]) || (s = e[r] = []), s.push(o), (c) => { s.length > 1 ? s.forEach(f => f(c)) : s[0](c) } }; qc = t('__VUE_INSTANCE_SETTERS__', r => sn = r), _d = t('__VUE_SSR_SETTERS__', r => Su = r) } function ua(e) { const t = sn; return qc(e), e.scope.on(), () => { e.scope.off(), qc(t) } } function $v() { sn && sn.scope.off(), qc(null) } function Wy(e) { return e.vnode.shapeFlag & 4 } let Su = !1; function Hk(e, t = !1, r = !1) { t && _d(t); const { props: o, children: s } = e.vnode; const c = Wy(e); lk(e, o, c, t), fk(e, s, r); const f = c ? qk(e, t) : void 0; return t && _d(!1), f } function qk(e, t) {
  const r = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, ZS); const { setup: o } = r; if (o) {
    const s = e.setupContext = o.length > 1 ? Vy(e) : null; const c = ua(e); eo(); const f = Vi(o, e, 0, [e.props, s]); if (to(), c(), P0(f)) {
      if (f.then($v, $v), t)
        return f.then((d) => { Sd(e, d, t) }).catch((d) => { sa(d, e, 0) }); e.asyncDep = f
    }
    else {
      Sd(e, f, t)
    }
  }
  else {
    Uy(e, t)
  }
} function Sd(e, t, r) { Xe(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : xt(t) && (e.setupState = oy(t)), Uy(e, r) } let Ov; function Uy(e, t, r) {
  const o = e.type; if (!e.render) { if (!t && Ov && !o.render) { const s = o.template || Sh(e).template; if (s) { const { isCustomElement: c, compilerOptions: f } = e.appContext.config; const { delimiters: d, compilerOptions: h } = o; const g = Gt(Gt({ isCustomElement: c, delimiters: d }, f), h); o.render = Ov(s, g) } }e.render = o.render || Jn } { const s = ua(e); eo(); try { ek(e) }
  finally { to(), s() } }
} const Bk = { get(e, t) { return zn(e, 'get', ''), e[t] } }; function Vy(e) { const t = (r) => { e.exposed = r || {} }; return { attrs: new Proxy(e.attrs, Bk), slots: e.slots, emit: e.emit, expose: t } } function ku(e) {
  return e.exposed
    ? e.exposeProxy || (e.exposeProxy = new Proxy(oy(vh(e.exposed)), { get(t, r) {
      if (r in t)
        return t[r]; if (r in Tl)
        return Tl[r](e)
    }, has(t, r) { return r in t || r in Tl } }))
    : e.proxy
} function Wk(e, t = !0) { return Xe(e) ? e.displayName || e.name : e.name || t && e.__name } function Uk(e) { return Xe(e) && '__vccOpts' in e } const Me = (e, t) => kS(e, t, Su); function fa(e, t, r) { const o = arguments.length; return o === 2 ? xt(t) && !Ie(t) ? ql(t) ? Oe(e, null, [t]) : Oe(e, t) : Oe(e, null, t) : (o > 3 ? r = Array.prototype.slice.call(arguments, 2) : o === 3 && ql(r) && (r = [r]), Oe(e, t, r)) } const Vk = '3.4.33'/**
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************* * @vue/runtime-dom v3.4.33
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************* * (c) 2018-present Yuxi (Evan) You and Vue contributors
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************* * @license MIT
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} ************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************* *
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}} */const jk = 'http://www.w3.org/2000/svg'; const Gk = 'http://www.w3.org/1998/Math/MathML'; const Qr = typeof document < 'u' ? document : null; const Pv = Qr && Qr.createElement('template'); const Kk = { insert: (e, t, r) => { t.insertBefore(e, r || null) }, remove: (e) => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, r, o) => { const s = t === 'svg' ? Qr.createElementNS(jk, e) : t === 'mathml' ? Qr.createElementNS(Gk, e) : r ? Qr.createElement(e, { is: r }) : Qr.createElement(e); return e === 'select' && o && o.multiple != null && s.setAttribute('multiple', o.multiple), s }, createText: e => Qr.createTextNode(e), createComment: e => Qr.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => Qr.querySelector(e), setScopeId(e, t) { e.setAttribute(t, '') }, insertStaticContent(e, t, r, o, s, c) {
  const f = r ? r.previousSibling : t.lastChild; if (s && (s === c || s.nextSibling)) {
    for (;t.insertBefore(s.cloneNode(!0), r), !(s === c || !(s = s.nextSibling)););
  }
  else { Pv.innerHTML = o === 'svg' ? `<svg>${e}</svg>` : o === 'mathml' ? `<math>${e}</math>` : e; const d = Pv.content; if (o === 'svg' || o === 'mathml') { const h = d.firstChild; for (;h.firstChild;)d.appendChild(h.firstChild); d.removeChild(h) }t.insertBefore(d, r) } return [f ? f.nextSibling : t.firstChild, r ? r.previousSibling : t.lastChild]
} }; const Li = 'transition'; const dl = 'animation'; const Bl = Symbol('_vtc'); const Ah = (e, { slots: t }) => fa(zS, Xk(e), t); Ah.displayName = 'Transition'; const jy = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }; Ah.props = Gt({}, hy, jy); function mo(e, t = []) { Ie(e) ? e.forEach(r => r(...t)) : e && e(...t) } const Rv = e => e ? Ie(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function Xk(e) {
  const t = {}; for (const K in e)K in jy || (t[K] = e[K]); if (e.css === !1)
    return t; const { name: r = 'v', type: o, duration: s, enterFromClass: c = `${r}-enter-from`, enterActiveClass: f = `${r}-enter-active`, enterToClass: d = `${r}-enter-to`, appearFromClass: h = c, appearActiveClass: g = f, appearToClass: v = d, leaveFromClass: y = `${r}-leave-from`, leaveActiveClass: b = `${r}-leave-active`, leaveToClass: x = `${r}-leave-to` } = e; const T = Yk(s); const E = T && T[0]; const M = T && T[1]; const { onBeforeEnter: N, onEnter: L, onEnterCancelled: O, onLeave: A, onLeaveCancelled: H, onBeforeAppear: z = N, onAppear: J = L, onAppearCancelled: re = O } = t; const te = (K, V, I) => { yo(K, V ? v : d), yo(K, V ? g : f), I && I() }; const j = (K, V) => { K._isLeaving = !1, yo(K, y), yo(K, x), yo(K, b), V && V() }; const ne = K => (V, I) => { const k = K ? J : L; const B = () => te(V, K, I); mo(k, [V, B]), Dv(() => { yo(V, K ? h : c), Ai(V, K ? v : d), Rv(k) || zv(V, o, E, B) }) }; return Gt(t, { onBeforeEnter(K) { mo(N, [K]), Ai(K, c), Ai(K, f) }, onBeforeAppear(K) { mo(z, [K]), Ai(K, h), Ai(K, g) }, onEnter: ne(!1), onAppear: ne(!0), onLeave(K, V) { K._isLeaving = !0; const I = () => j(K, V); Ai(K, y), Ai(K, b), Qk(), Dv(() => { K._isLeaving && (yo(K, y), Ai(K, x), Rv(A) || zv(K, o, M, I)) }), mo(A, [K, I]) }, onEnterCancelled(K) { te(K, !1), mo(O, [K]) }, onAppearCancelled(K) { te(K, !0), mo(re, [K]) }, onLeaveCancelled(K) { j(K), mo(H, [K]) } })
} function Yk(e) {
  if (e == null)
    return null; if (xt(e))
    return [Uf(e.enter), Uf(e.leave)]; { const t = Uf(e); return [t, t] }
} function Uf(e) { return I0(e) } function Ai(e, t) { t.split(/\s+/).forEach(r => r && e.classList.add(r)), (e[Bl] || (e[Bl] = new Set())).add(t) } function yo(e, t) { t.split(/\s+/).forEach(o => o && e.classList.remove(o)); const r = e[Bl]; r && (r.delete(t), r.size || (e[Bl] = void 0)) } function Dv(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } let Zk = 0; function zv(e, t, r, o) {
  const s = e._endId = ++Zk; const c = () => { s === e._endId && o() }; if (r)
    return setTimeout(c, r); const { type: f, timeout: d, propCount: h } = Jk(e, t); if (!f)
    return o(); const g = `${f}end`; let v = 0; const y = () => { e.removeEventListener(g, b), c() }; const b = (x) => { x.target === e && ++v >= h && y() }; setTimeout(() => { v < h && y() }, d + 1), e.addEventListener(g, b)
} function Jk(e, t) { const r = window.getComputedStyle(e); const o = T => (r[T] || '').split(', '); const s = o(`${Li}Delay`); const c = o(`${Li}Duration`); const f = Iv(s, c); const d = o(`${dl}Delay`); const h = o(`${dl}Duration`); const g = Iv(d, h); let v = null; let y = 0; let b = 0; t === Li ? f > 0 && (v = Li, y = f, b = c.length) : t === dl ? g > 0 && (v = dl, y = g, b = h.length) : (y = Math.max(f, g), v = y > 0 ? f > g ? Li : dl : null, b = v ? v === Li ? c.length : h.length : 0); const x = v === Li && /\b(transform|all)(,|$)/.test(o(`${Li}Property`).toString()); return { type: v, timeout: y, propCount: b, hasTransform: x } } function Iv(e, t) { for (;e.length < t.length;)e = e.concat(e); return Math.max(...t.map((r, o) => Fv(r) + Fv(e[o]))) } function Fv(e) { return e === 'auto' ? 0 : Number(e.slice(0, -1).replace(',', '.')) * 1e3 } function Qk() { return document.body.offsetHeight } function eC(e, t, r) { const o = e[Bl]; o && (t = (t ? [t, ...o] : [...o]).join(' ')), t == null ? e.removeAttribute('class') : r ? e.setAttribute('class', t) : e.className = t } const Bc = Symbol('_vod'); const Gy = Symbol('_vsh'); const bl = { beforeMount(e, { value: t }, { transition: r }) { e[Bc] = e.style.display === 'none' ? '' : e.style.display, r && t ? r.beforeEnter(e) : hl(e, t) }, mounted(e, { value: t }, { transition: r }) { r && t && r.enter(e) }, updated(e, { value: t, oldValue: r }, { transition: o }) { !t != !r && (o ? t ? (o.beforeEnter(e), hl(e, !0), o.enter(e)) : o.leave(e, () => { hl(e, !1) }) : hl(e, t)) }, beforeUnmount(e, { value: t }) { hl(e, t) } }; function hl(e, t) { e.style.display = t ? e[Bc] : 'none', e[Gy] = !t } const tC = Symbol(''); const nC = /(^|;)\s*display\s*:/; function rC(e, t, r) {
  const o = e.style; const s = $t(r); let c = !1; if (r && !s) {
    if (t) {
      if ($t(t)) {
        for (const f of t.split(';')) { const d = f.slice(0, f.indexOf(':')).trim(); r[d] == null && xc(o, d, '') }
      }
      else {
        for (const f in t)r[f] == null && xc(o, f, '')
      }
    } for (const f in r)f === 'display' && (c = !0), xc(o, f, r[f])
  }
  else if (s) { if (t !== r) { const f = o[tC]; f && (r += `;${f}`), o.cssText = r, c = nC.test(r) } }
  else {
    t && e.removeAttribute('style')
  }Bc in e && (e[Bc] = c ? o.display : '', e[Gy] && (o.display = 'none'))
} const Hv = /\s*!important$/; function xc(e, t, r) {
  if (Ie(r)) {
    r.forEach(o => xc(e, t, o))
  }
  else if (r == null && (r = ''), t.startsWith('--')) {
    e.setProperty(t, r)
  }
  else { const o = iC(e, t); Hv.test(r) ? e.setProperty(ui(o), r.replace(Hv, ''), 'important') : e[o] = r }
} const qv = ['Webkit', 'Moz', 'ms']; const Vf = {}; function iC(e, t) {
  const r = Vf[t]; if (r)
    return r; let o = nr(t); if (o !== 'filter' && o in e)
    return Vf[t] = o; o = du(o); for (let s = 0; s < qv.length; s++) {
    const c = qv[s] + o; if (c in e)
      return Vf[t] = c
  } return t
} const Bv = 'http://www.w3.org/1999/xlink'; function Wv(e, t, r, o, s, c = Q_(t)) { o && t.startsWith('xlink:') ? r == null ? e.removeAttributeNS(Bv, t.slice(6, t.length)) : e.setAttributeNS(Bv, t, r) : r == null || c && !H0(r) ? e.removeAttribute(t) : e.setAttribute(t, c ? '' : Dr(r) ? String(r) : r) } function oC(e, t, r, o) {
  if (t === 'innerHTML' || t === 'textContent') {
    if (r == null)
      return; e[t] = r; return
  } const s = e.tagName; if (t === 'value' && s !== 'PROGRESS' && !s.includes('-')) { const f = s === 'OPTION' ? e.getAttribute('value') || '' : e.value; const d = r == null ? '' : String(r); (f !== d || !('_value' in e)) && (e.value = d), r == null && e.removeAttribute(t), e._value = r; return } let c = !1; if (r === '' || r == null) { const f = typeof e[t]; f === 'boolean' ? r = H0(r) : r == null && f === 'string' ? (r = '', c = !0) : f === 'number' && (r = 0, c = !0) } try { e[t] = r }
  catch {}c && e.removeAttribute(t)
} function _o(e, t, r, o) { e.addEventListener(t, r, o) } function sC(e, t, r, o) { e.removeEventListener(t, r, o) } const Uv = Symbol('_vei'); function lC(e, t, r, o, s = null) {
  const c = e[Uv] || (e[Uv] = {}); const f = c[t]; if (o && f) {
    f.value = o
  }
  else {
    const [d, h] = aC(t); if (o) { const g = c[t] = fC(o, s); _o(e, d, g, h) }
    else {
      f && (sC(e, d, f, h), c[t] = void 0)
    }
  }
} const Vv = /(?:Once|Passive|Capture)$/; function aC(e) { let t; if (Vv.test(e)) { t = {}; let o; for (;o = e.match(Vv);)e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0 } return [e[2] === ':' ? e.slice(3) : ui(e.slice(2)), t] } let jf = 0; const cC = Promise.resolve(); const uC = () => jf || (cC.then(() => jf = 0), jf = Date.now()); function fC(e, t) {
  const r = (o) => {
    if (!o._vts)
      o._vts = Date.now(); else if (o._vts <= r.attached)
      return; tr(dC(o, r.value), t, 5, [o])
  }; return r.value = e, r.attached = uC(), r
} function dC(e, t) {
  if (Ie(t)) { const r = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { r.call(e), e._stopped = !0 }, t.map(o => s => !s._stopped && o && o(s)) }
  else {
    return t
  }
} const jv = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123; function hC(e, t, r, o, s, c) { const f = s === 'svg'; t === 'class' ? eC(e, o, f) : t === 'style' ? rC(e, r, o) : cu(t) ? sh(t) || lC(e, t, r, o, c) : (t[0] === '.' ? (t = t.slice(1), !0) : t[0] === '^' ? (t = t.slice(1), !1) : pC(e, t, o, f)) ? (oC(e, t, o), !e.tagName.includes('-') && (t === 'value' || t === 'checked' || t === 'selected') && Wv(e, t, o, f, c, t !== 'value')) : (t === 'true-value' ? e._trueValue = o : t === 'false-value' && (e._falseValue = o), Wv(e, t, o, f)) } function pC(e, t, r, o) {
  if (o)
    return !!(t === 'innerHTML' || t === 'textContent' || t in e && jv(t) && Xe(r)); if (t === 'spellcheck' || t === 'draggable' || t === 'translate' || t === 'form' || t === 'list' && e.tagName === 'INPUT' || t === 'type' && e.tagName === 'TEXTAREA')
    return !1; if (t === 'width' || t === 'height') {
    const s = e.tagName; if (s === 'IMG' || s === 'VIDEO' || s === 'CANVAS' || s === 'SOURCE')
      return !1
  } return jv(t) && $t(r) ? !1 : t in e
} function Wc(e) { const t = e.props['onUpdate:modelValue'] || !1; return Ie(t) ? r => yc(t, r) : t } function gC(e) { e.target.composing = !0 } function Gv(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event('input'))) } const vs = Symbol('_assign'); const vC = { created(e, { modifiers: { lazy: t, trim: r, number: o } }, s) {
  e[vs] = Wc(s); const c = o || s.props && s.props.type === 'number'; _o(e, t ? 'change' : 'input', (f) => {
    if (f.target.composing)
      return; let d = e.value; r && (d = d.trim()), c && (d = cd(d)), e[vs](d)
  }), r && _o(e, 'change', () => { e.value = e.value.trim() }), t || (_o(e, 'compositionstart', gC), _o(e, 'compositionend', Gv), _o(e, 'change', Gv))
}, mounted(e, { value: t }) { e.value = t ?? '' }, beforeUpdate(e, { value: t, oldValue: r, modifiers: { lazy: o, trim: s, number: c } }, f) {
  if (e[vs] = Wc(f), e.composing)
    return; const d = (c || e.type === 'number') && !/^0\d/.test(e.value) ? cd(e.value) : e.value; const h = t ?? ''; d !== h && (document.activeElement === e && e.type !== 'range' && (o && t === r || s && e.value.trim() === h) || (e.value = h))
} }; const mC = { deep: !0, created(e, t, r) {
  e[vs] = Wc(r), _o(e, 'change', () => {
    const o = e._modelValue; const s = yC(e); const c = e.checked; const f = e[vs]; if (Ie(o)) {
      const d = q0(o, s); const h = d !== -1; if (c && !h) {
        f(o.concat(s))
      }
      else if (!c && h) { const g = [...o]; g.splice(d, 1), f(g) }
    }
    else if (uu(o)) { const d = new Set(o); c ? d.add(s) : d.delete(s), f(d) }
    else {
      f(Ky(e, c))
    }
  })
}, mounted: Kv, beforeUpdate(e, t, r) { e[vs] = Wc(r), Kv(e, t, r) } }; function Kv(e, { value: t, oldValue: r }, o) { e._modelValue = t, Ie(t) ? e.checked = q0(t, o.props.value) > -1 : uu(t) ? e.checked = t.has(o.props.value) : t !== r && (e.checked = hu(t, Ky(e, !0))) } function yC(e) { return '_value' in e ? e._value : e.value } function Ky(e, t) { const r = t ? '_trueValue' : '_falseValue'; return r in e ? e[r] : t } const bC = ['ctrl', 'shift', 'alt', 'meta']; const wC = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => 'button' in e && e.button !== 0, middle: e => 'button' in e && e.button !== 1, right: e => 'button' in e && e.button !== 2, exact: (e, t) => bC.some(r => e[`${r}Key`] && !t.includes(r)) }; function _c(e, t) {
  const r = e._withMods || (e._withMods = {}); const o = t.join('.'); return r[o] || (r[o] = (s, ...c) => {
    for (let f = 0; f < t.length; f++) {
      const d = wC[t[f]]; if (d && d(s, t))
        return
    } return e(s, ...c)
  })
} const xC = { esc: 'escape', space: ' ', up: 'arrow-up', left: 'arrow-left', right: 'arrow-right', down: 'arrow-down', delete: 'backspace' }; function kd(e, t) {
  const r = e._withKeys || (e._withKeys = {}); const o = t.join('.'); return r[o] || (r[o] = (s) => {
    if (!('key' in s))
      return; const c = ui(s.key); if (t.some(f => f === c || xC[f] === c))
      return e(s)
  })
} const _C = Gt({ patchProp: hC }, Kk); let Xv; function SC() { return Xv || (Xv = gk(_C)) } function Xy(...e) {
  const t = SC().createApp(...e); const { mount: r } = t; return t.mount = (o) => {
    const s = CC(o); if (!s)
      return; const c = t._component; !Xe(c) && !c.render && !c.template && (c.template = s.innerHTML), s.innerHTML = ''; const f = r(s, !1, kC(s)); return s instanceof Element && (s.removeAttribute('v-cloak'), s.setAttribute('data-v-app', '')), f
  }, t
} function kC(e) {
  if (e instanceof SVGElement)
    return 'svg'; if (typeof MathMLElement == 'function' && e instanceof MathMLElement)
    return 'mathml'
} function CC(e) { return $t(e) ? document.querySelector(e) : e } function di(e, t) { const r = e.__vccOpts || e; for (const [o, s] of t)r[o] = s; return r } const TC = {}; function EC(e, t) { const r = Ao('RouterView'); return oe(), ot(r) } const LC = di(TC, [['render', EC]])/*!
  * vue-router v4.4.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */const as = typeof document < 'u'; function AC(e) { return e.__esModule || e[Symbol.toStringTag] === 'Module' } const bt = Object.assign; function Gf(e, t) { const r = {}; for (const o in t) { const s = t[o]; r[o] = xr(s) ? s.map(e) : e(s) } return r } function Al() {} const xr = Array.isArray; const Yy = /#/g; const MC = /&/g; const NC = /\//g; const $C = /=/g; const OC = /\?/g; const Zy = /\+/g; const PC = /%5B/g; const RC = /%5D/g; const Jy = /%5E/g; const DC = /%60/g; const Qy = /%7B/g; const zC = /%7C/g; const eb = /%7D/g; const IC = /%20/g; function Mh(e) { return encodeURI(`${e}`).replace(zC, '|').replace(PC, '[').replace(RC, ']') } function FC(e) { return Mh(e).replace(Qy, '{').replace(eb, '}').replace(Jy, '^') } function Cd(e) { return Mh(e).replace(Zy, '%2B').replace(IC, '+').replace(Yy, '%23').replace(MC, '%26').replace(DC, '`').replace(Qy, '{').replace(eb, '}').replace(Jy, '^') } function HC(e) { return Cd(e).replace($C, '%3D') } function qC(e) { return Mh(e).replace(Yy, '%23').replace(OC, '%3F') } function BC(e) { return e == null ? '' : qC(e).replace(NC, '%2F') } function Wl(e) {
  try { return decodeURIComponent(`${e}`) }
  catch {} return `${e}`
} const WC = /\/$/; const UC = e => e.replace(WC, ''); function Kf(e, t, r = '/') { let o; let s = {}; let c = ''; let f = ''; const d = t.indexOf('#'); let h = t.indexOf('?'); return d < h && d >= 0 && (h = -1), h > -1 && (o = t.slice(0, h), c = t.slice(h + 1, d > -1 ? d : t.length), s = e(c)), d > -1 && (o = o || t.slice(0, d), f = t.slice(d, t.length)), o = KC(o ?? t, r), { fullPath: o + (c && '?') + c + f, path: o, query: s, hash: Wl(f) } } function VC(e, t) { const r = t.query ? e(t.query) : ''; return t.path + (r && '?') + r + (t.hash || '') } function Yv(e, t) { return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || '/' } function jC(e, t, r) { const o = t.matched.length - 1; const s = r.matched.length - 1; return o > -1 && o === s && ks(t.matched[o], r.matched[s]) && tb(t.params, r.params) && e(t.query) === e(r.query) && t.hash === r.hash } function ks(e, t) { return (e.aliasOf || e) === (t.aliasOf || t) } function tb(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1; for (const r in e) {
    if (!GC(e[r], t[r]))
      return !1
  } return !0
} function GC(e, t) { return xr(e) ? Zv(e, t) : xr(t) ? Zv(t, e) : e === t } function Zv(e, t) { return xr(t) ? e.length === t.length && e.every((r, o) => r === t[o]) : e.length === 1 && e[0] === t } function KC(e, t) {
  if (e.startsWith('/'))
    return e; if (!e)
    return t; const r = t.split('/'); const o = e.split('/'); const s = o[o.length - 1]; (s === '..' || s === '.') && o.push(''); let c = r.length - 1; let f; let d; for (f = 0; f < o.length; f++) {
    if (d = o[f], d !== '.') {
      if (d === '..')
        c > 1 && c--; else break
    }
  } return `${r.slice(0, c).join('/')}/${o.slice(f).join('/')}`
} const Mi = { path: '/', name: void 0, params: {}, query: {}, hash: '', fullPath: '/', matched: [], meta: {}, redirectedFrom: void 0 }; let Ul; (function (e) { e.pop = 'pop', e.push = 'push' })(Ul || (Ul = {})); let Ml; (function (e) { e.back = 'back', e.forward = 'forward', e.unknown = '' })(Ml || (Ml = {})); function XC(e) {
  if (!e) {
    if (as) { const t = document.querySelector('base'); e = t && t.getAttribute('href') || '/', e = e.replace(/^\w+:\/\/[^/]+/, '') }
    else {
      e = '/'
    }
  } return e[0] !== '/' && e[0] !== '#' && (e = `/${e}`), UC(e)
} const YC = /^[^#]+#/; function ZC(e, t) { return e.replace(YC, '#') + t } function JC(e, t) { const r = document.documentElement.getBoundingClientRect(); const o = e.getBoundingClientRect(); return { behavior: t.behavior, left: o.left - r.left - (t.left || 0), top: o.top - r.top - (t.top || 0) } } const Cu = () => ({ left: window.scrollX, top: window.scrollY }); function QC(e) {
  let t; if ('el' in e) {
    const r = e.el; const o = typeof r == 'string' && r.startsWith('#'); const s = typeof r == 'string' ? o ? document.getElementById(r.slice(1)) : document.querySelector(r) : r; if (!s)
      return; t = JC(s, e)
  }
  else {
    t = e
  }'scrollBehavior' in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
} function Jv(e, t) { return (history.state ? history.state.position - t : -1) + e } const Td = new Map(); function eT(e, t) { Td.set(e, t) } function tT(e) { const t = Td.get(e); return Td.delete(e), t } const nT = () => `${location.protocol}//${location.host}`; function nb(e, t) { const { pathname: r, search: o, hash: s } = t; const c = e.indexOf('#'); if (c > -1) { const d = s.includes(e.slice(c)) ? e.slice(c).length : 1; let h = s.slice(d); return h[0] !== '/' && (h = `/${h}`), Yv(h, '') } return Yv(r, e) + o + s } function rT(e, t, r, o) {
  const s = []; let c = []; let f = null; const d = ({ state: b }) => {
    const x = nb(e, location); const T = r.value; const E = t.value; let M = 0; if (b) { if (r.value = x, t.value = b, f && f === T) { f = null; return }M = E ? b.position - E.position : 0 }
    else {
      o(x)
    }s.forEach((N) => { N(r.value, T, { delta: M, type: Ul.pop, direction: M ? M > 0 ? Ml.forward : Ml.back : Ml.unknown }) })
  }; function h() { f = r.value } function g(b) { s.push(b); const x = () => { const T = s.indexOf(b); T > -1 && s.splice(T, 1) }; return c.push(x), x } function v() { const { history: b } = window; b.state && b.replaceState(bt({}, b.state, { scroll: Cu() }), '') } function y() { for (const b of c)b(); c = [], window.removeEventListener('popstate', d), window.removeEventListener('beforeunload', v) } return window.addEventListener('popstate', d), window.addEventListener('beforeunload', v, { passive: !0 }), { pauseListeners: h, listen: g, destroy: y }
} function Qv(e, t, r, o = !1, s = !1) { return { back: e, current: t, forward: r, replaced: o, position: window.history.length, scroll: s ? Cu() : null } } function iT(e) {
  const { history: t, location: r } = window; const o = { value: nb(e, r) }; const s = { value: t.state }; s.value || c(o.value, { back: null, current: o.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0); function c(h, g, v) {
    const y = e.indexOf('#'); const b = y > -1 ? (r.host && document.querySelector('base') ? e : e.slice(y)) + h : nT() + e + h; try { t[v ? 'replaceState' : 'pushState'](g, '', b), s.value = g }
    catch (x) { console.error(x), r[v ? 'replace' : 'assign'](b) }
  } function f(h, g) { const v = bt({}, t.state, Qv(s.value.back, h, s.value.forward, !0), g, { position: s.value.position }); c(h, v, !0), o.value = h } function d(h, g) { const v = bt({}, s.value, t.state, { forward: h, scroll: Cu() }); c(v.current, v, !0); const y = bt({}, Qv(o.value, h, null), { position: v.position + 1 }, g); c(h, y, !1), o.value = h } return { location: o, state: s, push: d, replace: f }
} function oT(e) { e = XC(e); const t = iT(e); const r = rT(e, t.state, t.location, t.replace); function o(c, f = !0) { f || r.pauseListeners(), history.go(c) } const s = bt({ location: '', base: e, go: o, createHref: ZC.bind(null, e) }, t, r); return Object.defineProperty(s, 'location', { enumerable: !0, get: () => t.location.value }), Object.defineProperty(s, 'state', { enumerable: !0, get: () => t.state.value }), s } function sT(e) { return e = location.host ? e || location.pathname + location.search : '', e.includes('#') || (e += '#'), oT(e) } function lT(e) { return typeof e == 'string' || e && typeof e == 'object' } function rb(e) { return typeof e == 'string' || typeof e == 'symbol' } const ib = Symbol(''); let em; (function (e) { e[e.aborted = 4] = 'aborted', e[e.cancelled = 8] = 'cancelled', e[e.duplicated = 16] = 'duplicated' })(em || (em = {})); function Cs(e, t) { return bt(new Error(), { type: e, [ib]: !0 }, t) } function Yr(e, t) { return e instanceof Error && ib in e && (t == null || !!(e.type & t)) } const tm = '[^/]+?'; const aT = { sensitive: !1, strict: !1, start: !0, end: !0 }; const cT = /[.+*?^${}()[\]/\\]/g; function uT(e, t) {
  const r = bt({}, aT, t); const o = []; let s = r.start ? '^' : ''; const c = []; for (const g of e) {
    const v = g.length ? [] : [90]; r.strict && !g.length && (s += '/'); for (let y = 0; y < g.length; y++) {
      const b = g[y]; let x = 40 + (r.sensitive ? 0.25 : 0); if (b.type === 0) {
        y || (s += '/'), s += b.value.replace(cT, '\\$&'), x += 40
      }
      else if (b.type === 1) {
        const { value: T, repeatable: E, optional: M, regexp: N } = b; c.push({ name: T, repeatable: E, optional: M }); const L = N || tm; if (L !== tm) {
          x += 10; try { new RegExp(`(${L})`) }
          catch (A) { throw new Error(`Invalid custom RegExp for param "${T}" (${L}): ${A.message}`) }
        } let O = E ? `((?:${L})(?:/(?:${L}))*)` : `(${L})`; y || (O = M && g.length < 2 ? `(?:/${O})` : `/${O}`), M && (O += '?'), s += O, x += 20, M && (x += -8), E && (x += -20), L === '.*' && (x += -50)
      }v.push(x)
    }o.push(v)
  } if (r.strict && r.end) { const g = o.length - 1; o[g][o[g].length - 1] += 0.7000000000000001 }r.strict || (s += '/?'), r.end ? s += '$' : r.strict && (s += '(?:/|$)'); const f = new RegExp(s, r.sensitive ? '' : 'i'); function d(g) {
    const v = g.match(f); const y = {}; if (!v)
      return null; for (let b = 1; b < v.length; b++) { const x = v[b] || ''; const T = c[b - 1]; y[T.name] = x && T.repeatable ? x.split('/') : x } return y
  } function h(g) {
    let v = ''; let y = !1; for (const b of e) {
      (!y || !v.endsWith('/')) && (v += '/'), y = !1; for (const x of b) {
        if (x.type === 0) {
          v += x.value
        }
        else if (x.type === 1) {
          const { value: T, repeatable: E, optional: M } = x; const N = T in g ? g[T] : ''; if (xr(N) && !E)
            throw new Error(`Provided param "${T}" is an array but it is not repeatable (* or + modifiers)`); const L = xr(N) ? N.join('/') : N; if (!L) {
            if (M)
              b.length < 2 && (v.endsWith('/') ? v = v.slice(0, -1) : y = !0); else throw new Error(`Missing required param "${T}"`)
          } v += L
        }
      }
    } return v || '/'
  } return { re: f, score: o, keys: c, parse: d, stringify: h }
} function fT(e, t) {
  let r = 0; for (;r < e.length && r < t.length;) {
    const o = t[r] - e[r]; if (o)
      return o; r++
  } return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
} function ob(e, t) {
  let r = 0; const o = e.score; const s = t.score; for (;r < o.length && r < s.length;) {
    const c = fT(o[r], s[r]); if (c)
      return c; r++
  } if (Math.abs(s.length - o.length) === 1) {
    if (nm(o))
      return 1; if (nm(s))
      return -1
  } return s.length - o.length
} function nm(e) { const t = e[e.length - 1]; return e.length > 0 && t[t.length - 1] < 0 } const dT = { type: 0, value: '' }; const hT = /\w/; function pT(e) {
  if (!e)
    return [[]]; if (e === '/')
    return [[dT]]; if (!e.startsWith('/'))
    throw new Error(`Invalid path "${e}"`); function t(x) { throw new Error(`ERR (${r})/"${g}": ${x}`) } let r = 0; let o = r; const s = []; let c; function f() { c && s.push(c), c = [] } let d = 0; let h; let g = ''; let v = ''; function y() { g && (r === 0 ? c.push({ type: 0, value: g }) : r === 1 || r === 2 || r === 3 ? (c.length > 1 && (h === '*' || h === '+') && t(`A repeatable param (${g}) must be alone in its segment. eg: '/:ids+.`), c.push({ type: 1, value: g, regexp: v, repeatable: h === '*' || h === '+', optional: h === '*' || h === '?' })) : t('Invalid state to consume buffer'), g = '') } function b() { g += h } for (;d < e.length;) { if (h = e[d++], h === '\\' && r !== 2) { o = r, r = 4; continue } switch (r) { case 0:h === '/' ? (g && y(), f()) : h === ':' ? (y(), r = 1) : b(); break; case 4:b(), r = o; break; case 1:h === '(' ? r = 2 : hT.test(h) ? b() : (y(), r = 0, h !== '*' && h !== '?' && h !== '+' && d--); break; case 2:h === ')' ? v[v.length - 1] == '\\' ? v = v.slice(0, -1) + h : r = 3 : v += h; break; case 3:y(), r = 0, h !== '*' && h !== '?' && h !== '+' && d--, v = ''; break; default:t('Unknown state'); break } } return r === 2 && t(`Unfinished custom RegExp for param "${g}"`), y(), f(), s
} function gT(e, t, r) { const o = uT(pT(e.path), r); const s = bt(o, { record: e, parent: t, children: [], alias: [] }); return t && !s.record.aliasOf == !t.record.aliasOf && t.children.push(s), s } function vT(e, t) {
  const r = []; const o = new Map(); t = om({ strict: !1, end: !0, sensitive: !1 }, t); function s(y) { return o.get(y) } function c(y, b, x) { const T = !x; const E = mT(y); E.aliasOf = x && x.record; const M = om(t, y); const N = [E]; if ('alias' in y) { const A = typeof y.alias == 'string' ? [y.alias] : y.alias; for (const H of A)N.push(bt({}, E, { components: x ? x.record.components : E.components, path: H, aliasOf: x ? x.record : E })) } let L, O; for (const A of N) { const { path: H } = A; if (b && H[0] !== '/') { const z = b.record.path; const J = z[z.length - 1] === '/' ? '' : '/'; A.path = b.record.path + (H && J + H) } if (L = gT(A, b, M), x ? x.alias.push(L) : (O = O || L, O !== L && O.alias.push(L), T && y.name && !im(L) && f(y.name)), sb(L) && h(L), E.children) { const z = E.children; for (let J = 0; J < z.length; J++)c(z[J], L, x && x.children[J]) }x = x || L } return O ? () => { f(O) } : Al } function f(y) {
    if (rb(y)) { const b = o.get(y); b && (o.delete(y), r.splice(r.indexOf(b), 1), b.children.forEach(f), b.alias.forEach(f)) }
    else { const b = r.indexOf(y); b > -1 && (r.splice(b, 1), y.record.name && o.delete(y.record.name), y.children.forEach(f), y.alias.forEach(f)) }
  } function d() { return r } function h(y) { const b = wT(y, r); r.splice(b, 0, y), y.record.name && !im(y) && o.set(y.record.name, y) } function g(y, b) {
    let x; let T = {}; let E; let M; if ('name' in y && y.name) {
      if (x = o.get(y.name), !x)
        throw Cs(1, { location: y }); M = x.record.name, T = bt(rm(b.params, x.keys.filter(O => !O.optional).concat(x.parent ? x.parent.keys.filter(O => O.optional) : []).map(O => O.name)), y.params && rm(y.params, x.keys.map(O => O.name))), E = x.stringify(T)
    }
    else if (y.path != null) {
      E = y.path, x = r.find(O => O.re.test(E)), x && (T = x.parse(E), M = x.record.name)
    }
    else {
      if (x = b.name ? o.get(b.name) : r.find(O => O.re.test(b.path)), !x)
        throw Cs(1, { location: y, currentLocation: b }); M = x.record.name, T = bt({}, b.params, y.params), E = x.stringify(T)
    } const N = []; let L = x; for (;L;)N.unshift(L.record), L = L.parent; return { name: M, path: E, params: T, matched: N, meta: bT(N) }
  }e.forEach(y => c(y)); function v() { r.length = 0, o.clear() } return { addRoute: c, resolve: g, removeRoute: f, clearRoutes: v, getRoutes: d, getRecordMatcher: s }
} function rm(e, t) { const r = {}; for (const o of t)o in e && (r[o] = e[o]); return r } function mT(e) { return { path: e.path, redirect: e.redirect, name: e.name, meta: e.meta || {}, aliasOf: void 0, beforeEnter: e.beforeEnter, props: yT(e), children: e.children || [], instances: {}, leaveGuards: new Set(), updateGuards: new Set(), enterCallbacks: {}, components: 'components' in e ? e.components || null : e.component && { default: e.component } } } function yT(e) {
  const t = {}; const r = e.props || !1; if ('component' in e) {
    t.default = r
  }
  else {
    for (const o in e.components)t[o] = typeof r == 'object' ? r[o] : r
  } return t
} function im(e) {
  for (;e;) {
    if (e.record.aliasOf)
      return !0; e = e.parent
  } return !1
} function bT(e) { return e.reduce((t, r) => bt(t, r.meta), {}) } function om(e, t) { const r = {}; for (const o in e)r[o] = o in t ? t[o] : e[o]; return r } function wT(e, t) { let r = 0; let o = t.length; for (;r !== o;) { const c = r + o >> 1; ob(e, t[c]) < 0 ? o = c : r = c + 1 } const s = xT(e); return s && (o = t.lastIndexOf(s, o - 1)), o } function xT(e) {
  let t = e; for (;t = t.parent;) {
    if (sb(t) && ob(e, t) === 0)
      return t
  }
} function sb({ record: e }) { return !!(e.name || e.components && Object.keys(e.components).length || e.redirect) } function _T(e) {
  const t = {}; if (e === '' || e === '?')
    return t; const o = (e[0] === '?' ? e.slice(1) : e).split('&'); for (let s = 0; s < o.length; ++s) {
    const c = o[s].replace(Zy, ' '); const f = c.indexOf('='); const d = Wl(f < 0 ? c : c.slice(0, f)); const h = f < 0 ? null : Wl(c.slice(f + 1)); if (d in t) { let g = t[d]; xr(g) || (g = t[d] = [g]), g.push(h) }
    else {
      t[d] = h
    }
  } return t
} function sm(e) { let t = ''; for (let r in e) { const o = e[r]; if (r = HC(r), o == null) { o !== void 0 && (t += (t.length ? '&' : '') + r); continue }(xr(o) ? o.map(c => c && Cd(c)) : [o && Cd(o)]).forEach((c) => { c !== void 0 && (t += (t.length ? '&' : '') + r, c != null && (t += `=${c}`)) }) } return t } function ST(e) { const t = {}; for (const r in e) { const o = e[r]; o !== void 0 && (t[r] = xr(o) ? o.map(s => s == null ? null : `${s}`) : o == null ? o : `${o}`) } return t } const kT = Symbol(''); const lm = Symbol(''); const Nh = Symbol(''); const lb = Symbol(''); const Ed = Symbol(''); function pl() { let e = []; function t(o) { return e.push(o), () => { const s = e.indexOf(o); s > -1 && e.splice(s, 1) } } function r() { e = [] } return { add: t, list: () => e.slice(), reset: r } } function zi(e, t, r, o, s, c = f => f()) { const f = o && (o.enterCallbacks[s] = o.enterCallbacks[s] || []); return () => new Promise((d, h) => { const g = (b) => { b === !1 ? h(Cs(4, { from: r, to: t })) : b instanceof Error ? h(b) : lT(b) ? h(Cs(2, { from: t, to: b })) : (f && o.enterCallbacks[s] === f && typeof b == 'function' && f.push(b), d()) }; const v = c(() => e.call(o && o.instances[s], t, r, g)); let y = Promise.resolve(v); e.length < 3 && (y = y.then(g)), y.catch(b => h(b)) }) } function Xf(e, t, r, o, s = c => c()) {
  const c = []; for (const f of e) {
    for (const d in f.components) {
      const h = f.components[d]; if (!(t !== 'beforeRouteEnter' && !f.instances[d])) {
        if (CT(h)) { const v = (h.__vccOpts || h)[t]; v && c.push(zi(v, r, o, f, d, s)) }
        else {
          const g = h(); c.push(() => g.then((v) => {
            if (!v)
              return Promise.reject(new Error(`Couldn't resolve component "${d}" at "${f.path}"`)); const y = AC(v) ? v.default : v; f.components[d] = y; const x = (y.__vccOpts || y)[t]; return x && zi(x, r, o, f, d, s)()
          }))
        }
      }
    }
  } return c
} function CT(e) { return typeof e == 'object' || 'displayName' in e || 'props' in e || '__vccOpts' in e } function am(e) {
  const t = ri(Nh); const r = ri(lb); const o = Me(() => { const h = q(e.to); return t.resolve(h) }); const s = Me(() => {
    const { matched: h } = o.value; const { length: g } = h; const v = h[g - 1]; const y = r.matched; if (!v || !y.length)
      return -1; const b = y.findIndex(ks.bind(null, v)); if (b > -1)
      return b; const x = cm(h[g - 2]); return g > 1 && cm(v) === x && y[y.length - 1].path !== x ? y.findIndex(ks.bind(null, h[g - 2])) : b
  }); const c = Me(() => s.value > -1 && AT(r.params, o.value.params)); const f = Me(() => s.value > -1 && s.value === r.matched.length - 1 && tb(r.params, o.value.params)); function d(h = {}) { return LT(h) ? t[q(e.replace) ? 'replace' : 'push'](q(e.to)).catch(Al) : Promise.resolve() } return { route: o, href: Me(() => o.value.href), isActive: c, isExactActive: f, navigate: d }
} const TT = ft({ name: 'RouterLink', compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: 'page' } }, useLink: am, setup(e, { slots: t }) { const r = er(am(e)); const { options: o } = ri(Nh); const s = Me(() => ({ [um(e.activeClass, o.linkActiveClass, 'router-link-active')]: r.isActive, [um(e.exactActiveClass, o.linkExactActiveClass, 'router-link-exact-active')]: r.isExactActive })); return () => { const c = t.default && t.default(r); return e.custom ? c : fa('a', { 'aria-current': r.isExactActive ? e.ariaCurrentValue : null, 'href': r.href, 'onClick': r.navigate, 'class': s.value }, c) } } }); const ET = TT; function LT(e) {
  if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute('target'); if (/\b_blank\b/i.test(t))
        return
    } return e.preventDefault && e.preventDefault(), !0
  }
} function AT(e, t) {
  for (const r in t) {
    const o = t[r]; const s = e[r]; if (typeof o == 'string') {
      if (o !== s)
        return !1
    }
    else if (!xr(s) || s.length !== o.length || o.some((c, f) => c !== s[f])) {
      return !1
    }
  } return !0
} function cm(e) { return e ? e.aliasOf ? e.aliasOf.path : e.path : '' } const um = (e, t, r) => e ?? t ?? r; const MT = ft({ name: 'RouterView', inheritAttrs: !1, props: { name: { type: String, default: 'default' }, route: Object }, compatConfig: { MODE: 3 }, setup(e, { attrs: t, slots: r }) {
  const o = ri(Ed); const s = Me(() => e.route || o.value); const c = ri(lm, 0); const f = Me(() => { let g = q(c); const { matched: v } = s.value; let y; for (;(y = v[g]) && !y.components;)g++; return g }); const d = Me(() => s.value.matched[f.value]); bc(lm, Me(() => f.value + 1)), bc(kT, d), bc(Ed, s); const h = Be(); return Ht(() => [h.value, d.value, e.name], ([g, v, y], [b, x, T]) => { v && (v.instances[y] = g, x && x !== v && g && g === b && (v.leaveGuards.size || (v.leaveGuards = x.leaveGuards), v.updateGuards.size || (v.updateGuards = x.updateGuards))), g && v && (!x || !ks(v, x) || !b) && (v.enterCallbacks[y] || []).forEach(E => E(g)) }, { flush: 'post' }), () => {
    const g = s.value; const v = e.name; const y = d.value; const b = y && y.components[v]; if (!b)
      return fm(r.default, { Component: b, route: g }); const x = y.props[v]; const T = x ? x === !0 ? g.params : typeof x == 'function' ? x(g) : x : null; const M = fa(b, bt({}, T, t, { onVnodeUnmounted: (N) => { N.component.isUnmounted && (y.instances[v] = null) }, ref: h })); return fm(r.default, { Component: M, route: g }) || M
  }
} }); function fm(e, t) {
  if (!e)
    return null; const r = e(t); return r.length === 1 ? r[0] : r
} const NT = MT; function $T(e) {
  const t = vT(e.routes, e); const r = e.parseQuery || _T; const o = e.stringifyQuery || sm; const s = e.history; const c = pl(); const f = pl(); const d = pl(); const h = Fr(Mi); let g = Mi; as && e.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual'); const v = Gf.bind(null, X => `${X}`); const y = Gf.bind(null, BC); const b = Gf.bind(null, Wl); function x(X, ae) { let de, $e; return rb(X) ? (de = t.getRecordMatcher(X), $e = ae) : $e = X, t.addRoute($e, de) } function T(X) { const ae = t.getRecordMatcher(X); ae && t.removeRoute(ae) } function E() { return t.getRoutes().map(X => X.record) } function M(X) { return !!t.getRecordMatcher(X) } function N(X, ae) {
    if (ae = bt({}, ae || h.value), typeof X == 'string') { const F = Kf(r, X, ae.path); const Z = t.resolve({ path: F.path }, ae); const ue = s.createHref(F.fullPath); return bt(F, Z, { params: b(Z.params), hash: Wl(F.hash), redirectedFrom: void 0, href: ue }) } let de; if (X.path != null) {
      de = bt({}, X, { path: Kf(r, X.path, ae.path).path })
    }
    else { const F = bt({}, X.params); for (const Z in F)F[Z] == null && delete F[Z]; de = bt({}, X, { params: y(F) }), ae.params = y(ae.params) } const $e = t.resolve(de, ae); const Te = X.hash || ''; $e.params = v(b($e.params)); const Ye = VC(o, bt({}, X, { hash: FC(Te), path: $e.path })); const P = s.createHref(Ye); return bt({ fullPath: Ye, hash: Te, query: o === sm ? ST(X.query) : X.query || {} }, $e, { redirectedFrom: void 0, href: P })
  } function L(X) { return typeof X == 'string' ? Kf(r, X, h.value.path) : bt({}, X) } function O(X, ae) {
    if (g !== X)
      return Cs(8, { from: ae, to: X })
  } function A(X) { return J(X) } function H(X) { return A(bt(L(X), { replace: !0 })) } function z(X) { const ae = X.matched[X.matched.length - 1]; if (ae && ae.redirect) { const { redirect: de } = ae; let $e = typeof de == 'function' ? de(X) : de; return typeof $e == 'string' && ($e = $e.includes('?') || $e.includes('#') ? $e = L($e) : { path: $e }, $e.params = {}), bt({ query: X.query, hash: X.hash, params: $e.path != null ? {} : X.params }, $e) } } function J(X, ae) {
    const de = g = N(X); const $e = h.value; const Te = X.state; const Ye = X.force; const P = X.replace === !0; const F = z(de); if (F)
      return J(bt(L(F), { state: typeof F == 'object' ? bt({}, Te, F.state) : Te, force: Ye, replace: P }), ae || de); const Z = de; Z.redirectedFrom = ae; let ue; return !Ye && jC(o, $e, de) && (ue = Cs(16, { to: Z, from: $e }), We($e, $e, !0, !1)), (ue ? Promise.resolve(ue) : j(Z, $e)).catch(le => Yr(le) ? Yr(le, 2) ? le : Ne(le) : ie(le, Z, $e)).then((le) => {
      if (le) {
        if (Yr(le, 2))
          return J(bt({ replace: P }, L(le.to), { state: typeof le.to == 'object' ? bt({}, Te, le.to.state) : Te, force: Ye }), ae || Z)
      }
      else {
        le = K(Z, $e, !0, P, Te)
      } return ne(Z, $e, le), le
    })
  } function re(X, ae) { const de = O(X, ae); return de ? Promise.reject(de) : Promise.resolve() } function te(X) { const ae = rt.values().next().value; return ae && typeof ae.runWithContext == 'function' ? ae.runWithContext(X) : X() } function j(X, ae) {
    let de; const [$e, Te, Ye] = OT(X, ae); de = Xf($e.reverse(), 'beforeRouteLeave', X, ae); for (const F of $e)F.leaveGuards.forEach((Z) => { de.push(zi(Z, X, ae)) }); const P = re.bind(null, X, ae); return de.push(P), Ee(de).then(() => { de = []; for (const F of c.list())de.push(zi(F, X, ae)); return de.push(P), Ee(de) }).then(() => { de = Xf(Te, 'beforeRouteUpdate', X, ae); for (const F of Te)F.updateGuards.forEach((Z) => { de.push(zi(Z, X, ae)) }); return de.push(P), Ee(de) }).then(() => {
      de = []; for (const F of Ye) {
        if (F.beforeEnter) {
          if (xr(F.beforeEnter)) {
            for (const Z of F.beforeEnter)de.push(zi(Z, X, ae))
          }
          else {
            de.push(zi(F.beforeEnter, X, ae))
          }
        }
      } return de.push(P), Ee(de)
    }).then(() => (X.matched.forEach(F => F.enterCallbacks = {}), de = Xf(Ye, 'beforeRouteEnter', X, ae, te), de.push(P), Ee(de))).then(() => { de = []; for (const F of f.list())de.push(zi(F, X, ae)); return de.push(P), Ee(de) }).catch(F => Yr(F, 8) ? F : Promise.reject(F))
  } function ne(X, ae, de) { d.list().forEach($e => te(() => $e(X, ae, de))) } function K(X, ae, de, $e, Te) {
    const Ye = O(X, ae); if (Ye)
      return Ye; const P = ae === Mi; const F = as ? history.state : {}; de && ($e || P ? s.replace(X.fullPath, bt({ scroll: P && F && F.scroll }, Te)) : s.push(X.fullPath, Te)), h.value = X, We(X, ae, de, P), Ne()
  } let V; function I() {
    V || (V = s.listen((X, ae, de) => {
      if (!Ze.listening)
        return; const $e = N(X); const Te = z($e); if (Te) { J(bt(Te, { replace: !0 }), $e).catch(Al); return }g = $e; const Ye = h.value; as && eT(Jv(Ye.fullPath, de.delta), Cu()), j($e, Ye).catch(P => Yr(P, 12) ? P : Yr(P, 2) ? (J(P.to, $e).then((F) => { Yr(F, 20) && !de.delta && de.type === Ul.pop && s.go(-1, !1) }).catch(Al), Promise.reject()) : (de.delta && s.go(-de.delta, !1), ie(P, $e, Ye))).then((P) => { P = P || K($e, Ye, !1), P && (de.delta && !Yr(P, 8) ? s.go(-de.delta, !1) : de.type === Ul.pop && Yr(P, 20) && s.go(-1, !1)), ne($e, Ye, P) }).catch(Al)
    }))
  } const k = pl(); const B = pl(); let W; function ie(X, ae, de) { Ne(X); const $e = B.list(); return $e.length ? $e.forEach(Te => Te(X, ae, de)) : console.error(X), Promise.reject(X) } function ye() { return W && h.value !== Mi ? Promise.resolve() : new Promise((X, ae) => { k.add([X, ae]) }) } function Ne(X) { return W || (W = !X, I(), k.list().forEach(([ae, de]) => X ? de(X) : ae()), k.reset()), X } function We(X, ae, de, $e) {
    const { scrollBehavior: Te } = e; if (!as || !Te)
      return Promise.resolve(); const Ye = !de && tT(Jv(X.fullPath, 0)) || ($e || !de) && history.state && history.state.scroll || null; return ln().then(() => Te(X, ae, Ye)).then(P => P && QC(P)).catch(P => ie(P, X, ae))
  } const je = X => s.go(X); let it; const rt = new Set(); const Ze = { currentRoute: h, listening: !0, addRoute: x, removeRoute: T, clearRoutes: t.clearRoutes, hasRoute: M, getRoutes: E, resolve: N, options: e, push: A, replace: H, go: je, back: () => je(-1), forward: () => je(1), beforeEach: c.add, beforeResolve: f.add, afterEach: d.add, onError: B.add, isReady: ye, install(X) { const ae = this; X.component('RouterLink', ET), X.component('RouterView', NT), X.config.globalProperties.$router = ae, Object.defineProperty(X.config.globalProperties, '$route', { enumerable: !0, get: () => q(h) }), as && !it && h.value === Mi && (it = !0, A(s.location).catch((Te) => {})); const de = {}; for (const Te in Mi)Object.defineProperty(de, Te, { get: () => h.value[Te], enumerable: !0 }); X.provide(Nh, ae), X.provide(lb, ph(de)), X.provide(Ed, h); const $e = X.unmount; rt.add(X), X.unmount = function () { rt.delete(X), rt.size < 1 && (g = Mi, V && V(), V = null, h.value = Mi, it = !1, W = !1), $e() } } }; function Ee(X) { return X.reduce((ae, de) => ae.then(() => te(de)), Promise.resolve()) } return Ze
} function OT(e, t) { const r = []; const o = []; const s = []; const c = Math.max(t.matched.length, e.matched.length); for (let f = 0; f < c; f++) { const d = t.matched[f]; d && (e.matched.find(g => ks(g, d)) ? o.push(d) : r.push(d)); const h = e.matched[f]; h && (t.matched.find(g => ks(g, h)) || s.push(h)) } return [r, o, s] } const PT = ['top', 'right', 'bottom', 'left']; const dm = ['start', 'end']; const hm = PT.reduce((e, t) => e.concat(t, `${t}-${dm[0]}`, `${t}-${dm[1]}`), []); const Vl = Math.min; const wo = Math.max; const RT = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; const DT = { start: 'end', end: 'start' }; function Ld(e, t, r) { return wo(e, Vl(t, r)) } function Oo(e, t) { return typeof e == 'function' ? e(t) : e } function Ir(e) { return e.split('-')[0] } function br(e) { return e.split('-')[1] } function ab(e) { return e === 'x' ? 'y' : 'x' } function $h(e) { return e === 'y' ? 'height' : 'width' } function da(e) { return ['top', 'bottom'].includes(Ir(e)) ? 'y' : 'x' } function Oh(e) { return ab(da(e)) } function cb(e, t, r) { r === void 0 && (r = !1); const o = br(e); const s = Oh(e); const c = $h(s); let f = s === 'x' ? o === (r ? 'end' : 'start') ? 'right' : 'left' : o === 'start' ? 'bottom' : 'top'; return t.reference[c] > t.floating[c] && (f = Vc(f)), [f, Vc(f)] } function zT(e) { const t = Vc(e); return [Uc(e), t, Uc(t)] } function Uc(e) { return e.replace(/start|end/g, t => DT[t]) } function IT(e, t, r) { const o = ['left', 'right']; const s = ['right', 'left']; const c = ['top', 'bottom']; const f = ['bottom', 'top']; switch (e) { case 'top':case 'bottom':return r ? t ? s : o : t ? o : s; case 'left':case 'right':return t ? c : f; default:return [] } } function FT(e, t, r, o) { const s = br(e); let c = IT(Ir(e), r === 'start', o); return s && (c = c.map(f => `${f}-${s}`), t && (c = c.concat(c.map(Uc)))), c } function Vc(e) { return e.replace(/left|right|bottom|top/g, t => RT[t]) } function HT(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function ub(e) { return typeof e != 'number' ? HT(e) : { top: e, right: e, bottom: e, left: e } } function Nl(e) { return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height } } function pm(e, t, r) { const { reference: o, floating: s } = e; const c = da(t); const f = Oh(t); const d = $h(f); const h = Ir(t); const g = c === 'y'; const v = o.x + o.width / 2 - s.width / 2; const y = o.y + o.height / 2 - s.height / 2; const b = o[d] / 2 - s[d] / 2; let x; switch (h) { case 'top':x = { x: v, y: o.y - s.height }; break; case 'bottom':x = { x: v, y: o.y + o.height }; break; case 'right':x = { x: o.x + o.width, y }; break; case 'left':x = { x: o.x - s.width, y }; break; default:x = { x: o.x, y: o.y } } switch (br(t)) { case 'start':x[f] -= b * (r && g ? -1 : 1); break; case 'end':x[f] += b * (r && g ? -1 : 1); break } return x } async function qT(e, t, r) { const { placement: o = 'bottom', strategy: s = 'absolute', middleware: c = [], platform: f } = r; const d = c.filter(Boolean); const h = await (f.isRTL == null ? void 0 : f.isRTL(t)); let g = await f.getElementRects({ reference: e, floating: t, strategy: s }); let { x: v, y } = pm(g, o, h); let b = o; let x = {}; let T = 0; for (let E = 0; E < d.length; E++) { const { name: M, fn: N } = d[E]; const { x: L, y: O, data: A, reset: H } = await N({ x: v, y, initialPlacement: o, placement: b, strategy: s, middlewareData: x, rects: g, platform: f, elements: { reference: e, floating: t } }); v = L ?? v, y = O ?? y, x = { ...x, [M]: { ...x[M], ...A } }, H && T <= 50 && (T++, typeof H == 'object' && (H.placement && (b = H.placement), H.rects && (g = H.rects === !0 ? await f.getElementRects({ reference: e, floating: t, strategy: s }) : H.rects), { x: v, y } = pm(g, b, h)), E = -1) } return { x: v, y, placement: b, strategy: s, middlewareData: x } } async function Tu(e, t) { let r; t === void 0 && (t = {}); const { x: o, y: s, platform: c, rects: f, elements: d, strategy: h } = e; const { boundary: g = 'clippingAncestors', rootBoundary: v = 'viewport', elementContext: y = 'floating', altBoundary: b = !1, padding: x = 0 } = Oo(t, e); const T = ub(x); const M = d[b ? y === 'floating' ? 'reference' : 'floating' : y]; const N = Nl(await c.getClippingRect({ element: (r = await (c.isElement == null ? void 0 : c.isElement(M))) == null || r ? M : M.contextElement || await (c.getDocumentElement == null ? void 0 : c.getDocumentElement(d.floating)), boundary: g, rootBoundary: v, strategy: h })); const L = y === 'floating' ? { ...f.floating, x: o, y: s } : f.reference; const O = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(d.floating)); const A = await (c.isElement == null ? void 0 : c.isElement(O)) ? await (c.getScale == null ? void 0 : c.getScale(O)) || { x: 1, y: 1 } : { x: 1, y: 1 }; const H = Nl(c.convertOffsetParentRelativeRectToViewportRelativeRect ? await c.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: d, rect: L, offsetParent: O, strategy: h }) : L); return { top: (N.top - H.top + T.top) / A.y, bottom: (H.bottom - N.bottom + T.bottom) / A.y, left: (N.left - H.left + T.left) / A.x, right: (H.right - N.right + T.right) / A.x } } function BT(e) {
  return { name: 'arrow', options: e, async fn(t) {
    const { x: r, y: o, placement: s, rects: c, platform: f, elements: d, middlewareData: h } = t; const { element: g, padding: v = 0 } = Oo(e, t) || {}; if (g == null)
      return {}; const y = ub(v); const b = { x: r, y: o }; const x = Oh(s); const T = $h(x); const E = await f.getDimensions(g); const M = x === 'y'; const N = M ? 'top' : 'left'; const L = M ? 'bottom' : 'right'; const O = M ? 'clientHeight' : 'clientWidth'; const A = c.reference[T] + c.reference[x] - b[x] - c.floating[T]; const H = b[x] - c.reference[x]; const z = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(g)); let J = z ? z[O] : 0; (!J || !await (f.isElement == null ? void 0 : f.isElement(z))) && (J = d.floating[O] || c.floating[T]); const re = A / 2 - H / 2; const te = J / 2 - E[T] / 2 - 1; const j = Vl(y[N], te); const ne = Vl(y[L], te); const K = j; const V = J - E[T] - ne; const I = J / 2 - E[T] / 2 + re; const k = Ld(K, I, V); const B = !h.arrow && br(s) != null && I !== k && c.reference[T] / 2 - (I < K ? j : ne) - E[T] / 2 < 0; const W = B ? I < K ? I - K : I - V : 0; return { [x]: b[x] + W, data: { [x]: k, centerOffset: I - k - W, ...B && { alignmentOffset: W } }, reset: B }
  } }
} function WT(e, t, r) { return (e ? [...r.filter(s => br(s) === e), ...r.filter(s => br(s) !== e)] : r.filter(s => Ir(s) === s)).filter(s => e ? br(s) === e || (t ? Uc(s) !== s : !1) : !0) } const UT = function (e) {
  return e === void 0 && (e = {}), { name: 'autoPlacement', options: e, async fn(t) {
    let r, o, s; const { rects: c, middlewareData: f, placement: d, platform: h, elements: g } = t; const { crossAxis: v = !1, alignment: y, allowedPlacements: b = hm, autoAlignment: x = !0, ...T } = Oo(e, t); const E = y !== void 0 || b === hm ? WT(y || null, x, b) : b; const M = await Tu(t, T); const N = ((r = f.autoPlacement) == null ? void 0 : r.index) || 0; const L = E[N]; if (L == null)
      return {}; const O = cb(L, c, await (h.isRTL == null ? void 0 : h.isRTL(g.floating))); if (d !== L)
      return { reset: { placement: E[0] } }; const A = [M[Ir(L)], M[O[0]], M[O[1]]]; const H = [...((o = f.autoPlacement) == null ? void 0 : o.overflows) || [], { placement: L, overflows: A }]; const z = E[N + 1]; if (z)
      return { data: { index: N + 1, overflows: H }, reset: { placement: z } }; const J = H.map((j) => { const ne = br(j.placement); return [j.placement, ne && v ? j.overflows.slice(0, 2).reduce((K, V) => K + V, 0) : j.overflows[0], j.overflows] }).sort((j, ne) => j[1] - ne[1]); const te = ((s = J.filter(j => j[2].slice(0, br(j[0]) ? 2 : 3).every(ne => ne <= 0))[0]) == null ? void 0 : s[0]) || J[0][0]; return te !== d ? { data: { index: N + 1, overflows: H }, reset: { placement: te } } : {}
  } }
}; const VT = function (e) {
  return e === void 0 && (e = {}), { name: 'flip', options: e, async fn(t) {
    let r, o; const { placement: s, middlewareData: c, rects: f, initialPlacement: d, platform: h, elements: g } = t; const { mainAxis: v = !0, crossAxis: y = !0, fallbackPlacements: b, fallbackStrategy: x = 'bestFit', fallbackAxisSideDirection: T = 'none', flipAlignment: E = !0, ...M } = Oo(e, t); if ((r = c.arrow) != null && r.alignmentOffset)
      return {}; const N = Ir(s); const L = Ir(d) === d; const O = await (h.isRTL == null ? void 0 : h.isRTL(g.floating)); const A = b || (L || !E ? [Vc(d)] : zT(d)); !b && T !== 'none' && A.push(...FT(d, E, T, O)); const H = [d, ...A]; const z = await Tu(t, M); const J = []; let re = ((o = c.flip) == null ? void 0 : o.overflows) || []; if (v && J.push(z[N]), y) { const K = cb(s, f, O); J.push(z[K[0]], z[K[1]]) } if (re = [...re, { placement: s, overflows: J }], !J.every(K => K <= 0)) {
      let te, j; const K = (((te = c.flip) == null ? void 0 : te.index) || 0) + 1; const V = H[K]; if (V)
        return { data: { index: K, overflows: re }, reset: { placement: V } }; let I = (j = re.filter(k => k.overflows[0] <= 0).sort((k, B) => k.overflows[1] - B.overflows[1])[0]) == null ? void 0 : j.placement; if (!I)
        switch (x) { case 'bestFit':{ let ne; const k = (ne = re.map(B => [B.placement, B.overflows.filter(W => W > 0).reduce((W, ie) => W + ie, 0)]).sort((B, W) => B[1] - W[1])[0]) == null ? void 0 : ne[0]; k && (I = k); break } case 'initialPlacement':I = d; break } if (s !== I)
        return { reset: { placement: I } }
    } return {}
  } }
}; async function jT(e, t) { const { placement: r, platform: o, elements: s } = e; const c = await (o.isRTL == null ? void 0 : o.isRTL(s.floating)); const f = Ir(r); const d = br(r); const h = da(r) === 'y'; const g = ['left', 'top'].includes(f) ? -1 : 1; const v = c && h ? -1 : 1; const y = Oo(t, e); let { mainAxis: b, crossAxis: x, alignmentAxis: T } = typeof y == 'number' ? { mainAxis: y, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...y }; return d && typeof T == 'number' && (x = d === 'end' ? T * -1 : T), h ? { x: x * v, y: b * g } : { x: b * g, y: x * v } } const GT = function (e) { return e === void 0 && (e = 0), { name: 'offset', options: e, async fn(t) { let r, o; const { x: s, y: c, placement: f, middlewareData: d } = t; const h = await jT(t, e); return f === ((r = d.offset) == null ? void 0 : r.placement) && (o = d.arrow) != null && o.alignmentOffset ? {} : { x: s + h.x, y: c + h.y, data: { ...h, placement: f } } } } }; const KT = function (e) { return e === void 0 && (e = {}), { name: 'shift', options: e, async fn(t) { const { x: r, y: o, placement: s } = t; const { mainAxis: c = !0, crossAxis: f = !1, limiter: d = { fn: (M) => { const { x: N, y: L } = M; return { x: N, y: L } } }, ...h } = Oo(e, t); const g = { x: r, y: o }; const v = await Tu(t, h); const y = da(Ir(s)); const b = ab(y); let x = g[b]; let T = g[y]; if (c) { const M = b === 'y' ? 'top' : 'left'; const N = b === 'y' ? 'bottom' : 'right'; const L = x + v[M]; const O = x - v[N]; x = Ld(L, x, O) } if (f) { const M = y === 'y' ? 'top' : 'left'; const N = y === 'y' ? 'bottom' : 'right'; const L = T + v[M]; const O = T - v[N]; T = Ld(L, T, O) } const E = d.fn({ ...t, [b]: x, [y]: T }); return { ...E, data: { x: E.x - r, y: E.y - o } } } } }; const XT = function (e) {
  return e === void 0 && (e = {}), { name: 'size', options: e, async fn(t) {
    const { placement: r, rects: o, platform: s, elements: c } = t; const { apply: f = () => {}, ...d } = Oo(e, t); const h = await Tu(t, d); const g = Ir(r); const v = br(r); const y = da(r) === 'y'; const { width: b, height: x } = o.floating; let T, E; g === 'top' || g === 'bottom' ? (T = g, E = v === (await (s.isRTL == null ? void 0 : s.isRTL(c.floating)) ? 'start' : 'end') ? 'left' : 'right') : (E = g, T = v === 'end' ? 'top' : 'bottom'); const M = x - h[T]; const N = b - h[E]; const L = !t.middlewareData.shift; let O = M; let A = N; if (y) { const z = b - h.left - h.right; A = v || L ? Vl(N, z) : z }
    else { const z = x - h.top - h.bottom; O = v || L ? Vl(M, z) : z } if (L && !v) { const z = wo(h.left, 0); const J = wo(h.right, 0); const re = wo(h.top, 0); const te = wo(h.bottom, 0); y ? A = b - 2 * (z !== 0 || J !== 0 ? z + J : wo(h.left, h.right)) : O = x - 2 * (re !== 0 || te !== 0 ? re + te : wo(h.top, h.bottom)) } await f({ ...t, availableWidth: A, availableHeight: O }); const H = await s.getDimensions(c.floating); return b !== H.width || x !== H.height ? { reset: { rects: !0 } } : {}
  } }
}; function Qn(e) { let t; return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function $r(e) { return Qn(e).getComputedStyle(e) } const gm = Math.min; const $l = Math.max; const jc = Math.round; function fb(e) { const t = $r(e); let r = Number.parseFloat(t.width); let o = Number.parseFloat(t.height); const s = e.offsetWidth; const c = e.offsetHeight; const f = jc(r) !== s || jc(o) !== c; return f && (r = s, o = c), { width: r, height: o, fallback: f } } function Xi(e) { return hb(e) ? (e.nodeName || '').toLowerCase() : '' } let ic; function db() {
  if (ic)
    return ic; const e = navigator.userAgentData; return e && Array.isArray(e.brands) ? (ic = e.brands.map(t => `${t.brand}/${t.version}`).join(' '), ic) : navigator.userAgent
} function Or(e) { return e instanceof Qn(e).HTMLElement } function ji(e) { return e instanceof Qn(e).Element } function hb(e) { return e instanceof Qn(e).Node } function vm(e) { return typeof ShadowRoot > 'u' ? !1 : e instanceof Qn(e).ShadowRoot || e instanceof ShadowRoot } function Eu(e) { const { overflow: t, overflowX: r, overflowY: o, display: s } = $r(e); return /auto|scroll|overlay|hidden|clip/.test(t + o + r) && !['inline', 'contents'].includes(s) } function YT(e) { return ['table', 'td', 'th'].includes(Xi(e)) } function Ad(e) { const t = /firefox/i.test(db()); const r = $r(e); const o = r.backdropFilter || r.WebkitBackdropFilter; return r.transform !== 'none' || r.perspective !== 'none' || !!o && o !== 'none' || t && r.willChange === 'filter' || t && !!r.filter && r.filter !== 'none' || ['transform', 'perspective'].some(s => r.willChange.includes(s)) || ['paint', 'layout', 'strict', 'content'].some((s) => { const c = r.contain; return c != null && c.includes(s) }) } function pb() { return !/^((?!chrome|android).)*safari/i.test(db()) } function Ph(e) { return ['html', 'body', '#document'].includes(Xi(e)) } function gb(e) { return ji(e) ? e : e.contextElement } const vb = { x: 1, y: 1 }; function ms(e) {
  const t = gb(e); if (!Or(t))
    return vb; const r = t.getBoundingClientRect(); const { width: o, height: s, fallback: c } = fb(t); let f = (c ? jc(r.width) : r.width) / o; let d = (c ? jc(r.height) : r.height) / s; return f && Number.isFinite(f) || (f = 1), d && Number.isFinite(d) || (d = 1), { x: f, y: d }
} function jl(e, t, r, o) { let s, c; t === void 0 && (t = !1), r === void 0 && (r = !1); const f = e.getBoundingClientRect(); const d = gb(e); let h = vb; t && (o ? ji(o) && (h = ms(o)) : h = ms(e)); const g = d ? Qn(d) : window; const v = !pb() && r; let y = (f.left + (v && ((s = g.visualViewport) == null ? void 0 : s.offsetLeft) || 0)) / h.x; let b = (f.top + (v && ((c = g.visualViewport) == null ? void 0 : c.offsetTop) || 0)) / h.y; let x = f.width / h.x; let T = f.height / h.y; if (d) { const E = Qn(d); const M = o && ji(o) ? Qn(o) : o; let N = E.frameElement; for (;N && o && M !== E;) { const L = ms(N); const O = N.getBoundingClientRect(); const A = getComputedStyle(N); O.x += (N.clientLeft + Number.parseFloat(A.paddingLeft)) * L.x, O.y += (N.clientTop + Number.parseFloat(A.paddingTop)) * L.y, y *= L.x, b *= L.y, x *= L.x, T *= L.y, y += O.x, b += O.y, N = Qn(N).frameElement } } return { width: x, height: T, top: b, right: y + x, bottom: b + T, left: y, x: y, y: b } } function Gi(e) { return ((hb(e) ? e.ownerDocument : e.document) || window.document).documentElement } function Lu(e) { return ji(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function mb(e) { return jl(Gi(e)).left + Lu(e).scrollLeft } function Gl(e) {
  if (Xi(e) === 'html')
    return e; const t = e.assignedSlot || e.parentNode || vm(e) && e.host || Gi(e); return vm(t) ? t.host : t
} function yb(e) { const t = Gl(e); return Ph(t) ? t.ownerDocument.body : Or(t) && Eu(t) ? t : yb(t) } function Gc(e, t) { let r; t === void 0 && (t = []); const o = yb(e); const s = o === ((r = e.ownerDocument) == null ? void 0 : r.body); const c = Qn(o); return s ? t.concat(c, c.visualViewport || [], Eu(o) ? o : []) : t.concat(o, Gc(o)) } function mm(e, t, r) { return t === 'viewport' ? Nl(function (o, s) { const c = Qn(o); const f = Gi(o); const d = c.visualViewport; let h = f.clientWidth; let g = f.clientHeight; let v = 0; let y = 0; if (d) { h = d.width, g = d.height; const b = pb(); (b || !b && s === 'fixed') && (v = d.offsetLeft, y = d.offsetTop) } return { width: h, height: g, x: v, y } }(e, r)) : ji(t) ? Nl(function (o, s) { const c = jl(o, !0, s === 'fixed'); const f = c.top + o.clientTop; const d = c.left + o.clientLeft; const h = Or(o) ? ms(o) : { x: 1, y: 1 }; return { width: o.clientWidth * h.x, height: o.clientHeight * h.y, x: d * h.x, y: f * h.y } }(t, r)) : Nl(function (o) { const s = Gi(o); const c = Lu(o); const f = o.ownerDocument.body; const d = $l(s.scrollWidth, s.clientWidth, f.scrollWidth, f.clientWidth); const h = $l(s.scrollHeight, s.clientHeight, f.scrollHeight, f.clientHeight); let g = -c.scrollLeft + mb(o); const v = -c.scrollTop; return $r(f).direction === 'rtl' && (g += $l(s.clientWidth, f.clientWidth) - d), { width: d, height: h, x: g, y: v } }(Gi(e))) } function ym(e) { return Or(e) && $r(e).position !== 'fixed' ? e.offsetParent : null } function bm(e) {
  const t = Qn(e); let r = ym(e); for (;r && YT(r) && $r(r).position === 'static';)r = ym(r); return r && (Xi(r) === 'html' || Xi(r) === 'body' && $r(r).position === 'static' && !Ad(r))
    ? t
    : r || (function (o) {
      let s = Gl(o); for (;Or(s) && !Ph(s);) {
        if (Ad(s))
          return s; s = Gl(s)
      } return null
    }(e)) || t
} function ZT(e, t, r) {
  const o = Or(t); const s = Gi(t); const c = jl(e, !0, r === 'fixed', t); let f = { scrollLeft: 0, scrollTop: 0 }; const d = { x: 0, y: 0 }; if (o || !o && r !== 'fixed') {
    if ((Xi(t) !== 'body' || Eu(s)) && (f = Lu(t)), Or(t)) { const h = jl(t, !0); d.x = h.x + t.clientLeft, d.y = h.y + t.clientTop }
    else {
      s && (d.x = mb(s))
    }
  } return { x: c.left + f.scrollLeft - d.x, y: c.top + f.scrollTop - d.y, width: c.width, height: c.height }
} const JT = { getClippingRect(e) {
  const { element: t, boundary: r, rootBoundary: o, strategy: s } = e; const c = r === 'clippingAncestors'
    ? (function (g, v) {
        const y = v.get(g); if (y)
          return y; let b = Gc(g).filter(M => ji(M) && Xi(M) !== 'body'); let x = null; const T = $r(g).position === 'fixed'; let E = T ? Gl(g) : g; for (;ji(E) && !Ph(E);) { const M = $r(E); const N = Ad(E); (T ? N || x : N || M.position !== 'static' || !x || !['absolute', 'fixed'].includes(x.position)) ? x = M : b = b.filter(L => L !== E), E = Gl(E) } return v.set(g, b), b
      }(t, this._c))
    : [].concat(r); const f = [...c, o]; const d = f[0]; const h = f.reduce((g, v) => { const y = mm(t, v, s); return g.top = $l(y.top, g.top), g.right = gm(y.right, g.right), g.bottom = gm(y.bottom, g.bottom), g.left = $l(y.left, g.left), g }, mm(t, d, s)); return { width: h.right - h.left, height: h.bottom - h.top, x: h.left, y: h.top }
}, convertOffsetParentRelativeRectToViewportRelativeRect(e) {
  const { rect: t, offsetParent: r, strategy: o } = e; const s = Or(r); const c = Gi(r); if (r === c)
    return t; let f = { scrollLeft: 0, scrollTop: 0 }; let d = { x: 1, y: 1 }; const h = { x: 0, y: 0 }; if ((s || !s && o !== 'fixed') && ((Xi(r) !== 'body' || Eu(c)) && (f = Lu(r)), Or(r))) { const g = jl(r); d = ms(r), h.x = g.x + r.clientLeft, h.y = g.y + r.clientTop } return { width: t.width * d.x, height: t.height * d.y, x: t.x * d.x - f.scrollLeft * d.x + h.x, y: t.y * d.y - f.scrollTop * d.y + h.y }
}, isElement: ji, getDimensions(e) { return Or(e) ? fb(e) : e.getBoundingClientRect() }, getOffsetParent: bm, getDocumentElement: Gi, getScale: ms, async getElementRects(e) { const { reference: t, floating: r, strategy: o } = e; const s = this.getOffsetParent || bm; const c = this.getDimensions; return { reference: ZT(t, await s(r), o), floating: { x: 0, y: 0, ...await c(r) } } }, getClientRects: e => Array.from(e.getClientRects()), isRTL: e => $r(e).direction === 'rtl' }; function QT(e, t, r) { const o = new Map(); const s = { platform: JT, ...r }; const c = { ...s.platform, _c: o }; return qT(e, t, { ...s, platform: c }) } function bb(e, t) { for (const r in t)Object.prototype.hasOwnProperty.call(t, r) && (typeof t[r] == 'object' && e[r] ? bb(e[r], t[r]) : e[r] = t[r]) } const wr = { disabled: !1, distance: 5, skidding: 0, container: 'body', boundary: void 0, instantMove: !1, disposeTimeout: 150, popperTriggers: [], strategy: 'absolute', preventOverflow: !0, flip: !0, shift: !0, overflowPadding: 0, arrowPadding: 0, arrowOverflow: !0, autoHideOnMousedown: !1, themes: { tooltip: { placement: 'top', triggers: ['hover', 'focus', 'touch'], hideTriggers: e => [...e, 'click'], delay: { show: 200, hide: 0 }, handleResize: !1, html: !1, loadingContent: '...' }, dropdown: { placement: 'bottom', triggers: ['click'], delay: 0, handleResize: !0, autoHide: !0 }, menu: { $extend: 'dropdown', triggers: ['hover', 'focus'], popperTriggers: ['hover'], delay: { show: 0, hide: 400 } } } }; function Kl(e, t) { let r = wr.themes[e] || {}; let o; do o = r[t], typeof o > 'u' ? r.$extend ? r = wr.themes[r.$extend] || {} : (r = null, o = wr[t]) : r = null; while (r); return o } function eE(e) { const t = [e]; let r = wr.themes[e] || {}; do r.$extend && !r.$resetCss ? (t.push(r.$extend), r = wr.themes[r.$extend] || {}) : r = null; while (r); return t.map(o => `v-popper--theme-${o}`) } function wm(e) { const t = [e]; let r = wr.themes[e] || {}; do r.$extend ? (t.push(r.$extend), r = wr.themes[r.$extend] || {}) : r = null; while (r); return t } let Ts = !1; if (typeof window < 'u') {
  Ts = !1; try { const e = Object.defineProperty({}, 'passive', { get() { Ts = !0 } }); window.addEventListener('test', null, e) }
  catch {}
} let wb = !1; typeof window < 'u' && typeof navigator < 'u' && (wb = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream); const xb = ['auto', 'top', 'bottom', 'left', 'right'].reduce((e, t) => e.concat([t, `${t}-start`, `${t}-end`]), []); const xm = { hover: 'mouseenter', focus: 'focus', click: 'click', touch: 'touchstart', pointer: 'pointerdown' }; const _m = { hover: 'mouseleave', focus: 'blur', click: 'click', touch: 'touchend', pointer: 'pointerup' }; function Sm(e, t) { const r = e.indexOf(t); r !== -1 && e.splice(r, 1) } function Yf() { return new Promise(e => requestAnimationFrame(() => { requestAnimationFrame(e) })) } const Un = []; let bo = null; const km = {}; function Cm(e) { let t = km[e]; return t || (t = km[e] = []), t } let Md = function () {}; typeof window < 'u' && (Md = window.Element); function at(e) { return function (t) { return Kl(t.theme, e) } } const Zf = '__floating-vue__popper'; function _b() {
  return ft({ name: 'VPopper', provide() { return { [Zf]: { parentPopper: this } } }, inject: { [Zf]: { default: null } }, props: { theme: { type: String, required: !0 }, targetNodes: { type: Function, required: !0 }, referenceNode: { type: Function, default: null }, popperNode: { type: Function, required: !0 }, shown: { type: Boolean, default: !1 }, showGroup: { type: String, default: null }, ariaId: { default: null }, disabled: { type: Boolean, default: at('disabled') }, positioningDisabled: { type: Boolean, default: at('positioningDisabled') }, placement: { type: String, default: at('placement'), validator: e => xb.includes(e) }, delay: { type: [String, Number, Object], default: at('delay') }, distance: { type: [Number, String], default: at('distance') }, skidding: { type: [Number, String], default: at('skidding') }, triggers: { type: Array, default: at('triggers') }, showTriggers: { type: [Array, Function], default: at('showTriggers') }, hideTriggers: { type: [Array, Function], default: at('hideTriggers') }, popperTriggers: { type: Array, default: at('popperTriggers') }, popperShowTriggers: { type: [Array, Function], default: at('popperShowTriggers') }, popperHideTriggers: { type: [Array, Function], default: at('popperHideTriggers') }, container: { type: [String, Object, Md, Boolean], default: at('container') }, boundary: { type: [String, Md], default: at('boundary') }, strategy: { type: String, validator: e => ['absolute', 'fixed'].includes(e), default: at('strategy') }, autoHide: { type: [Boolean, Function], default: at('autoHide') }, handleResize: { type: Boolean, default: at('handleResize') }, instantMove: { type: Boolean, default: at('instantMove') }, eagerMount: { type: Boolean, default: at('eagerMount') }, popperClass: { type: [String, Array, Object], default: at('popperClass') }, computeTransformOrigin: { type: Boolean, default: at('computeTransformOrigin') }, autoMinSize: { type: Boolean, default: at('autoMinSize') }, autoSize: { type: [Boolean, String], default: at('autoSize') }, autoMaxSize: { type: Boolean, default: at('autoMaxSize') }, autoBoundaryMaxSize: { type: Boolean, default: at('autoBoundaryMaxSize') }, preventOverflow: { type: Boolean, default: at('preventOverflow') }, overflowPadding: { type: [Number, String], default: at('overflowPadding') }, arrowPadding: { type: [Number, String], default: at('arrowPadding') }, arrowOverflow: { type: Boolean, default: at('arrowOverflow') }, flip: { type: Boolean, default: at('flip') }, shift: { type: Boolean, default: at('shift') }, shiftCrossAxis: { type: Boolean, default: at('shiftCrossAxis') }, noAutoFocus: { type: Boolean, default: at('noAutoFocus') }, disposeTimeout: { type: Number, default: at('disposeTimeout') } }, emits: { 'show': () => !0, 'hide': () => !0, 'update:shown': e => !0, 'apply-show': () => !0, 'apply-hide': () => !0, 'close-group': () => !0, 'close-directive': () => !0, 'auto-hide': () => !0, 'resize': () => !0 }, data() { return { isShown: !1, isMounted: !1, skipTransition: !1, classes: { showFrom: !1, showTo: !1, hideFrom: !1, hideTo: !0 }, result: { x: 0, y: 0, placement: '', strategy: this.strategy, arrow: { x: 0, y: 0, centerOffset: 0 }, transformOrigin: null }, randomId: `popper_${[Math.random(), Date.now()].map(e => e.toString(36).substring(2, 10)).join('_')}`, shownChildren: new Set(), lastAutoHide: !0, pendingHide: !1, containsGlobalTarget: !1, isDisposed: !0, mouseDownContains: !1 } }, computed: { popperId() { return this.ariaId != null ? this.ariaId : this.randomId }, shouldMountContent() { return this.eagerMount || this.isMounted }, slotData() { return { popperId: this.popperId, isShown: this.isShown, shouldMountContent: this.shouldMountContent, skipTransition: this.skipTransition, autoHide: typeof this.autoHide == 'function' ? this.lastAutoHide : this.autoHide, show: this.show, hide: this.hide, handleResize: this.handleResize, onResize: this.onResize, classes: { ...this.classes, popperClass: this.popperClass }, result: this.positioningDisabled ? null : this.result, attrs: this.$attrs } }, parentPopper() { let e; return (e = this[Zf]) == null ? void 0 : e.parentPopper }, hasPopperShowTriggerHover() { let e, t; return ((e = this.popperTriggers) == null ? void 0 : e.includes('hover')) || ((t = this.popperShowTriggers) == null ? void 0 : t.includes('hover')) } }, watch: { shown: '$_autoShowHide', disabled(e) { e ? this.dispose() : this.init() }, async container() { this.isShown && (this.$_ensureTeleport(), await this.$_computePosition()) }, triggers: { handler: '$_refreshListeners', deep: !0 }, positioningDisabled: '$_refreshListeners', ...['placement', 'distance', 'skidding', 'boundary', 'strategy', 'overflowPadding', 'arrowPadding', 'preventOverflow', 'shift', 'shiftCrossAxis', 'flip'].reduce((e, t) => (e[t] = '$_computePosition', e), {}) }, created() { this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn('[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.') }, mounted() { this.init(), this.$_detachPopperNode() }, activated() { this.$_autoShowHide() }, deactivated() { this.hide() }, beforeUnmount() { this.dispose() }, methods: { show({ event: e = null, skipDelay: t = !1, force: r = !1 } = {}) { let o, s; (o = this.parentPopper) != null && o.lockedChild && this.parentPopper.lockedChild !== this || (this.pendingHide = !1, (r || !this.disabled) && (((s = this.parentPopper) == null ? void 0 : s.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e, t), this.$emit('show'), this.$_showFrameLocked = !0, requestAnimationFrame(() => { this.$_showFrameLocked = !1 })), this.$emit('update:shown', !0)) }, hide({ event: e = null, skipDelay: t = !1 } = {}) { let r; if (!this.$_hideInProgress) { if (this.shownChildren.size > 0) { this.pendingHide = !0; return } if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) { this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => { this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t }), this.parentPopper.lockedChild = null) }, 1e3)); return }((r = this.parentPopper) == null ? void 0 : r.lockedChild) === this && (this.parentPopper.lockedChild = null), this.pendingHide = !1, this.$_scheduleHide(e, t), this.$emit('hide'), this.$emit('update:shown', !1) } }, init() { let e; this.isDisposed && (this.isDisposed = !1, this.isMounted = !1, this.$_events = [], this.$_preventShow = !1, this.$_referenceNode = ((e = this.referenceNode) == null ? void 0 : e.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter(t => t.nodeType === t.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector('.v-popper__inner'), this.$_arrowNode = this.$_popperNode.querySelector('.v-popper__arrow-container'), this.$_swapTargetAttrs('title', 'data-original-title'), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show()) }, dispose() { this.isDisposed || (this.isDisposed = !0, this.$_removeEventListeners(), this.hide({ skipDelay: !0 }), this.$_detachPopperNode(), this.isMounted = !1, this.isShown = !1, this.$_updateParentShownChildren(!1), this.$_swapTargetAttrs('data-original-title', 'title')) }, async onResize() { this.isShown && (await this.$_computePosition(), this.$emit('resize')) }, async $_computePosition() {
    if (this.isDisposed || this.positioningDisabled)
      return; const e = { strategy: this.strategy, middleware: [] }; (this.distance || this.skidding) && e.middleware.push(GT({ mainAxis: this.distance, crossAxis: this.skidding })); const t = this.placement.startsWith('auto'); if (t ? e.middleware.push(UT({ alignment: this.placement.split('-')[1] ?? '' })) : e.placement = this.placement, this.preventOverflow && (this.shift && e.middleware.push(KT({ padding: this.overflowPadding, boundary: this.boundary, crossAxis: this.shiftCrossAxis })), !t && this.flip && e.middleware.push(VT({ padding: this.overflowPadding, boundary: this.boundary }))), e.middleware.push(BT({ element: this.$_arrowNode, padding: this.arrowPadding })), this.arrowOverflow && e.middleware.push({ name: 'arrowOverflow', fn: ({ placement: o, rects: s, middlewareData: c }) => { let f; const { centerOffset: d } = c.arrow; return o.startsWith('top') || o.startsWith('bottom') ? f = Math.abs(d) > s.reference.width / 2 : f = Math.abs(d) > s.reference.height / 2, { data: { overflow: f } } } }), this.autoMinSize || this.autoSize) {
      const o = this.autoSize ? this.autoSize : this.autoMinSize ? 'min' : null; e.middleware.push({ name: 'autoSize', fn: ({ rects: s, placement: c, middlewareData: f }) => {
        let d; if ((d = f.autoSize) != null && d.skip)
          return {}; let h, g; return c.startsWith('top') || c.startsWith('bottom') ? h = s.reference.width : g = s.reference.height, this.$_innerNode.style[o === 'min' ? 'minWidth' : o === 'max' ? 'maxWidth' : 'width'] = h != null ? `${h}px` : null, this.$_innerNode.style[o === 'min' ? 'minHeight' : o === 'max' ? 'maxHeight' : 'height'] = g != null ? `${g}px` : null, { data: { skip: !0 }, reset: { rects: !0 } }
      } })
    }(this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e.middleware.push(XT({ boundary: this.boundary, padding: this.overflowPadding, apply: ({ availableWidth: o, availableHeight: s }) => { this.$_innerNode.style.maxWidth = o != null ? `${o}px` : null, this.$_innerNode.style.maxHeight = s != null ? `${s}px` : null } }))); const r = await QT(this.$_referenceNode, this.$_popperNode, e); Object.assign(this.result, { x: r.x, y: r.y, placement: r.placement, strategy: r.strategy, arrow: { ...r.middlewareData.arrow, ...r.middlewareData.arrowOverflow } })
  }, $_scheduleShow(e, t = !1) { if (this.$_updateParentShownChildren(!0), this.$_hideInProgress = !1, clearTimeout(this.$_scheduleTimer), bo && this.instantMove && bo.instantMove && bo !== this.parentPopper) { bo.$_applyHide(!0), this.$_applyShow(!0); return }t ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay('show')) }, $_scheduleHide(e, t = !1) { if (this.shownChildren.size > 0) { this.pendingHide = !0; return } this.$_updateParentShownChildren(!1), this.$_hideInProgress = !0, clearTimeout(this.$_scheduleTimer), this.isShown && (bo = this), t ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay('hide')) }, $_computeDelay(e) { const t = this.delay; return Number.parseInt(t && t[e] || t || 0) }, async $_applyShow(e = !1) { clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e, !this.isShown && (this.$_ensureTeleport(), await Yf(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([...Gc(this.$_referenceNode), ...Gc(this.$_popperNode)], 'scroll', () => { this.$_computePosition() })) }, async $_applyShowEffect() {
    if (this.$_hideInProgress)
      return; if (this.computeTransformOrigin) { const t = this.$_referenceNode.getBoundingClientRect(); const r = this.$_popperNode.querySelector('.v-popper__wrapper'); const o = r.parentNode.getBoundingClientRect(); const s = t.x + t.width / 2 - (o.left + r.offsetLeft); const c = t.y + t.height / 2 - (o.top + r.offsetTop); this.result.transformOrigin = `${s}px ${c}px` } this.isShown = !0, this.$_applyAttrsToTarget({ 'aria-describedby': this.popperId, 'data-popper-shown': '' }); const e = this.showGroup; if (e) { let t; for (let r = 0; r < Un.length; r++)t = Un[r], t.showGroup !== e && (t.hide(), t.$emit('close-group')) }Un.push(this), document.body.classList.add('v-popper--some-open'); for (const t of wm(this.theme))Cm(t).push(this), document.body.classList.add(`v-popper--some-open--${t}`); this.$emit('apply-show'), this.classes.showFrom = !0, this.classes.showTo = !1, this.classes.hideFrom = !1, this.classes.hideTo = !1, await Yf(), this.classes.showFrom = !1, this.classes.showTo = !0, this.noAutoFocus || this.$_popperNode.focus()
  }, async $_applyHide(e = !1) {
    if (this.shownChildren.size > 0) { this.pendingHide = !0, this.$_hideInProgress = !1; return } if (clearTimeout(this.$_scheduleTimer), !this.isShown)
      return; this.skipTransition = e, Sm(Un, this), Un.length === 0 && document.body.classList.remove('v-popper--some-open'); for (const r of wm(this.theme)) { const o = Cm(r); Sm(o, this), o.length === 0 && document.body.classList.remove(`v-popper--some-open--${r}`) }bo === this && (bo = null), this.isShown = !1, this.$_applyAttrsToTarget({ 'aria-describedby': void 0, 'data-popper-shown': void 0 }), clearTimeout(this.$_disposeTimer); const t = this.disposeTimeout; t !== null && (this.$_disposeTimer = setTimeout(() => { this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = !1) }, t)), this.$_removeEventListeners('scroll'), this.$emit('apply-hide'), this.classes.showFrom = !1, this.classes.showTo = !1, this.classes.hideFrom = !0, this.classes.hideTo = !1, await Yf(), this.classes.hideFrom = !1, this.classes.hideTo = !0
  }, $_autoShowHide() { this.shown ? this.show() : this.hide() }, $_ensureTeleport() {
    if (this.isDisposed)
      return; let e = this.container; if (typeof e == 'string' ? e = window.document.querySelector(e) : e === !1 && (e = this.$_targetNodes[0].parentNode), !e)
      throw new Error(`No container for popover: ${this.container}`); e.appendChild(this.$_popperNode), this.isMounted = !0
  }, $_addEventListeners() { const e = (r) => { this.isShown && !this.$_hideInProgress || (r.usedByTooltip = !0, !this.$_preventShow && this.show({ event: r })) }; this.$_registerTriggerListeners(this.$_targetNodes, xm, this.triggers, this.showTriggers, e), this.$_registerTriggerListeners([this.$_popperNode], xm, this.popperTriggers, this.popperShowTriggers, e); const t = (r) => { r.usedByTooltip || this.hide({ event: r }) }; this.$_registerTriggerListeners(this.$_targetNodes, _m, this.triggers, this.hideTriggers, t), this.$_registerTriggerListeners([this.$_popperNode], _m, this.popperTriggers, this.popperHideTriggers, t) }, $_registerEventListeners(e, t, r) { this.$_events.push({ targetNodes: e, eventType: t, handler: r }), e.forEach(o => o.addEventListener(t, r, Ts ? { passive: !0 } : void 0)) }, $_registerTriggerListeners(e, t, r, o, s) { let c = r; o != null && (c = typeof o == 'function' ? o(c) : o), c.forEach((f) => { const d = t[f]; d && this.$_registerEventListeners(e, d, s) }) }, $_removeEventListeners(e) { const t = []; this.$_events.forEach((r) => { const { targetNodes: o, eventType: s, handler: c } = r; !e || e === s ? o.forEach(f => f.removeEventListener(s, c)) : t.push(r) }), this.$_events = t }, $_refreshListeners() { this.isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners()) }, $_handleGlobalClose(e, t = !1) { this.$_showFrameLocked || (this.hide({ event: e }), e.closePopover ? this.$emit('close-directive') : this.$emit('auto-hide'), t && (this.$_preventShow = !0, setTimeout(() => { this.$_preventShow = !1 }, 300))) }, $_detachPopperNode() { this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode) }, $_swapTargetAttrs(e, t) { for (const r of this.$_targetNodes) { const o = r.getAttribute(e); o && (r.removeAttribute(e), r.setAttribute(t, o)) } }, $_applyAttrsToTarget(e) {
    for (const t of this.$_targetNodes) {
      for (const r in e) { const o = e[r]; o == null ? t.removeAttribute(r) : t.setAttribute(r, o) }
    }
  }, $_updateParentShownChildren(e) { let t = this.parentPopper; for (;t;)e ? t.shownChildren.add(this.randomId) : (t.shownChildren.delete(this.randomId), t.pendingHide && t.hide()), t = t.parentPopper }, $_isAimingPopper() { const e = this.$_referenceNode.getBoundingClientRect(); if (Ol >= e.left && Ol <= e.right && Pl >= e.top && Pl <= e.bottom) { const t = this.$_popperNode.getBoundingClientRect(); const r = Ol - $i; const o = Pl - Oi; const s = t.left + t.width / 2 - $i + (t.top + t.height / 2) - Oi + t.width + t.height; const c = $i + r * s; const f = Oi + o * s; return oc($i, Oi, c, f, t.left, t.top, t.left, t.bottom) || oc($i, Oi, c, f, t.left, t.top, t.right, t.top) || oc($i, Oi, c, f, t.right, t.top, t.right, t.bottom) || oc($i, Oi, c, f, t.left, t.bottom, t.right, t.bottom) } return !1 } }, render() { return this.$slots.default(this.slotData) } })
} if (typeof document < 'u' && typeof window < 'u') {
  if (wb) { const e = Ts ? { passive: !0, capture: !0 } : !0; document.addEventListener('touchstart', t => Tm(t, !0), e), document.addEventListener('touchend', t => Em(t, !0), e) }
  else {
    window.addEventListener('mousedown', e => Tm(e, !1), !0), window.addEventListener('click', e => Em(e, !1), !0)
  }window.addEventListener('resize', nE)
} function Tm(e, t) {
  if (wr.autoHideOnMousedown) {
    Sb(e, t)
  }
  else {
    for (let r = 0; r < Un.length; r++) {
      const o = Un[r]; try { o.mouseDownContains = o.popperNode().contains(e.target) }
      catch {}
    }
  }
} function Em(e, t) { wr.autoHideOnMousedown || Sb(e, t) } function Sb(e, t) {
  const r = {}; for (let o = Un.length - 1; o >= 0; o--) {
    const s = Un[o]; try { const c = s.containsGlobalTarget = s.mouseDownContains || s.popperNode().contains(e.target); s.pendingHide = !1, requestAnimationFrame(() => { if (s.pendingHide = !1, !r[s.randomId] && Lm(s, c, e)) { if (s.$_handleGlobalClose(e, t), !e.closeAllPopover && e.closePopover && c) { let d = s.parentPopper; for (;d;)r[d.randomId] = !0, d = d.parentPopper; return } let f = s.parentPopper; for (;f && Lm(f, f.containsGlobalTarget, e);)f.$_handleGlobalClose(e, t), f = f.parentPopper } }) }
    catch {}
  }
} function Lm(e, t, r) { return r.closeAllPopover || r.closePopover && t || tE(e, r) && !t } function tE(e, t) { if (typeof e.autoHide == 'function') { const r = e.autoHide(t); return e.lastAutoHide = r, r } return e.autoHide } function nE() { for (let e = 0; e < Un.length; e++)Un[e].$_computePosition() } function Am() { for (let e = 0; e < Un.length; e++)Un[e].hide() } let $i = 0; let Oi = 0; let Ol = 0; let Pl = 0; typeof window < 'u' && window.addEventListener('mousemove', (e) => { $i = Ol, Oi = Pl, Ol = e.clientX, Pl = e.clientY }, Ts ? { passive: !0 } : void 0); function oc(e, t, r, o, s, c, f, d) { const h = ((f - s) * (t - c) - (d - c) * (e - s)) / ((d - c) * (r - e) - (f - s) * (o - t)); const g = ((r - e) * (t - c) - (o - t) * (e - s)) / ((d - c) * (r - e) - (f - s) * (o - t)); return h >= 0 && h <= 1 && g >= 0 && g <= 1 } const rE = { extends: _b() }; function Au(e, t) { const r = e.__vccOpts || e; for (const [o, s] of t)r[o] = s; return r } function iE(e, t, r, o, s, c) { return oe(), me('div', { ref: 'reference', class: lt(['v-popper', { 'v-popper--shown': e.slotData.isShown }]) }, [dn(e.$slots, 'default', Z_(By(e.slotData)))], 2) } const oE = Au(rE, [['render', iE]]); function sE() {
  const e = window.navigator.userAgent; const t = e.indexOf('MSIE '); if (t > 0)
    return Number.parseInt(e.substring(t + 5, e.indexOf('.', t)), 10); const r = e.indexOf('Trident/'); if (r > 0) { const o = e.indexOf('rv:'); return Number.parseInt(e.substring(o + 3, e.indexOf('.', o)), 10) } const s = e.indexOf('Edge/'); return s > 0 ? Number.parseInt(e.substring(s + 5, e.indexOf('.', s)), 10) : -1
} let Sc; function Nd() { Nd.init || (Nd.init = !0, Sc = sE() !== -1) } const Mu = { name: 'ResizeObserver', props: { emitOnMount: { type: Boolean, default: !1 }, ignoreWidth: { type: Boolean, default: !1 }, ignoreHeight: { type: Boolean, default: !1 } }, emits: ['notify'], mounted() { Nd(), ln(() => { this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize() }); const e = document.createElement('object'); this._resizeObject = e, e.setAttribute('aria-hidden', 'true'), e.setAttribute('tabindex', -1), e.onload = this.addResizeHandlers, e.type = 'text/html', Sc && this.$el.appendChild(e), e.data = 'about:blank', Sc || this.$el.appendChild(e) }, beforeUnmount() { this.removeResizeHandlers() }, methods: { compareAndNotify() { (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize()) }, emitSize() { this.$emit('notify', { width: this._w, height: this._h }) }, addResizeHandlers() { this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify), this.compareAndNotify() }, removeResizeHandlers() { this._resizeObject && this._resizeObject.onload && (!Sc && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null) } } }; const lE = dy(); la('data-v-b329ee4c'); const aE = { class: 'resize-observer', tabindex: '-1' }; aa(); const cE = lE((e, t, r, o, s, c) => (oe(), ot('div', aE))); Mu.render = cE; Mu.__scopeId = 'data-v-b329ee4c'; Mu.__file = 'src/components/ResizeObserver.vue'; const kb = (e = 'theme') => ({ computed: { themeClass() { return eE(this[e]) } } }); const uE = ft({ name: 'VPopperContent', components: { ResizeObserver: Mu }, mixins: [kb()], props: { popperId: String, theme: String, shown: Boolean, mounted: Boolean, skipTransition: Boolean, autoHide: Boolean, handleResize: Boolean, classes: Object, result: Object }, emits: ['hide', 'resize'], methods: { toPx(e) { return e != null && !isNaN(e) ? `${e}px` : null } } }); const fE = ['id', 'aria-hidden', 'tabindex', 'data-popper-placement']; const dE = { ref: 'inner', class: 'v-popper__inner' }; const hE = Y('div', { class: 'v-popper__arrow-outer' }, null, -1); const pE = Y('div', { class: 'v-popper__arrow-inner' }, null, -1); const gE = [hE, pE]; function vE(e, t, r, o, s, c) { const f = Ao('ResizeObserver'); return oe(), me('div', { 'id': e.popperId, 'ref': 'popover', 'class': lt(['v-popper__popper', [e.themeClass, e.classes.popperClass, { 'v-popper__popper--shown': e.shown, 'v-popper__popper--hidden': !e.shown, 'v-popper__popper--show-from': e.classes.showFrom, 'v-popper__popper--show-to': e.classes.showTo, 'v-popper__popper--hide-from': e.classes.hideFrom, 'v-popper__popper--hide-to': e.classes.hideTo, 'v-popper__popper--skip-transition': e.skipTransition, 'v-popper__popper--arrow-overflow': e.result && e.result.arrow.overflow, 'v-popper__popper--no-positioning': !e.result }]]), 'style': Zt(e.result ? { position: e.result.strategy, transform: `translate3d(${Math.round(e.result.x)}px,${Math.round(e.result.y)}px,0)` } : void 0), 'aria-hidden': e.shown ? 'false' : 'true', 'tabindex': e.autoHide ? 0 : void 0, 'data-popper-placement': e.result ? e.result.placement : void 0, 'onKeyup': t[2] || (t[2] = kd(d => e.autoHide && e.$emit('hide'), ['esc'])) }, [Y('div', { class: 'v-popper__backdrop', onClick: t[0] || (t[0] = d => e.autoHide && e.$emit('hide')) }), Y('div', { class: 'v-popper__wrapper', style: Zt(e.result ? { transformOrigin: e.result.transformOrigin } : void 0) }, [Y('div', dE, [e.mounted ? (oe(), me(ut, { key: 0 }, [Y('div', null, [dn(e.$slots, 'default')]), e.handleResize ? (oe(), ot(f, { key: 0, onNotify: t[1] || (t[1] = d => e.$emit('resize', d)) })) : et('', !0)], 64)) : et('', !0)], 512), Y('div', { ref: 'arrow', class: 'v-popper__arrow-container', style: Zt(e.result ? { left: e.toPx(e.result.arrow.x), top: e.toPx(e.result.arrow.y) } : void 0) }, gE, 4)], 4)], 46, fE) } const Cb = Au(uE, [['render', vE]]); const Tb = { methods: { show(...e) { return this.$refs.popper.show(...e) }, hide(...e) { return this.$refs.popper.hide(...e) }, dispose(...e) { return this.$refs.popper.dispose(...e) }, onResize(...e) { return this.$refs.popper.onResize(...e) } } }; let $d = function () {}; typeof window < 'u' && ($d = window.Element); const mE = ft({ name: 'VPopperWrapper', components: { Popper: oE, PopperContent: Cb }, mixins: [Tb, kb('finalTheme')], props: { theme: { type: String, default: null }, referenceNode: { type: Function, default: null }, shown: { type: Boolean, default: !1 }, showGroup: { type: String, default: null }, ariaId: { default: null }, disabled: { type: Boolean, default: void 0 }, positioningDisabled: { type: Boolean, default: void 0 }, placement: { type: String, default: void 0 }, delay: { type: [String, Number, Object], default: void 0 }, distance: { type: [Number, String], default: void 0 }, skidding: { type: [Number, String], default: void 0 }, triggers: { type: Array, default: void 0 }, showTriggers: { type: [Array, Function], default: void 0 }, hideTriggers: { type: [Array, Function], default: void 0 }, popperTriggers: { type: Array, default: void 0 }, popperShowTriggers: { type: [Array, Function], default: void 0 }, popperHideTriggers: { type: [Array, Function], default: void 0 }, container: { type: [String, Object, $d, Boolean], default: void 0 }, boundary: { type: [String, $d], default: void 0 }, strategy: { type: String, default: void 0 }, autoHide: { type: [Boolean, Function], default: void 0 }, handleResize: { type: Boolean, default: void 0 }, instantMove: { type: Boolean, default: void 0 }, eagerMount: { type: Boolean, default: void 0 }, popperClass: { type: [String, Array, Object], default: void 0 }, computeTransformOrigin: { type: Boolean, default: void 0 }, autoMinSize: { type: Boolean, default: void 0 }, autoSize: { type: [Boolean, String], default: void 0 }, autoMaxSize: { type: Boolean, default: void 0 }, autoBoundaryMaxSize: { type: Boolean, default: void 0 }, preventOverflow: { type: Boolean, default: void 0 }, overflowPadding: { type: [Number, String], default: void 0 }, arrowPadding: { type: [Number, String], default: void 0 }, arrowOverflow: { type: Boolean, default: void 0 }, flip: { type: Boolean, default: void 0 }, shift: { type: Boolean, default: void 0 }, shiftCrossAxis: { type: Boolean, default: void 0 }, noAutoFocus: { type: Boolean, default: void 0 }, disposeTimeout: { type: Number, default: void 0 } }, emits: { 'show': () => !0, 'hide': () => !0, 'update:shown': e => !0, 'apply-show': () => !0, 'apply-hide': () => !0, 'close-group': () => !0, 'close-directive': () => !0, 'auto-hide': () => !0, 'resize': () => !0 }, computed: { finalTheme() { return this.theme ?? this.$options.vPopperTheme } }, methods: { getTargetNodes() { return Array.from(this.$el.children).filter(e => e !== this.$refs.popperContent.$el) } } }); function yE(e, t, r, o, s, c) { const f = Ao('PopperContent'); const d = Ao('Popper'); return oe(), ot(d, ii({ ref: 'popper' }, e.$props, { 'theme': e.finalTheme, 'target-nodes': e.getTargetNodes, 'popper-node': () => e.$refs.popperContent.$el, 'class': [e.themeClass], 'onShow': t[0] || (t[0] = () => e.$emit('show')), 'onHide': t[1] || (t[1] = () => e.$emit('hide')), 'onUpdate:shown': t[2] || (t[2] = h => e.$emit('update:shown', h)), 'onApplyShow': t[3] || (t[3] = () => e.$emit('apply-show')), 'onApplyHide': t[4] || (t[4] = () => e.$emit('apply-hide')), 'onCloseGroup': t[5] || (t[5] = () => e.$emit('close-group')), 'onCloseDirective': t[6] || (t[6] = () => e.$emit('close-directive')), 'onAutoHide': t[7] || (t[7] = () => e.$emit('auto-hide')), 'onResize': t[8] || (t[8] = () => e.$emit('resize')) }), { default: st(({ popperId: h, isShown: g, shouldMountContent: v, skipTransition: y, autoHide: b, show: x, hide: T, handleResize: E, onResize: M, classes: N, result: L }) => [dn(e.$slots, 'default', { shown: g, show: x, hide: T }), Oe(f, { 'ref': 'popperContent', 'popper-id': h, 'theme': e.finalTheme, 'shown': g, 'mounted': v, 'skip-transition': y, 'auto-hide': b, 'handle-resize': E, 'classes': N, 'result': L, 'onHide': T, 'onResize': M }, { default: st(() => [dn(e.$slots, 'popper', { shown: g, hide: T })]), _: 2 }, 1032, ['popper-id', 'theme', 'shown', 'mounted', 'skip-transition', 'auto-hide', 'handle-resize', 'classes', 'result', 'onHide', 'onResize'])]), _: 3 }, 16, ['theme', 'target-nodes', 'popper-node', 'class']) } const Rh = Au(mE, [['render', yE]]); const bE = { ...Rh, name: 'VDropdown', vPopperTheme: 'dropdown' }; const wE = { ...Rh, name: 'VMenu', vPopperTheme: 'menu' }; const Eb = { ...Rh, name: 'VTooltip', vPopperTheme: 'tooltip' }; const xE = ft({ name: 'VTooltipDirective', components: { Popper: _b(), PopperContent: Cb }, mixins: [Tb], inheritAttrs: !1, props: { theme: { type: String, default: 'tooltip' }, html: { type: Boolean, default: e => Kl(e.theme, 'html') }, content: { type: [String, Number, Function], default: null }, loadingContent: { type: String, default: e => Kl(e.theme, 'loadingContent') }, targetNodes: { type: Function, required: !0 } }, data() { return { asyncContent: null } }, computed: { isContentAsync() { return typeof this.content == 'function' }, loading() { return this.isContentAsync && this.asyncContent == null }, finalContent() { return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content } }, watch: { content: { handler() { this.fetchContent(!0) }, immediate: !0 }, async finalContent() { await this.$nextTick(), this.$refs.popper.onResize() } }, created() { this.$_fetchId = 0 }, methods: { fetchContent(e) { if (typeof this.content == 'function' && this.$_isShown && (e || !this.$_loading && this.asyncContent == null)) { this.asyncContent = null, this.$_loading = !0; const t = ++this.$_fetchId; const r = this.content(this); r.then ? r.then(o => this.onResult(t, o)) : this.onResult(t, r) } }, onResult(e, t) { e === this.$_fetchId && (this.$_loading = !1, this.asyncContent = t) }, onShow() { this.$_isShown = !0, this.fetchContent() }, onHide() { this.$_isShown = !1 } } }); const _E = ['innerHTML']; const SE = ['textContent']; function kE(e, t, r, o, s, c) { const f = Ao('PopperContent'); const d = Ao('Popper'); return oe(), ot(d, ii({ ref: 'popper' }, e.$attrs, { 'theme': e.theme, 'target-nodes': e.targetNodes, 'popper-node': () => e.$refs.popperContent.$el, 'onApplyShow': e.onShow, 'onApplyHide': e.onHide }), { default: st(({ popperId: h, isShown: g, shouldMountContent: v, skipTransition: y, autoHide: b, hide: x, handleResize: T, onResize: E, classes: M, result: N }) => [Oe(f, { 'ref': 'popperContent', 'class': lt({ 'v-popper--tooltip-loading': e.loading }), 'popper-id': h, 'theme': e.theme, 'shown': g, 'mounted': v, 'skip-transition': y, 'auto-hide': b, 'handle-resize': T, 'classes': M, 'result': N, 'onHide': x, 'onResize': E }, { default: st(() => [e.html ? (oe(), me('div', { key: 0, innerHTML: e.finalContent }, null, 8, _E)) : (oe(), me('div', { key: 1, textContent: qe(e.finalContent) }, null, 8, SE))]), _: 2 }, 1032, ['class', 'popper-id', 'theme', 'shown', 'mounted', 'skip-transition', 'auto-hide', 'handle-resize', 'classes', 'result', 'onHide', 'onResize'])]), _: 1 }, 16, ['theme', 'target-nodes', 'popper-node', 'onApplyShow', 'onApplyHide']) } const CE = Au(xE, [['render', kE]]); const Lb = 'v-popper--has-tooltip'; function TE(e, t) {
  let r = e.placement; if (!r && t) {
    for (const o of xb)t[o] && (r = o)
  } return r || (r = Kl(e.theme || 'tooltip', 'placement')), r
} function Ab(e, t, r) { let o; const s = typeof t; return s === 'string' ? o = { content: t } : t && s === 'object' ? o = t : o = { content: !1 }, o.placement = TE(o, r), o.targetNodes = () => [e], o.referenceNode = () => e, o } let Jf; let Xl; let EE = 0; function LE() {
  if (Jf)
    return; Xl = Be([]), Jf = Xy({ name: 'VTooltipDirectiveApp', setup() { return { directives: Xl } }, render() { return this.directives.map(t => fa(CE, { ...t.options, shown: t.shown || t.options.shown, key: t.id })) }, devtools: { hide: !0 } }); const e = document.createElement('div'); document.body.appendChild(e), Jf.mount(e)
} function Mb(e, t, r) { LE(); const o = Be(Ab(e, t, r)); const s = Be(!1); const c = { id: EE++, options: o, shown: s }; return Xl.value.push(c), e.classList && e.classList.add(Lb), e.$_popper = { options: o, item: c, show() { s.value = !0 }, hide() { s.value = !1 } } } function Dh(e) { if (e.$_popper) { const t = Xl.value.indexOf(e.$_popper.item); t !== -1 && Xl.value.splice(t, 1), delete e.$_popper, delete e.$_popperOldShown, delete e.$_popperMountTarget }e.classList && e.classList.remove(Lb) } function Mm(e, { value: t, modifiers: r }) {
  const o = Ab(e, t, r); if (!o.content || Kl(o.theme || 'tooltip', 'disabled')) {
    Dh(e)
  }
  else { let s; e.$_popper ? (s = e.$_popper, s.options.value = o) : s = Mb(e, t, r), typeof t.shown < 'u' && t.shown !== e.$_popperOldShown && (e.$_popperOldShown = t.shown, t.shown ? s.show() : s.hide()) }
} const Nb = { beforeMount: Mm, updated: Mm, beforeUnmount(e) { Dh(e) } }; function Nm(e) { e.addEventListener('mousedown', Kc), e.addEventListener('click', Kc), e.addEventListener('touchstart', $b, Ts ? { passive: !0 } : !1) } function $m(e) { e.removeEventListener('mousedown', Kc), e.removeEventListener('click', Kc), e.removeEventListener('touchstart', $b), e.removeEventListener('touchend', Ob), e.removeEventListener('touchcancel', Pb) } function Kc(e) { const t = e.currentTarget; e.closePopover = !t.$_vclosepopover_touch, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all } function $b(e) { if (e.changedTouches.length === 1) { const t = e.currentTarget; t.$_vclosepopover_touch = !0; const r = e.changedTouches[0]; t.$_vclosepopover_touchPoint = r, t.addEventListener('touchend', Ob), t.addEventListener('touchcancel', Pb) } } function Ob(e) { const t = e.currentTarget; if (t.$_vclosepopover_touch = !1, e.changedTouches.length === 1) { const r = e.changedTouches[0]; const o = t.$_vclosepopover_touchPoint; e.closePopover = Math.abs(r.screenY - o.screenY) < 20 && Math.abs(r.screenX - o.screenX) < 20, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all } } function Pb(e) { const t = e.currentTarget; t.$_vclosepopover_touch = !1 } const AE = { beforeMount(e, { value: t, modifiers: r }) { e.$_closePopoverModifiers = r, (typeof t > 'u' || t) && Nm(e) }, updated(e, { value: t, oldValue: r, modifiers: o }) { e.$_closePopoverModifiers = o, t !== r && (typeof t > 'u' || t ? Nm(e) : $m(e)) }, beforeUnmount(e) { $m(e) } }; const ME = Nb; const Rb = Eb; function NE(e, t = {}) { e.$_vTooltipInstalled || (e.$_vTooltipInstalled = !0, bb(wr, t), e.directive('tooltip', Nb), e.directive('close-popper', AE), e.component('VTooltip', Eb), e.component('VDropdown', bE), e.component('VMenu', wE)) } const Db = { version: '5.2.2', install: NE, options: wr }; const $E = 6e4; function zb(e) { return e } const OE = zb; const { clearTimeout: PE, setTimeout: RE } = globalThis; const DE = Math.random.bind(Math); function zE(e, t) {
  const { post: r, on: o, eventNames: s = [], serialize: c = zb, deserialize: f = OE, resolver: d, timeout: h = $E } = t; const g = new Map(); let v; const y = new Proxy({}, { get(b, x) {
    if (x === '$functions')
      return e; if (x === 'then' && !s.includes('then') && !('then' in e))
      return; const T = (...M) => { r(c({ m: x, a: M, t: 'q' })) }; if (s.includes(x))
      return T.asEvent = T, T; const E = async (...M) => (await v, new Promise((N, L) => {
      let H; const O = FE(); let A; h >= 0 && (A = RE(() => {
        let z; try { throw (z = t.onTimeoutError) == null || z.call(t, x, M), new Error(`[birpc] timeout on calling "${x}"`) }
        catch (J) { L(J) }g.delete(O)
      }, h), typeof A == 'object' && (A = (H = A.unref) == null ? void 0 : H.call(A))), g.set(O, { resolve: N, reject: L, timeoutId: A }), r(c({ m: x, a: M, i: O, t: 'q' }))
    })); return E.asEvent = T, E
  } }); return v = o(async (b, ...x) => {
    const T = f(b); if (T.t === 'q') {
      const { m: E, a: M } = T; let N, L; const O = d ? d(E, e[E]) : e[E]; if (!O) {
        L = new Error(`[birpc] function "${E}" not found`)
      }
      else {
        try { N = await O.apply(y, M) }
        catch (A) { L = A }
      }T.i && (L && t.onError && t.onError(L, E, M), r(c({ t: 's', i: T.i, r: N, e: L }), ...x))
    }
    else { const { i: E, r: M, e: N } = T; const L = g.get(E); L && (PE(L.timeoutId), N ? L.reject(N) : L.resolve(M)), g.delete(E) }
  }), y
} const IE = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'; function FE(e = 21) { let t = ''; let r = e; for (;r--;)t += IE[DE() * 64 | 0]; return t } const { parse: HE, stringify: qE } = JSON; const { keys: BE } = Object; const Yl = String; const Ib = 'string'; const Om = {}; const Xc = 'object'; const Fb = (e, t) => t; const WE = e => e instanceof Yl ? Yl(e) : e; const UE = (e, t) => typeof t === Ib ? new Yl(t) : t; function Hb(e, t, r, o) {
  const s = []; for (let c = BE(r), { length: f } = c, d = 0; d < f; d++) {
    const h = c[d]; const g = r[h]; if (g instanceof Yl) { const v = e[g]; typeof v === Xc && !t.has(v) ? (t.add(v), r[h] = Om, s.push({ k: h, a: [e, t, v, o] })) : r[h] = o.call(r, h, v) }
    else {
      r[h] !== Om && (r[h] = o.call(r, h, g))
    }
  } for (let { length: c } = s, f = 0; f < c; f++) { const { k: d, a: h } = s[f]; r[d] = o.call(r, d, Hb.apply(null, h)) } return r
} function Pm(e, t, r) { const o = Yl(t.push(r) - 1); return e.set(r, o), o } function Od(e, t) { const r = HE(e, UE).map(WE); const o = r[0]; const s = t || Fb; const c = typeof o === Xc && o ? Hb(r, new Set(), o, s) : o; return s.call({ '': c }, '', c) } function VE(e, t, r) {
  const o = t && typeof t === Xc ? (v, y) => v === '' || t.includes(v) ? y : void 0 : t || Fb; const s = new Map(); const c = []; const f = []; let d = +Pm(s, c, o.call({ '': e }, '', e)); let h = !d; for (;d < c.length;)h = !0, f[d] = qE(c[d++], g, r); return `[${f.join(',')}]`; function g(v, y) {
    if (h)
      return h = !h, y; const b = o.call(this, v, y); switch (typeof b) {
      case Xc:if (b === null)
        return b; case Ib:return s.get(b) || Pm(s, c, b)
    } return b
  }
} function qb(e) { return e != null } function zh(e) { return e == null && (e = []), Array.isArray(e) ? e : [e] } const jE = /^[A-Z]:\//i; function GE(e = '') { return e && e.replace(/\\/g, '/').replace(jE, t => t.toUpperCase()) } const KE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Z]:[/\\]/i; const Rm = /^\/([A-Z]:)?$/i; function XE() { return typeof process < 'u' && typeof process.cwd == 'function' ? process.cwd().replace(/\\/g, '/') : '/' } const Dm = function (...e) { e = e.map(o => GE(o)); let t = ''; let r = !1; for (let o = e.length - 1; o >= -1 && !r; o--) { const s = o >= 0 ? e[o] : XE(); !s || s.length === 0 || (t = `${s}/${t}`, r = zm(s)) } return t = YE(t, !r), r && !zm(t) ? `/${t}` : t.length > 0 ? t : '.' }; function YE(e, t) {
  let r = ''; let o = 0; let s = -1; let c = 0; let f = null; for (let d = 0; d <= e.length; ++d) {
    if (d < e.length) {
      f = e[d]
    }
    else {
      if (f === '/')
        break; f = '/'
    } if (f === '/') {
      if (!(s === d - 1 || c === 1)) {
        if (c === 2) {
          if (r.length < 2 || o !== 2 || r[r.length - 1] !== '.' || r[r.length - 2] !== '.') {
            if (r.length > 2) { const h = r.lastIndexOf('/'); h === -1 ? (r = '', o = 0) : (r = r.slice(0, h), o = r.length - 1 - r.lastIndexOf('/')), s = d, c = 0; continue }
            else if (r.length > 0) { r = '', o = 0, s = d, c = 0; continue }
          }t && (r += r.length > 0 ? '/..' : '..', o = 2)
        }
        else {
          r.length > 0 ? r += `/${e.slice(s + 1, d)}` : r = e.slice(s + 1, d), o = d - s - 1
        }
      }s = d, c = 0
    }
    else {
      f === '.' && c !== -1 ? ++c : c = -1
    }
  } return r
} const zm = function (e) { return KE.test(e) }; const ZE = function (e, t) {
  const r = Dm(e).replace(Rm, '$1').split('/'); const o = Dm(t).replace(Rm, '$1').split('/'); if (o[0][1] === ':' && r[0][1] === ':' && r[0] !== o[0])
    return o.join('/'); const s = [...r]; for (const c of s) {
    if (o[0] !== c)
      break; r.shift(), o.shift()
  } return [...r.map(() => '..'), ...o].join('/')
}; function JE(e) {
  let t = 0; if (e.length === 0)
    return `${t}`; for (let r = 0; r < e.length; r++) { const o = e.charCodeAt(r); t = (t << 5) - t + o, t = t & t } return `${t}`
} function Bb(e, t, r, o) { const s = ZE(t, e); const c = { id: JE(`${s}${r || ''}`), name: s, type: 'suite', mode: 'run', filepath: e, tasks: [], meta: Object.create(null), projectName: r, file: void 0, pool: o }; return c.file = c, c } function Es(e) { return e.type === 'test' || e.type === 'custom' } function Wb(e) {
  const t = []; const r = zh(e); for (const o of r) {
    if (Es(o)) {
      t.push(o)
    }
    else {
      for (const s of o.tasks) {
        if (Es(s)) {
          t.push(s)
        }
        else { const c = Wb(s); for (const f of c)t.push(f) }
      }
    }
  } return t
} function Ih(e = []) { return zh(e).flatMap(t => Es(t) ? [t] : [t, ...Ih(t.tasks)]) } function QE(e) { const t = [e.name]; let r = e; for (;r != null && r.suite;)r = r.suite, r != null && r.name && t.unshift(r.name); return r !== e.file && t.unshift(e.file.name), t } class Ub {constructor() { ls(this, 'filesMap', new Map()); ls(this, 'pathsSet', new Set()); ls(this, 'idMap', new Map()) }getPaths() { return Array.from(this.pathsSet) }getFiles(t) { return t ? t.map(r => this.filesMap.get(r)).flat().filter(r => r && !r.local) : Array.from(this.filesMap.values()).flat().filter(r => !r.local) }getFilepaths() { return Array.from(this.filesMap.keys()) }getFailedFilepaths() { return this.getFiles().filter((t) => { let r; return ((r = t.result) == null ? void 0 : r.state) === 'fail' }).map(t => t.filepath) }collectPaths(t = []) { t.forEach((r) => { this.pathsSet.add(r) }) }collectFiles(t = []) { t.forEach((r) => { const o = this.filesMap.get(r.filepath) || []; const s = o.filter(f => f.projectName !== r.projectName); const c = o.find(f => f.projectName === r.projectName); c && (r.logs = c.logs), s.push(r), this.filesMap.set(r.filepath, s), this.updateId(r) }) }clearFiles(t, r = []) { const o = t; r.forEach((s) => { const c = this.filesMap.get(s); const f = Bb(s, o.config.root, o.config.name || ''); if (f.local = !0, this.idMap.set(f.id, f), !c) { this.filesMap.set(s, [f]); return } const d = c.filter(h => h.projectName !== o.config.name); d.length ? this.filesMap.set(s, [...d, f]) : this.filesMap.set(s, [f]) }) }updateId(t) { this.idMap.get(t.id) !== t && (this.idMap.set(t.id, t), t.type === 'suite' && t.tasks.forEach((r) => { this.updateId(r) })) }updateTasks(t) { for (const [r, o, s] of t) { const c = this.idMap.get(r); c && (c.result = o, c.meta = s, (o == null ? void 0 : o.state) === 'skip' && (c.mode = 'skip')) } }updateUserLog(t) { const r = t.taskId && this.idMap.get(t.taskId); r && (r.logs || (r.logs = []), r.logs.push(t)) }} function Fh(e) { return Wb(e).some((t) => { let r, o; return (o = (r = t.result) == null ? void 0 : r.errors) == null ? void 0 : o.some(s => typeof (s == null ? void 0 : s.message) == 'string' && s.message.match(/Snapshot .* mismatched/)) }) } function eL(e, t = {}) { const { handlers: r = {}, autoReconnect: o = !0, reconnectInterval: s = 2e3, reconnectTries: c = 10, connectTimeout: f = 6e4, reactive: d = L => L, WebSocketConstructor: h = globalThis.WebSocket } = t; let g = c; const v = d({ ws: new h(e), state: new Ub(), waitForConnection: N, reconnect: E }, 'state'); v.state.filesMap = d(v.state.filesMap, 'filesMap'), v.state.idMap = d(v.state.idMap, 'idMap'); let y; const b = { onSpecsCollected(L) { let O; L == null || L.forEach(([A, H]) => { v.state.clearFiles({ config: A }, [H]) }), (O = r.onSpecsCollected) == null || O.call(r, L) }, onPathsCollected(L) { let O; v.state.collectPaths(L), (O = r.onPathsCollected) == null || O.call(r, L) }, onCollected(L) { let O; v.state.collectFiles(L), (O = r.onCollected) == null || O.call(r, L) }, onTaskUpdate(L) { let O; v.state.updateTasks(L), (O = r.onTaskUpdate) == null || O.call(r, L) }, onUserConsoleLog(L) { let O; v.state.updateUserLog(L), (O = r.onUserConsoleLog) == null || O.call(r, L) }, onFinished(L, O) { let A; (A = r.onFinished) == null || A.call(r, L, O) }, onFinishedReportCoverage() { let L; (L = r.onFinishedReportCoverage) == null || L.call(r) } }; const x = { post: L => v.ws.send(L), on: L => y = L, serialize: L => VE(L, (O, A) => A instanceof Error ? { name: A.name, message: A.message, stack: A.stack } : A), deserialize: Od, onTimeoutError(L) { throw new Error(`[vitest-ws-client]: Timeout calling "${L}"`) } }; v.rpc = zE(b, x); let T; function E(L = !1) { L && (g = c), v.ws = new h(e), M() } function M() { T = new Promise((L, O) => { let H, z; const A = (z = (H = setTimeout(() => { O(new Error(`Cannot connect to the server in ${f / 1e3} seconds`)) }, f)) == null ? void 0 : H.unref) == null ? void 0 : z.call(H); v.ws.OPEN === v.ws.readyState && L(), v.ws.addEventListener('open', () => { g = c, L(), clearTimeout(A) }) }), v.ws.addEventListener('message', (L) => { y(L.data) }), v.ws.addEventListener('close', () => { g -= 1, o && g > 0 && setTimeout(E, s) }) }M(); function N() { return T } return v } const tL = location.port; const nL = [location.hostname, tL].filter(Boolean).join(':'); const rL = `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${nL}/__vitest_api__`; const Pr = !!window.METADATA_PATH; const Mo = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {}; function Vb(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e } const jb = {}; const oi = {}; const iL = ''; const oL = ''; const sL = ''; const lL = ''; const aL = ''; const cL = ''; const uL = ''; const fL = ''; const dL = ''; const hL = ''; const pL = ''; const gL = ''; const vL = ''; const mL = ''; const yL = ''; const bL = ''; const wL = ''; const xL = ''; const _L = ''; const SL = ''; const kL = ''; const CL = ''; const TL = ''; const EL = ''; const LL = ''; const AL = ''; const ML = '&'; const NL = '&'; const $L = ''; const OL = ''; const PL = ''; const RL = ''; const DL = ''; const zL = ''; const IL = ''; const FL = ''; const HL = ''; const qL = ''; const BL = ''; const WL = ''; const UL = ''; const VL = ''; const jL = ''; const GL = ''; const KL = ''; const XL = ''; const YL = ''; const ZL = ''; const JL = ''; const QL = ''; const eA = ''; const tA = ''; const nA = ''; const rA = ''; const iA = ''; const oA = ''; const sA = ''; const lA = ''; const aA = ''; const cA = ''; const uA = ''; const fA = '\''; const dA = ''; const hA = ''; const pA = ''; const gA = ''; const vA = ''; const mA = ''; const yA = ''; const bA = ''; const wA = '*'; const xA = ''; const _A = ''; const SA = ''; const kA = ''; const CA = ''; const TA = ''; const EA = ''; const LA = ''; const AA = ''; const MA = ''; const NA = ''; const $A = ''; const OA = ''; const PA = ''; const RA = ''; const DA = ''; const zA = ''; const IA = ''; const FA = ''; const HA = ''; const qA = ''; const BA = ''; const WA = ''; const UA = ''; const VA = ''; const jA = ''; const GA = ''; const KA = ''; const XA = ''; const YA = ''; const ZA = ''; const JA = ''; const QA = ''; const eM = ''; const tM = ''; const nM = ''; const rM = ''; const iM = ''; const oM = ''; const sM = ''; const lM = ''; const aM = ''; const cM = ''; const uM = ''; const fM = ''; const dM = ''; const hM = ''; const pM = ''; const gM = ''; const vM = ''; const mM = ''; const yM = ''; const bM = ''; const wM = ''; const xM = ''; const _M = ''; const SM = ''; const kM = ''; const CM = ''; const TM = ''; const EM = ''; const LM = ''; const AM = ''; const MM = '='; const NM = ''; const $M = ''; const OM = ''; const PM = ''; const RM = ''; const DM = ''; const zM = ''; const IM = ''; const FM = ''; const HM = ''; const qM = ''; const BM = ''; const WM = ''; const UM = ''; const VM = ''; const jM = ''; const GM = ''; const KM = ''; const XM = ''; const YM = ''; const ZM = ''; const JM = ''; const QM = ''; const eN = ''; const tN = ''; const nN = ''; const rN = ''; const iN = ''; const oN = ''; const sN = ''; const lN = ''; const aN = ''; const cN = ''; const uN = ''; const fN = ''; const dN = ''; const hN = ''; const pN = ''; const gN = ''; const vN = ''; const mN = ''; const yN = ''; const bN = ''; const wN = ''; const xN = ''; const _N = ''; const SN = ''; const kN = ''; const CN = ''; const TN = ''; const EN = ''; const LN = ''; const AN = ''; const MN = ''; const NN = ''; const $N = ''; const ON = ''; const PN = ''; const RN = ''; const DN = ''; const zN = ''; const IN = ''; const FN = '\\'; const HN = ''; const qN = ''; const BN = ''; const WN = ''; const UN = ''; const VN = ''; const jN = ''; const GN = ''; const KN = ''; const XN = ''; const YN = ''; const ZN = ''; const JN = ''; const QN = ''; const e$ = ''; const t$ = ''; const n$ = ''; const r$ = ''; const i$ = ''; const o$ = ''; const s$ = ''; const l$ = ''; const a$ = ''; const c$ = ''; const u$ = ''; const f$ = ''; const d$ = ''; const h$ = ''; const p$ = ''; const g$ = ''; const v$ = ''; const m$ = ''; const y$ = ''; const b$ = ''; const w$ = ''; const x$ = ''; const _$ = ''; const S$ = ''; const k$ = ''; const C$ = ''; const T$ = ''; const E$ = ''; const L$ = ''; const A$ = ''; const M$ = ''; const N$ = ''; const $$ = ''; const O$ = ''; const P$ = ''; const R$ = ''; const D$ = ''; const z$ = ''; const I$ = ''; const F$ = ''; const H$ = ''; const q$ = ''; const B$ = ''; const W$ = ''; const U$ = ''; const V$ = ''; const j$ = ''; const G$ = ''; const K$ = ''; const X$ = ''; const Y$ = ''; const Z$ = ''; const J$ = ''; const Q$ = ''; const eO = ''; const tO = ''; const nO = ''; const rO = ''; const iO = ':'; const oO = ''; const sO = ''; const lO = ''; const aO = ''; const cO = ','; const uO = '@'; const fO = ''; const dO = ''; const hO = ''; const pO = ''; const gO = ''; const vO = ''; const mO = ''; const yO = ''; const bO = ''; const wO = ''; const xO = ''; const _O = ''; const SO = ''; const kO = ''; const CO = ''; const TO = ''; const EO = ''; const LO = ''; const AO = ''; const MO = ''; const NO = ''; const $O = ''; const OO = ''; const PO = ''; const RO = ''; const DO = ''; const zO = ''; const IO = ''; const FO = ''; const HO = ''; const qO = ''; const BO = ''; const WO = ''; const UO = ''; const VO = ''; const jO = ''; const GO = ''; const KO = ''; const XO = ''; const YO = ''; const ZO = ''; const JO = ''; const QO = ''; const eP = ''; const tP = ''; const nP = ''; const rP = ''; const iP = ''; const oP = ''; const sP = ''; const lP = ''; const aP = ''; const cP = ''; const uP = ''; const fP = ''; const dP = ''; const hP = ''; const pP = ''; const gP = ''; const vP = ''; const mP = ''; const yP = ''; const bP = ''; const wP = ''; const xP = ''; const _P = ''; const SP = ''; const kP = ''; const CP = ''; const TP = ''; const EP = ''; const LP = ''; const AP = ''; const MP = ''; const NP = ''; const $P = ''; const OP = ''; const PP = ''; const RP = ''; const DP = ''; const zP = ''; const IP = ''; const FP = ''; const HP = ''; const qP = ''; const BP = ''; const WP = ''; const UP = ''; const VP = ''; const jP = ''; const GP = ''; const KP = ''; const XP = '`'; const YP = ''; const ZP = ''; const JP = ''; const QP = ''; const eR = ''; const tR = ''; const nR = ''; const rR = ''; const iR = ''; const oR = ''; const sR = ''; const lR = ''; const aR = ''; const cR = ''; const uR = ''; const fR = ''; const dR = ''; const hR = ''; const pR = '$'; const gR = ''; const vR = ''; const mR = ''; const yR = ''; const bR = ''; const wR = ''; const xR = ''; const _R = ''; const SR = ''; const kR = ''; const CR = ''; const TR = ''; const ER = ''; const LR = ''; const AR = ''; const MR = ''; const NR = ''; const $R = ''; const OR = ''; const PR = ''; const RR = ''; const DR = ''; const zR = ''; const IR = ''; const FR = ''; const HR = ''; const qR = ''; const BR = ''; const WR = ''; const UR = ''; const VR = ''; const jR = ''; const GR = ''; const KR = ''; const XR = ''; const YR = ''; const ZR = ''; const JR = ''; const QR = ''; const eD = ''; const tD = ''; const nD = ''; const rD = ''; const iD = ''; const oD = ''; const sD = ''; const lD = ''; const aD = ''; const cD = ''; const uD = ''; const fD = ''; const dD = ''; const hD = ''; const pD = ''; const gD = ''; const vD = ''; const mD = ''; const yD = ''; const bD = ''; const wD = ''; const xD = ''; const _D = ''; const SD = ''; const kD = ''; const CD = ''; const TD = ''; const ED = ''; const LD = ''; const AD = ''; const MD = ''; const ND = ''; const $D = ''; const OD = ''; const PD = ''; const RD = ''; const DD = ''; const zD = ''; const ID = ''; const FD = ''; const HD = ''; const qD = ''; const BD = ''; const WD = ''; const UD = ''; const VD = ''; const jD = ''; const GD = ''; const KD = ''; const XD = ''; const YD = ''; const ZD = ''; const JD = ''; const QD = ''; const e2 = ''; const t2 = ''; const n2 = ''; const r2 = ''; const i2 = ''; const o2 = ''; const s2 = ''; const l2 = ''; const a2 = ''; const c2 = ''; const u2 = ''; const f2 = ''; const d2 = ''; const h2 = ''; const p2 = ''; const g2 = ''; const v2 = ''; const m2 = ''; const y2 = ''; const b2 = ''; const w2 = ''; const x2 = ''; const _2 = ''; const S2 = ''; const k2 = ''; const C2 = ''; const T2 = ''; const E2 = ''; const L2 = ''; const A2 = ''; const M2 = '='; const N2 = ''; const $2 = ''; const O2 = ''; const P2 = ''; const R2 = ''; const D2 = ''; const z2 = ''; const I2 = ''; const F2 = ''; const H2 = ''; const q2 = ''; const B2 = ''; const W2 = ''; const U2 = ''; const V2 = ''; const j2 = ''; const G2 = ''; const K2 = ''; const X2 = ''; const Y2 = ''; const Z2 = '!'; const J2 = ''; const Q2 = ''; const ez = ''; const tz = ''; const nz = ''; const rz = ''; const iz = ''; const oz = ''; const sz = ''; const lz = ''; const az = ''; const cz = ''; const uz = ''; const fz = ''; const dz = ''; const hz = ''; const pz = ''; const gz = 'fj'; const vz = ''; const mz = ''; const yz = ''; const bz = ''; const wz = ''; const xz = ''; const _z = ''; const Sz = ''; const kz = ''; const Cz = ''; const Tz = ''; const Ez = ''; const Lz = ''; const Az = ''; const Mz = ''; const Nz = ''; const $z = ''; const Oz = ''; const Pz = ''; const Rz = ''; const Dz = ''; const zz = ''; const Iz = ''; const Fz = ''; const Hz = ''; const qz = ''; const Bz = ''; const Wz = ''; const Uz = ''; const Vz = ''; const jz = ''; const Gz = ''; const Kz = ''; const Xz = ''; const Yz = ''; const Zz = ''; const Jz = ''; const Qz = ''; const eI = ''; const tI = ''; const nI = ''; const rI = ''; const iI = ''; const oI = ''; const sI = ''; const lI = ''; const aI = ''; const cI = ''; const uI = ''; const fI = ''; const dI = ''; const hI = ''; const pI = ''; const gI = ''; const vI = ''; const mI = ''; const yI = ''; const bI = ''; const wI = ''; const xI = ''; const _I = ''; const SI = ''; const kI = ''; const CI = ''; const TI = ''; const EI = ''; const LI = ''; const AI = ''; const MI = ''; const NI = ''; const $I = ''; const OI = ''; const PI = ''; const RI = ''; const DI = ''; const zI = ''; const II = ''; const FI = ''; const HI = ''; const qI = ''; const BI = ''; const WI = '`'; const UI = ''; const VI = ''; const jI = ''; const GI = ''; const KI = ''; const XI = ''; const YI = ''; const ZI = ''; const JI = ''; const QI = ''; const eF = ''; const tF = ''; const nF = ''; const rF = ''; const iF = '>'; const oF = '>'; const sF = ''; const lF = ''; const aF = ''; const cF = ''; const uF = ''; const fF = ''; const dF = ''; const hF = ''; const pF = ''; const gF = ''; const vF = ''; const mF = ''; const yF = ''; const bF = ''; const wF = ''; const xF = ''; const _F = ''; const SF = ''; const kF = ''; const CF = ''; const TF = ''; const EF = ''; const LF = ''; const AF = '^'; const MF = ''; const NF = ''; const $F = ''; const OF = ''; const PF = ''; const RF = ''; const DF = ''; const zF = ''; const IF = ''; const FF = ''; const HF = ''; const qF = ''; const BF = ''; const WF = ''; const UF = ''; const VF = ''; const jF = ''; const GF = ''; const KF = ''; const XF = ''; const YF = ''; const ZF = ''; const JF = ''; const QF = ''; const eH = ''; const tH = ''; const nH = ''; const rH = ''; const iH = ''; const oH = ''; const sH = ''; const lH = ''; const aH = ''; const cH = ''; const uH = ''; const fH = ''; const dH = ''; const hH = ''; const pH = ''; const gH = ''; const vH = ''; const mH = ''; const yH = ''; const bH = ''; const wH = ''; const xH = ''; const _H = ''; const SH = ''; const kH = ''; const CH = ''; const TH = ''; const EH = ''; const LH = ''; const AH = ''; const MH = ''; const NH = ''; const $H = ''; const OH = ''; const PH = ''; const RH = ''; const DH = ''; const zH = ''; const IH = ''; const FH = ''; const HH = ''; const qH = ''; const BH = ''; const WH = ''; const UH = ''; const VH = ''; const jH = ''; const GH = ''; const KH = ''; const XH = ''; const YH = ''; const ZH = ''; const JH = ''; const QH = ''; const eq = ''; const tq = ''; const nq = ''; const rq = ''; const iq = ''; const oq = ''; const sq = ''; const lq = ''; const aq = ''; const cq = ''; const uq = ''; const fq = ''; const dq = ''; const hq = ''; const pq = ''; const gq = ''; const vq = ''; const mq = ''; const yq = ''; const bq = ''; const wq = ''; const xq = ''; const _q = ''; const Sq = ''; const kq = ''; const Cq = ''; const Tq = ''; const Eq = ''; const Lq = ''; const Aq = ''; const Mq = ''; const Nq = ''; const $q = ''; const Oq = ''; const Pq = ''; const Rq = ''; const Dq = ''; const zq = ''; const Iq = ''; const Fq = ''; const Hq = ''; const qq = ''; const Bq = ''; const Wq = ''; const Uq = ''; const Vq = ''; const jq = ''; const Gq = ''; const Kq = ''; const Xq = ''; const Yq = ''; const Zq = ''; const Jq = ''; const Qq = ''; const eB = ''; const tB = ''; const nB = ''; const rB = ''; const iB = ''; const oB = ''; const sB = ''; const lB = ''; const aB = ''; const cB = ''; const uB = ''; const fB = ''; const dB = ''; const hB = ''; const pB = ''; const gB = ''; const vB = ''; const mB = ''; const yB = ''; const bB = ''; const wB = ''; const xB = ''; const _B = ''; const SB = ''; const kB = ''; const CB = ''; const TB = ''; const EB = ''; const LB = ''; const AB = ''; const MB = ''; const NB = ''; const $B = ''; const OB = ''; const PB = ''; const RB = ''; const DB = ''; const zB = '{'; const IB = '['; const FB = ''; const HB = ''; const qB = ''; const BB = ''; const WB = ''; const UB = ''; const VB = ''; const jB = ''; const GB = '{'; const KB = ''; const XB = ''; const YB = ''; const ZB = ''; const JB = ''; const QB = ''; const e3 = ''; const t3 = ''; const n3 = ''; const r3 = ''; const i3 = ''; const o3 = ''; const s3 = ''; const l3 = ''; const a3 = ''; const c3 = ''; const u3 = ''; const f3 = ''; const d3 = ''; const h3 = ''; const p3 = ''; const g3 = ''; const v3 = ''; const m3 = ''; const y3 = ''; const b3 = ''; const w3 = ''; const x3 = ''; const _3 = ''; const S3 = ''; const k3 = ''; const C3 = ''; const T3 = ''; const E3 = ''; const L3 = ''; const A3 = ''; const M3 = ''; const N3 = ''; const $3 = ''; const O3 = ''; const P3 = ''; const R3 = ''; const D3 = ''; const z3 = ''; const I3 = ''; const F3 = ''; const H3 = ''; const q3 = ''; const B3 = ''; const W3 = ''; const U3 = ''; const V3 = ''; const j3 = ''; const G3 = ''; const K3 = ''; const X3 = ''; const Y3 = ''; const Z3 = ''; const J3 = ''; const Q3 = ''; const e5 = ''; const t5 = ''; const n5 = ''; const r5 = ''; const i5 = ''; const o5 = ''; const s5 = ''; const l5 = ''; const a5 = ''; const c5 = ''; const u5 = ''; const f5 = ''; const d5 = ''; const h5 = ''; const p5 = ''; const g5 = ''; const v5 = ''; const m5 = ''; const y5 = ''; const b5 = ''; const w5 = ''; const x5 = ''; const _5 = ''; const S5 = ''; const k5 = ''; const C5 = ''; const T5 = ''; const E5 = ''; const L5 = ''; const A5 = ''; const M5 = ''; const N5 = ''; const $5 = ''; const O5 = ''; const P5 = ''; const R5 = ''; const D5 = ''; const z5 = ''; const I5 = ''; const F5 = ''; const H5 = ''; const q5 = ''; const B5 = ''; const W5 = ''; const U5 = ''; const V5 = ''; const j5 = ''; const G5 = ''; const K5 = ''; const X5 = ''; const Y5 = ''; const Z5 = ''; const J5 = ''; const Q5 = ''; const e8 = ''; const t8 = ''; const n8 = ''; const r8 = ''; const i8 = ''; const o8 = ''; const s8 = ''; const l8 = ''; const a8 = '_'; const c8 = ''; const u8 = ''; const f8 = ''; const d8 = ''; const h8 = ''; const p8 = '('; const g8 = ''; const v8 = ''; const m8 = ''; const y8 = ''; const b8 = ''; const w8 = ''; const x8 = ''; const _8 = ''; const S8 = ''; const k8 = ''; const C8 = ''; const T8 = ''; const E8 = ''; const L8 = ''; const A8 = ''; const M8 = '['; const N8 = ''; const $8 = ''; const O8 = ''; const P8 = ''; const R8 = ''; const D8 = ''; const z8 = '<'; const I8 = '<'; const F8 = ''; const H8 = ''; const q8 = ''; const B8 = ''; const W8 = ''; const U8 = ''; const V8 = ''; const j8 = ''; const G8 = ''; const K8 = ''; const X8 = ''; const Y8 = ''; const Z8 = ''; const J8 = ''; const Q8 = ''; const eW = ''; const tW = ''; const nW = ''; const rW = ''; const iW = ''; const oW = ''; const sW = ''; const lW = ''; const aW = ''; const cW = ''; const uW = ''; const fW = ''; const dW = ''; const hW = ''; const pW = ''; const gW = ''; const vW = ''; const mW = ''; const yW = ''; const bW = ''; const wW = ''; const xW = '*'; const _W = ''; const SW = ''; const kW = ''; const CW = ''; const TW = ''; const EW = ''; const LW = ''; const AW = ''; const MW = ''; const NW = ''; const $W = ''; const OW = ''; const PW = ''; const RW = ''; const DW = ''; const zW = ''; const IW = ''; const FW = ''; const HW = ''; const qW = ''; const BW = ''; const WW = ''; const UW = ''; const VW = ''; const jW = ''; const GW = ''; const KW = ''; const XW = ''; const YW = ''; const ZW = ''; const JW = ''; const QW = ''; const e4 = ''; const t4 = ''; const n4 = ''; const r4 = ''; const i4 = ''; const o4 = ''; const s4 = ''; const l4 = ''; const a4 = ''; const c4 = ''; const u4 = ''; const f4 = ''; const d4 = ''; const h4 = ''; const p4 = ''; const g4 = ''; const v4 = ''; const m4 = ''; const y4 = ''; const b4 = ''; const w4 = ''; const x4 = ''; const _4 = ''; const S4 = ''; const k4 = ''; const C4 = ''; const T4 = ''; const E4 = ''; const L4 = ''; const A4 = ''; const M4 = ''; const N4 = `
`; const $4 = ''; const O4 = ''; const P4 = ''; const R4 = ''; const D4 = ''; const z4 = ''; const I4 = ''; const F4 = ''; const H4 = ''; const q4 = ''; const B4 = ''; const W4 = ''; const U4 = ''; const V4 = ''; const j4 = ''; const G4 = ''; const K4 = ''; const X4 = ''; const Y4 = ''; const Z4 = ''; const J4 = ''; const Q4 = ''; const eU = ''; const tU = ''; const nU = ''; const rU = ''; const iU = ''; const oU = ''; const sU = ''; const lU = ''; const aU = ''; const cU = ''; const uU = ''; const fU = ''; const dU = ''; const hU = ''; const pU = ''; const gU = ''; const vU = ''; const mU = ''; const yU = ''; const bU = ''; const wU = ''; const xU = ''; const _U = ''; const SU = ''; const kU = ''; const CU = ''; const TU = ''; const EU = ''; const LU = ''; const AU = ''; const MU = ''; const NU = ''; const $U = ''; const OU = ''; const PU = ''; const RU = ''; const DU = ''; const zU = ''; const IU = ''; const FU = ''; const HU = ''; const qU = ''; const BU = ''; const WU = ''; const UU = ''; const VU = ''; const jU = ''; const GU = ''; const KU = ''; const XU = ''; const YU = ''; const ZU = ''; const JU = ''; const QU = ''; const e6 = ''; const t6 = ''; const n6 = ''; const r6 = ''; const i6 = ''; const o6 = ''; const s6 = ''; const l6 = ''; const a6 = ''; const c6 = ''; const u6 = ''; const f6 = ''; const d6 = ''; const h6 = ''; const p6 = ''; const g6 = ''; const v6 = ''; const m6 = ''; const y6 = ''; const b6 = ''; const w6 = ''; const x6 = ''; const _6 = ''; const S6 = ''; const k6 = ''; const C6 = ''; const T6 = ''; const E6 = ''; const L6 = ''; const A6 = ''; const M6 = ''; const N6 = ''; const $6 = ''; const O6 = ''; const P6 = ''; const R6 = ''; const D6 = ''; const z6 = ''; const I6 = ''; const F6 = ''; const H6 = ''; const q6 = ''; const B6 = ''; const W6 = ''; const U6 = ''; const V6 = ''; const j6 = ''; const G6 = ''; const K6 = ''; const X6 = ''; const Y6 = ''; const Z6 = ''; const J6 = ''; const Q6 = ''; const eV = ''; const tV = ''; const nV = ''; const rV = ''; const iV = ''; const oV = ''; const sV = ''; const lV = ''; const aV = ''; const cV = ''; const uV = ''; const fV = ''; const dV = ''; const hV = ''; const pV = ''; const gV = ''; const vV = ''; const mV = ''; const yV = ''; const bV = ''; const wV = ''; const xV = ''; const _V = ''; const SV = ''; const kV = ''; const CV = ''; const TV = ''; const EV = ''; const LV = ''; const AV = ''; const MV = ''; const NV = ''; const $V = ''; const OV = ''; const PV = ''; const RV = ''; const DV = ''; const zV = ''; const IV = ''; const FV = ''; const HV = '#'; const qV = ''; const BV = ''; const WV = ''; const UV = ''; const VV = ''; const jV = ''; const GV = ''; const KV = ''; const XV = '>'; const YV = ''; const ZV = ''; const JV = ''; const QV = ''; const ej = '<'; const tj = ''; const nj = ''; const rj = ''; const ij = ''; const oj = ''; const sj = ''; const lj = ''; const aj = ''; const cj = ''; const uj = ''; const fj = ''; const dj = ''; const hj = ''; const pj = ''; const gj = ''; const vj = ''; const mj = ''; const yj = ''; const bj = ''; const wj = ''; const xj = ''; const _j = ''; const Sj = ''; const kj = ''; const Cj = ''; const Tj = ''; const Ej = ''; const Lj = ''; const Aj = ''; const Mj = ''; const Nj = ''; const $j = ''; const Oj = ''; const Pj = ''; const Rj = ''; const Dj = ''; const zj = ''; const Ij = ''; const Fj = ''; const Hj = ''; const qj = ''; const Bj = ''; const Wj = ''; const Uj = ''; const Vj = ''; const jj = ''; const Gj = ''; const Kj = ''; const Xj = ''; const Yj = ''; const Zj = ''; const Jj = ''; const Qj = ''; const eG = ''; const tG = ''; const nG = ''; const rG = ''; const iG = ''; const oG = ''; const sG = ''; const lG = ''; const aG = ''; const cG = ''; const uG = ''; const fG = ''; const dG = ''; const hG = ''; const pG = ''; const gG = ''; const vG = ''; const mG = ''; const yG = ''; const bG = ''; const wG = ''; const xG = ''; const _G = ''; const SG = ''; const kG = ''; const CG = ''; const TG = ''; const EG = ''; const LG = ''; const AG = ''; const MG = ''; const NG = ''; const $G = ''; const OG = ''; const PG = ''; const RG = ''; const DG = ''; const zG = ''; const IG = ''; const FG = ''; const HG = ''; const qG = '%'; const BG = '.'; const WG = ''; const UG = ''; const VG = ''; const jG = ''; const GG = ''; const KG = ''; const XG = ''; const YG = ''; const ZG = ''; const JG = ''; const QG = ''; const e9 = ''; const t9 = ''; const n9 = ''; const r9 = ''; const i9 = ''; const o9 = ''; const s9 = ''; const l9 = ''; const a9 = ''; const c9 = '+'; const u9 = ''; const f9 = ''; const d9 = ''; const h9 = ''; const p9 = ''; const g9 = ''; const v9 = ''; const m9 = ''; const y9 = ''; const b9 = ''; const w9 = ''; const x9 = ''; const _9 = ''; const S9 = ''; const k9 = ''; const C9 = ''; const T9 = ''; const E9 = ''; const L9 = ''; const A9 = ''; const M9 = ''; const N9 = ''; const $9 = ''; const O9 = ''; const P9 = ''; const R9 = ''; const D9 = ''; const z9 = ''; const I9 = ''; const F9 = ''; const H9 = ''; const q9 = ''; const B9 = ''; const W9 = ''; const U9 = ''; const V9 = ''; const j9 = ''; const G9 = ''; const K9 = ''; const X9 = ''; const Y9 = ''; const Z9 = ''; const J9 = ''; const Q9 = ''; const e7 = ''; const t7 = ''; const n7 = ''; const r7 = ''; const i7 = ''; const o7 = ''; const s7 = ''; const l7 = ''; const a7 = ''; const c7 = ''; const u7 = ''; const f7 = ''; const d7 = ''; const h7 = ''; const p7 = ''; const g7 = ''; const v7 = ''; const m7 = ''; const y7 = ''; const b7 = '?'; const w7 = ''; const x7 = '"'; const _7 = '"'; const S7 = ''; const k7 = ''; const C7 = ''; const T7 = ''; const E7 = ''; const L7 = ''; const A7 = ''; const M7 = ''; const N7 = ''; const $7 = ''; const O7 = ''; const P7 = ''; const R7 = ''; const D7 = ''; const z7 = ''; const I7 = ''; const F7 = ''; const H7 = ''; const q7 = ''; const B7 = ''; const W7 = ''; const U7 = ''; const V7 = ''; const j7 = ''; const G7 = ''; const K7 = ''; const X7 = ''; const Y7 = ''; const Z7 = ''; const J7 = ''; const Q7 = ''; const eK = ''; const tK = ''; const nK = ''; const rK = ''; const iK = '}'; const oK = ']'; const sK = ''; const lK = ''; const aK = ''; const cK = ''; const uK = ''; const fK = ''; const dK = ''; const hK = ''; const pK = '}'; const gK = ''; const vK = ''; const mK = ''; const yK = ''; const bK = ''; const wK = ''; const xK = ''; const _K = ''; const SK = ''; const kK = ''; const CK = ''; const TK = ''; const EK = ''; const LK = ''; const AK = ''; const MK = ''; const NK = ''; const $K = ''; const OK = ''; const PK = ''; const RK = ''; const DK = ''; const zK = ''; const IK = ''; const FK = ''; const HK = ''; const qK = ''; const BK = ''; const WK = ''; const UK = ''; const VK = ''; const jK = ''; const GK = ''; const KK = ''; const XK = ''; const YK = ''; const ZK = ''; const JK = ''; const QK = ''; const eX = ''; const tX = ''; const nX = ''; const rX = ''; const iX = ''; const oX = ''; const sX = ''; const lX = ''; const aX = ''; const cX = ''; const uX = ''; const fX = ''; const dX = ''; const hX = ''; const pX = ''; const gX = ''; const vX = ''; const mX = ''; const yX = ''; const bX = ''; const wX = ''; const xX = ''; const _X = ''; const SX = ''; const kX = ''; const CX = ''; const TX = ''; const EX = ''; const LX = ''; const AX = ''; const MX = ''; const NX = ''; const $X = ''; const OX = ''; const PX = ''; const RX = ''; const DX = ''; const zX = ''; const IX = ''; const FX = ')'; const HX = ''; const qX = ''; const BX = ''; const WX = ''; const UX = ''; const VX = ''; const jX = ''; const GX = ''; const KX = ''; const XX = ']'; const YX = ''; const ZX = ''; const JX = ''; const QX = ''; const eY = ''; const tY = ''; const nY = ''; const rY = ''; const iY = ''; const oY = ''; const sY = ''; const lY = ''; const aY = ''; const cY = ''; const uY = ''; const fY = ''; const dY = ''; const hY = ''; const pY = ''; const gY = ''; const vY = ''; const mY = ''; const yY = ''; const bY = ''; const wY = ''; const xY = ''; const _Y = ''; const SY = ''; const kY = ''; const CY = ''; const TY = ''; const EY = ''; const LY = ''; const AY = ''; const MY = ''; const NY = ''; const $Y = ''; const OY = ''; const PY = ''; const RY = ''; const DY = ''; const zY = ';'; const IY = ''; const FY = ''; const HY = ''; const qY = ''; const BY = ''; const WY = ''; const UY = ''; const VY = ''; const jY = ''; const GY = ''; const KY = ''; const XY = ''; const YY = ''; const ZY = ''; const JY = ''; const QY = ''; const eZ = ''; const tZ = ''; const nZ = ''; const rZ = ''; const iZ = ''; const oZ = ''; const sZ = ''; const lZ = ''; const aZ = ''; const cZ = ''; const uZ = ''; const fZ = ''; const dZ = ''; const hZ = ''; const pZ = ''; const gZ = ''; const vZ = ''; const mZ = ''; const yZ = ''; const bZ = ''; const wZ = ''; const xZ = ''; const _Z = ''; const SZ = ''; const kZ = ''; const CZ = ''; const TZ = ''; const EZ = ''; const LZ = ''; const AZ = ''; const MZ = ''; const NZ = ''; const $Z = '/'; const OZ = ''; const PZ = ''; const RZ = ''; const DZ = ''; const zZ = ''; const IZ = ''; const FZ = ''; const HZ = ''; const qZ = ''; const BZ = ''; const WZ = ''; const UZ = ''; const VZ = ''; const jZ = ''; const GZ = ''; const KZ = ''; const XZ = ''; const YZ = ''; const ZZ = ''; const JZ = ''; const QZ = ''; const eJ = ''; const tJ = ''; const nJ = ''; const rJ = ''; const iJ = ''; const oJ = ''; const sJ = ''; const lJ = ''; const aJ = ''; const cJ = ''; const uJ = ''; const fJ = ''; const dJ = ''; const hJ = ''; const pJ = ''; const gJ = ''; const vJ = ''; const mJ = ''; const yJ = ''; const bJ = ''; const wJ = ''; const xJ = ''; const _J = ''; const SJ = ''; const kJ = ''; const CJ = ''; const TJ = ''; const EJ = ''; const LJ = ''; const AJ = ''; const MJ = ''; const NJ = ''; const $J = ''; const OJ = ''; const PJ = ''; const RJ = ''; const DJ = ''; const zJ = ''; const IJ = ''; const FJ = ''; const HJ = ''; const qJ = ''; const BJ = ''; const WJ = ''; const UJ = ''; const VJ = ''; const jJ = ''; const GJ = ''; const KJ = ''; const XJ = ''; const YJ = ''; const ZJ = ''; const JJ = ''; const QJ = ''; const eQ = ''; const tQ = ''; const nQ = ''; const rQ = ''; const iQ = ''; const oQ = ''; const sQ = ''; const lQ = ''; const aQ = ''; const cQ = ''; const uQ = ''; const fQ = ''; const dQ = ''; const hQ = ''; const pQ = ''; const gQ = ''; const vQ = ''; const mQ = ''; const yQ = ''; const bQ = ''; const wQ = ''; const xQ = ''; const _Q = ''; const SQ = ''; const kQ = ''; const CQ = ''; const TQ = ''; const EQ = ''; const LQ = ''; const AQ = ''; const MQ = ''; const NQ = ''; const $Q = ''; const OQ = ''; const PQ = ''; const RQ = ''; const DQ = ''; const zQ = '	'; const IQ = ''; const FQ = ''; const HQ = ''; const qQ = ''; const BQ = ''; const WQ = ''; const UQ = ''; const VQ = ''; const jQ = ''; const GQ = ''; const KQ = ''; const XQ = ''; const YQ = ''; const ZQ = ''; const JQ = ''; const QQ = ''; const eee = ''; const tee = ''; const nee = ''; const ree = ''; const iee = ''; const oee = ''; const see = ''; const lee = ''; const aee = ''; const cee = ''; const uee = ''; const fee = ''; const dee = ''; const hee = ''; const pee = ''; const gee = ''; const vee = ''; const mee = ''; const yee = ''; const bee = ''; const wee = ''; const xee = ''; const _ee = ''; const See = ''; const kee = ''; const Cee = ''; const Tee = ''; const Eee = ''; const Lee = ''; const Aee = ''; const Mee = ''; const Nee = ''; const $ee = ''; const Oee = ''; const Pee = ''; const Ree = ''; const Dee = ''; const zee = ''; const Iee = ''; const Fee = ''; const Hee = ''; const qee = ''; const Bee = ''; const Wee = ''; const Uee = ''; const Vee = ''; const jee = ''; const Gee = ''; const Kee = ''; const Xee = ''; const Yee = ''; const Zee = ''; const Jee = ''; const Qee = ''; const ete = ''; const tte = ''; const nte = ''; const rte = ''; const ite = ''; const ote = ''; const ste = ''; const lte = ''; const ate = ''; const cte = ''; const ute = ''; const fte = ''; const dte = ''; const hte = ''; const pte = ''; const gte = ''; const vte = ''; const mte = ''; const yte = ''; const bte = ''; const wte = ''; const xte = ''; const _te = ''; const Ste = ''; const kte = ''; const Cte = ''; const Tte = ''; const Ete = ''; const Lte = ''; const Ate = ''; const Mte = ''; const Nte = ''; const $te = ''; const Ote = ''; const Pte = ''; const Rte = ''; const Dte = ''; const zte = ''; const Ite = ''; const Fte = ''; const Hte = ''; const qte = '_'; const Bte = ''; const Wte = ''; const Ute = ''; const Vte = ''; const jte = ''; const Gte = ''; const Kte = ''; const Xte = ''; const Yte = ''; const Zte = ''; const Jte = ''; const Qte = ''; const ene = ''; const tne = ''; const nne = ''; const rne = ''; const ine = ''; const one = ''; const sne = ''; const lne = ''; const ane = ''; const cne = ''; const une = ''; const fne = ''; const dne = ''; const hne = ''; const pne = ''; const gne = ''; const vne = ''; const mne = ''; const yne = ''; const bne = ''; const wne = ''; const xne = ''; const _ne = ''; const Sne = ''; const kne = ''; const Cne = ''; const Tne = ''; const Ene = ''; const Lne = ''; const Ane = ''; const Mne = ''; const Nne = ''; const $ne = ''; const One = ''; const Pne = ''; const Rne = ''; const Dne = ''; const zne = ''; const Ine = ''; const Fne = ''; const Hne = ''; const qne = ''; const Bne = ''; const Wne = ''; const Une = ''; const Vne = ''; const jne = ''; const Gne = ''; const Kne = ''; const Xne = ''; const Yne = ''; const Zne = ''; const Jne = ''; const Qne = ''; const ere = ''; const tre = ''; const nre = ''; const rre = ''; const ire = ''; const ore = ''; const sre = ''; const lre = ''; const are = ''; const cre = ''; const ure = ''; const fre = ''; const dre = ''; const hre = ''; const pre = ''; const gre = '|'; const vre = ''; const mre = '|'; const yre = ''; const bre = ''; const wre = '|'; const xre = ''; const _re = ''; const Sre = ''; const kre = ''; const Cre = ''; const Tre = ''; const Ere = ''; const Lre = ''; const Are = ''; const Mre = ''; const Nre = ''; const $re = ''; const Ore = ''; const Pre = ''; const Rre = ''; const Dre = ''; const zre = ''; const Ire = ''; const Fre = ''; const Hre = ''; const qre = ''; const Bre = ''; const Wre = ''; const Ure = ''; const Vre = ''; const jre = ''; const Gre = ''; const Kre = ''; const Xre = ''; const Yre = ''; const Zre = ''; const Jre = ''; const Qre = ''; const eie = ''; const tie = ''; const nie = ''; const rie = ''; const iie = ''; const oie = ''; const sie = ''; const lie = ''; const aie = ''; const cie = ''; const uie = ''; const fie = ''; const die = ''; const hie = ''; const pie = ''; const gie = ''; const vie = ''; const mie = ''; const yie = ''; const bie = ''; const wie = ''; const xie = ''; const _ie = ''; const Sie = ''; const kie = ''; const Cie = ''; const Tie = ''; const Eie = ''; const Lie = ''; const Aie = ''; const Mie = ''; const Nie = ''; const $ie = ''; const Oie = ''; const Pie = ''; const Rie = ''; const Die = ''; const zie = ''; const Iie = ''; const Fie = ''; const Hie = ''; const qie = ''; const Bie = ''; const Wie = ''; const Uie = ''; const Vie = ''; const jie = ''; const Gie = ''; const Kie = ''; const Xie = ''; const Yie = ''; const Zie = ''; const Jie = ''; const Qie = ''; const eoe = ''; const toe = ''; const noe = ''; const roe = ''; const ioe = ''; const ooe = ''; const soe = ''; const loe = ''; const aoe = ''; const coe = ''; const uoe = ''; const foe = ''; const doe = ''; const hoe = ''; const poe = ''; const goe = ''; const voe = ''; const moe = ''; const yoe = ''; const boe = ''; const woe = ''; const Gb = { Aacute: iL, aacute: oL, Abreve: sL, abreve: lL, ac: aL, acd: cL, acE: uL, Acirc: fL, acirc: dL, acute: hL, Acy: pL, acy: gL, AElig: vL, aelig: mL, af: yL, Afr: bL, afr: wL, Agrave: xL, agrave: _L, alefsym: SL, aleph: kL, Alpha: CL, alpha: TL, Amacr: EL, amacr: LL, amalg: AL, amp: ML, AMP: NL, andand: $L, And: OL, and: PL, andd: RL, andslope: DL, andv: zL, ang: IL, ange: FL, angle: HL, angmsdaa: qL, angmsdab: BL, angmsdac: WL, angmsdad: UL, angmsdae: VL, angmsdaf: jL, angmsdag: GL, angmsdah: KL, angmsd: XL, angrt: YL, angrtvb: ZL, angrtvbd: JL, angsph: QL, angst: eA, angzarr: tA, Aogon: nA, aogon: rA, Aopf: iA, aopf: oA, apacir: sA, ap: lA, apE: aA, ape: cA, apid: uA, apos: fA, ApplyFunction: dA, approx: hA, approxeq: pA, Aring: gA, aring: vA, Ascr: mA, ascr: yA, Assign: bA, ast: wA, asymp: xA, asympeq: _A, Atilde: SA, atilde: kA, Auml: CA, auml: TA, awconint: EA, awint: LA, backcong: AA, backepsilon: MA, backprime: NA, backsim: $A, backsimeq: OA, Backslash: PA, Barv: RA, barvee: DA, barwed: zA, Barwed: IA, barwedge: FA, bbrk: HA, bbrktbrk: qA, bcong: BA, Bcy: WA, bcy: UA, bdquo: VA, becaus: jA, because: GA, Because: KA, bemptyv: XA, bepsi: YA, bernou: ZA, Bernoullis: JA, Beta: QA, beta: eM, beth: tM, between: nM, Bfr: rM, bfr: iM, bigcap: oM, bigcirc: sM, bigcup: lM, bigodot: aM, bigoplus: cM, bigotimes: uM, bigsqcup: fM, bigstar: dM, bigtriangledown: hM, bigtriangleup: pM, biguplus: gM, bigvee: vM, bigwedge: mM, bkarow: yM, blacklozenge: bM, blacksquare: wM, blacktriangle: xM, blacktriangledown: _M, blacktriangleleft: SM, blacktriangleright: kM, blank: CM, blk12: TM, blk14: EM, blk34: LM, block: AM, bne: MM, bnequiv: NM, bNot: $M, bnot: OM, Bopf: PM, bopf: RM, bot: DM, bottom: zM, bowtie: IM, boxbox: FM, boxdl: HM, boxdL: qM, boxDl: BM, boxDL: WM, boxdr: UM, boxdR: VM, boxDr: jM, boxDR: GM, boxh: KM, boxH: XM, boxhd: YM, boxHd: ZM, boxhD: JM, boxHD: QM, boxhu: eN, boxHu: tN, boxhU: nN, boxHU: rN, boxminus: iN, boxplus: oN, boxtimes: sN, boxul: lN, boxuL: aN, boxUl: cN, boxUL: uN, boxur: fN, boxuR: dN, boxUr: hN, boxUR: pN, boxv: gN, boxV: vN, boxvh: mN, boxvH: yN, boxVh: bN, boxVH: wN, boxvl: xN, boxvL: _N, boxVl: SN, boxVL: kN, boxvr: CN, boxvR: TN, boxVr: EN, boxVR: LN, bprime: AN, breve: MN, Breve: NN, brvbar: $N, bscr: ON, Bscr: PN, bsemi: RN, bsim: DN, bsime: zN, bsolb: IN, bsol: FN, bsolhsub: HN, bull: qN, bullet: BN, bump: WN, bumpE: UN, bumpe: VN, Bumpeq: jN, bumpeq: GN, Cacute: KN, cacute: XN, capand: YN, capbrcup: ZN, capcap: JN, cap: QN, Cap: e$, capcup: t$, capdot: n$, CapitalDifferentialD: r$, caps: i$, caret: o$, caron: s$, Cayleys: l$, ccaps: a$, Ccaron: c$, ccaron: u$, Ccedil: f$, ccedil: d$, Ccirc: h$, ccirc: p$, Cconint: g$, ccups: v$, ccupssm: m$, Cdot: y$, cdot: b$, cedil: w$, Cedilla: x$, cemptyv: _$, cent: S$, centerdot: k$, CenterDot: C$, cfr: T$, Cfr: E$, CHcy: L$, chcy: A$, check: M$, checkmark: N$, Chi: $$, chi: O$, circ: P$, circeq: R$, circlearrowleft: D$, circlearrowright: z$, circledast: I$, circledcirc: F$, circleddash: H$, CircleDot: q$, circledR: B$, circledS: W$, CircleMinus: U$, CirclePlus: V$, CircleTimes: j$, cir: G$, cirE: K$, cire: X$, cirfnint: Y$, cirmid: Z$, cirscir: J$, ClockwiseContourIntegral: Q$, CloseCurlyDoubleQuote: eO, CloseCurlyQuote: tO, clubs: nO, clubsuit: rO, colon: iO, Colon: oO, Colone: sO, colone: lO, coloneq: aO, comma: cO, commat: uO, comp: fO, compfn: dO, complement: hO, complexes: pO, cong: gO, congdot: vO, Congruent: mO, conint: yO, Conint: bO, ContourIntegral: wO, copf: xO, Copf: _O, coprod: SO, Coproduct: kO, copy: CO, COPY: TO, copysr: EO, CounterClockwiseContourIntegral: LO, crarr: AO, cross: MO, Cross: NO, Cscr: $O, cscr: OO, csub: PO, csube: RO, csup: DO, csupe: zO, ctdot: IO, cudarrl: FO, cudarrr: HO, cuepr: qO, cuesc: BO, cularr: WO, cularrp: UO, cupbrcap: VO, cupcap: jO, CupCap: GO, cup: KO, Cup: XO, cupcup: YO, cupdot: ZO, cupor: JO, cups: QO, curarr: eP, curarrm: tP, curlyeqprec: nP, curlyeqsucc: rP, curlyvee: iP, curlywedge: oP, curren: sP, curvearrowleft: lP, curvearrowright: aP, cuvee: cP, cuwed: uP, cwconint: fP, cwint: dP, cylcty: hP, dagger: pP, Dagger: gP, daleth: vP, darr: mP, Darr: yP, dArr: bP, dash: wP, Dashv: xP, dashv: _P, dbkarow: SP, dblac: kP, Dcaron: CP, dcaron: TP, Dcy: EP, dcy: LP, ddagger: AP, ddarr: MP, DD: NP, dd: $P, DDotrahd: OP, ddotseq: PP, deg: RP, Del: DP, Delta: zP, delta: IP, demptyv: FP, dfisht: HP, Dfr: qP, dfr: BP, dHar: WP, dharl: UP, dharr: VP, DiacriticalAcute: jP, DiacriticalDot: GP, DiacriticalDoubleAcute: KP, DiacriticalGrave: XP, DiacriticalTilde: YP, diam: ZP, diamond: JP, Diamond: QP, diamondsuit: eR, diams: tR, die: nR, DifferentialD: rR, digamma: iR, disin: oR, div: sR, divide: lR, divideontimes: aR, divonx: cR, DJcy: uR, djcy: fR, dlcorn: dR, dlcrop: hR, dollar: pR, Dopf: gR, dopf: vR, Dot: mR, dot: yR, DotDot: bR, doteq: wR, doteqdot: xR, DotEqual: _R, dotminus: SR, dotplus: kR, dotsquare: CR, doublebarwedge: TR, DoubleContourIntegral: ER, DoubleDot: LR, DoubleDownArrow: AR, DoubleLeftArrow: MR, DoubleLeftRightArrow: NR, DoubleLeftTee: $R, DoubleLongLeftArrow: OR, DoubleLongLeftRightArrow: PR, DoubleLongRightArrow: RR, DoubleRightArrow: DR, DoubleRightTee: zR, DoubleUpArrow: IR, DoubleUpDownArrow: FR, DoubleVerticalBar: HR, DownArrowBar: qR, downarrow: BR, DownArrow: WR, Downarrow: UR, DownArrowUpArrow: VR, DownBreve: jR, downdownarrows: GR, downharpoonleft: KR, downharpoonright: XR, DownLeftRightVector: YR, DownLeftTeeVector: ZR, DownLeftVectorBar: JR, DownLeftVector: QR, DownRightTeeVector: eD, DownRightVectorBar: tD, DownRightVector: nD, DownTeeArrow: rD, DownTee: iD, drbkarow: oD, drcorn: sD, drcrop: lD, Dscr: aD, dscr: cD, DScy: uD, dscy: fD, dsol: dD, Dstrok: hD, dstrok: pD, dtdot: gD, dtri: vD, dtrif: mD, duarr: yD, duhar: bD, dwangle: wD, DZcy: xD, dzcy: _D, dzigrarr: SD, Eacute: kD, eacute: CD, easter: TD, Ecaron: ED, ecaron: LD, Ecirc: AD, ecirc: MD, ecir: ND, ecolon: $D, Ecy: OD, ecy: PD, eDDot: RD, Edot: DD, edot: zD, eDot: ID, ee: FD, efDot: HD, Efr: qD, efr: BD, eg: WD, Egrave: UD, egrave: VD, egs: jD, egsdot: GD, el: KD, Element: XD, elinters: YD, ell: ZD, els: JD, elsdot: QD, Emacr: e2, emacr: t2, empty: n2, emptyset: r2, EmptySmallSquare: i2, emptyv: o2, EmptyVerySmallSquare: s2, emsp13: l2, emsp14: a2, emsp: c2, ENG: u2, eng: f2, ensp: d2, Eogon: h2, eogon: p2, Eopf: g2, eopf: v2, epar: m2, eparsl: y2, eplus: b2, epsi: w2, Epsilon: x2, epsilon: _2, epsiv: S2, eqcirc: k2, eqcolon: C2, eqsim: T2, eqslantgtr: E2, eqslantless: L2, Equal: A2, equals: M2, EqualTilde: N2, equest: $2, Equilibrium: O2, equiv: P2, equivDD: R2, eqvparsl: D2, erarr: z2, erDot: I2, escr: F2, Escr: H2, esdot: q2, Esim: B2, esim: W2, Eta: U2, eta: V2, ETH: j2, eth: G2, Euml: K2, euml: X2, euro: Y2, excl: Z2, exist: J2, Exists: Q2, expectation: ez, exponentiale: tz, ExponentialE: nz, fallingdotseq: rz, Fcy: iz, fcy: oz, female: sz, ffilig: lz, fflig: az, ffllig: cz, Ffr: uz, ffr: fz, filig: dz, FilledSmallSquare: hz, FilledVerySmallSquare: pz, fjlig: gz, flat: vz, fllig: mz, fltns: yz, fnof: bz, Fopf: wz, fopf: xz, forall: _z, ForAll: Sz, fork: kz, forkv: Cz, Fouriertrf: Tz, fpartint: Ez, frac12: Lz, frac13: Az, frac14: Mz, frac15: Nz, frac16: $z, frac18: Oz, frac23: Pz, frac25: Rz, frac34: Dz, frac35: zz, frac38: Iz, frac45: Fz, frac56: Hz, frac58: qz, frac78: Bz, frasl: Wz, frown: Uz, fscr: Vz, Fscr: jz, gacute: Gz, Gamma: Kz, gamma: Xz, Gammad: Yz, gammad: Zz, gap: Jz, Gbreve: Qz, gbreve: eI, Gcedil: tI, Gcirc: nI, gcirc: rI, Gcy: iI, gcy: oI, Gdot: sI, gdot: lI, ge: aI, gE: cI, gEl: uI, gel: fI, geq: dI, geqq: hI, geqslant: pI, gescc: gI, ges: vI, gesdot: mI, gesdoto: yI, gesdotol: bI, gesl: wI, gesles: xI, Gfr: _I, gfr: SI, gg: kI, Gg: CI, ggg: TI, gimel: EI, GJcy: LI, gjcy: AI, gla: MI, gl: NI, glE: $I, glj: OI, gnap: PI, gnapprox: RI, gne: DI, gnE: zI, gneq: II, gneqq: FI, gnsim: HI, Gopf: qI, gopf: BI, grave: WI, GreaterEqual: UI, GreaterEqualLess: VI, GreaterFullEqual: jI, GreaterGreater: GI, GreaterLess: KI, GreaterSlantEqual: XI, GreaterTilde: YI, Gscr: ZI, gscr: JI, gsim: QI, gsime: eF, gsiml: tF, gtcc: nF, gtcir: rF, gt: iF, GT: oF, Gt: sF, gtdot: lF, gtlPar: aF, gtquest: cF, gtrapprox: uF, gtrarr: fF, gtrdot: dF, gtreqless: hF, gtreqqless: pF, gtrless: gF, gtrsim: vF, gvertneqq: mF, gvnE: yF, Hacek: bF, hairsp: wF, half: xF, hamilt: _F, HARDcy: SF, hardcy: kF, harrcir: CF, harr: TF, hArr: EF, harrw: LF, Hat: AF, hbar: MF, Hcirc: NF, hcirc: $F, hearts: OF, heartsuit: PF, hellip: RF, hercon: DF, hfr: zF, Hfr: IF, HilbertSpace: FF, hksearow: HF, hkswarow: qF, hoarr: BF, homtht: WF, hookleftarrow: UF, hookrightarrow: VF, hopf: jF, Hopf: GF, horbar: KF, HorizontalLine: XF, hscr: YF, Hscr: ZF, hslash: JF, Hstrok: QF, hstrok: eH, HumpDownHump: tH, HumpEqual: nH, hybull: rH, hyphen: iH, Iacute: oH, iacute: sH, ic: lH, Icirc: aH, icirc: cH, Icy: uH, icy: fH, Idot: dH, IEcy: hH, iecy: pH, iexcl: gH, iff: vH, ifr: mH, Ifr: yH, Igrave: bH, igrave: wH, ii: xH, iiiint: _H, iiint: SH, iinfin: kH, iiota: CH, IJlig: TH, ijlig: EH, Imacr: LH, imacr: AH, image: MH, ImaginaryI: NH, imagline: $H, imagpart: OH, imath: PH, Im: RH, imof: DH, imped: zH, Implies: IH, incare: FH, in: '', infin: HH, infintie: qH, inodot: BH, intcal: WH, int: UH, Int: VH, integers: jH, Integral: GH, intercal: KH, Intersection: XH, intlarhk: YH, intprod: ZH, InvisibleComma: JH, InvisibleTimes: QH, IOcy: eq, iocy: tq, Iogon: nq, iogon: rq, Iopf: iq, iopf: oq, Iota: sq, iota: lq, iprod: aq, iquest: cq, iscr: uq, Iscr: fq, isin: dq, isindot: hq, isinE: pq, isins: gq, isinsv: vq, isinv: mq, it: yq, Itilde: bq, itilde: wq, Iukcy: xq, iukcy: _q, Iuml: Sq, iuml: kq, Jcirc: Cq, jcirc: Tq, Jcy: Eq, jcy: Lq, Jfr: Aq, jfr: Mq, jmath: Nq, Jopf: $q, jopf: Oq, Jscr: Pq, jscr: Rq, Jsercy: Dq, jsercy: zq, Jukcy: Iq, jukcy: Fq, Kappa: Hq, kappa: qq, kappav: Bq, Kcedil: Wq, kcedil: Uq, Kcy: Vq, kcy: jq, Kfr: Gq, kfr: Kq, kgreen: Xq, KHcy: Yq, khcy: Zq, KJcy: Jq, kjcy: Qq, Kopf: eB, kopf: tB, Kscr: nB, kscr: rB, lAarr: iB, Lacute: oB, lacute: sB, laemptyv: lB, lagran: aB, Lambda: cB, lambda: uB, lang: fB, Lang: dB, langd: hB, langle: pB, lap: gB, Laplacetrf: vB, laquo: mB, larrb: yB, larrbfs: bB, larr: wB, Larr: xB, lArr: _B, larrfs: SB, larrhk: kB, larrlp: CB, larrpl: TB, larrsim: EB, larrtl: LB, latail: AB, lAtail: MB, lat: NB, late: $B, lates: OB, lbarr: PB, lBarr: RB, lbbrk: DB, lbrace: zB, lbrack: IB, lbrke: FB, lbrksld: HB, lbrkslu: qB, Lcaron: BB, lcaron: WB, Lcedil: UB, lcedil: VB, lceil: jB, lcub: GB, Lcy: KB, lcy: XB, ldca: YB, ldquo: ZB, ldquor: JB, ldrdhar: QB, ldrushar: e3, ldsh: t3, le: n3, lE: r3, LeftAngleBracket: i3, LeftArrowBar: o3, leftarrow: s3, LeftArrow: l3, Leftarrow: a3, LeftArrowRightArrow: c3, leftarrowtail: u3, LeftCeiling: f3, LeftDoubleBracket: d3, LeftDownTeeVector: h3, LeftDownVectorBar: p3, LeftDownVector: g3, LeftFloor: v3, leftharpoondown: m3, leftharpoonup: y3, leftleftarrows: b3, leftrightarrow: w3, LeftRightArrow: x3, Leftrightarrow: _3, leftrightarrows: S3, leftrightharpoons: k3, leftrightsquigarrow: C3, LeftRightVector: T3, LeftTeeArrow: E3, LeftTee: L3, LeftTeeVector: A3, leftthreetimes: M3, LeftTriangleBar: N3, LeftTriangle: $3, LeftTriangleEqual: O3, LeftUpDownVector: P3, LeftUpTeeVector: R3, LeftUpVectorBar: D3, LeftUpVector: z3, LeftVectorBar: I3, LeftVector: F3, lEg: H3, leg: q3, leq: B3, leqq: W3, leqslant: U3, lescc: V3, les: j3, lesdot: G3, lesdoto: K3, lesdotor: X3, lesg: Y3, lesges: Z3, lessapprox: J3, lessdot: Q3, lesseqgtr: e5, lesseqqgtr: t5, LessEqualGreater: n5, LessFullEqual: r5, LessGreater: i5, lessgtr: o5, LessLess: s5, lesssim: l5, LessSlantEqual: a5, LessTilde: c5, lfisht: u5, lfloor: f5, Lfr: d5, lfr: h5, lg: p5, lgE: g5, lHar: v5, lhard: m5, lharu: y5, lharul: b5, lhblk: w5, LJcy: x5, ljcy: _5, llarr: S5, ll: k5, Ll: C5, llcorner: T5, Lleftarrow: E5, llhard: L5, lltri: A5, Lmidot: M5, lmidot: N5, lmoustache: $5, lmoust: O5, lnap: P5, lnapprox: R5, lne: D5, lnE: z5, lneq: I5, lneqq: F5, lnsim: H5, loang: q5, loarr: B5, lobrk: W5, longleftarrow: U5, LongLeftArrow: V5, Longleftarrow: j5, longleftrightarrow: G5, LongLeftRightArrow: K5, Longleftrightarrow: X5, longmapsto: Y5, longrightarrow: Z5, LongRightArrow: J5, Longrightarrow: Q5, looparrowleft: e8, looparrowright: t8, lopar: n8, Lopf: r8, lopf: i8, loplus: o8, lotimes: s8, lowast: l8, lowbar: a8, LowerLeftArrow: c8, LowerRightArrow: u8, loz: f8, lozenge: d8, lozf: h8, lpar: p8, lparlt: g8, lrarr: v8, lrcorner: m8, lrhar: y8, lrhard: b8, lrm: w8, lrtri: x8, lsaquo: _8, lscr: S8, Lscr: k8, lsh: C8, Lsh: T8, lsim: E8, lsime: L8, lsimg: A8, lsqb: M8, lsquo: N8, lsquor: $8, Lstrok: O8, lstrok: P8, ltcc: R8, ltcir: D8, lt: z8, LT: I8, Lt: F8, ltdot: H8, lthree: q8, ltimes: B8, ltlarr: W8, ltquest: U8, ltri: V8, ltrie: j8, ltrif: G8, ltrPar: K8, lurdshar: X8, luruhar: Y8, lvertneqq: Z8, lvnE: J8, macr: Q8, male: eW, malt: tW, maltese: nW, Map: '', map: rW, mapsto: iW, mapstodown: oW, mapstoleft: sW, mapstoup: lW, marker: aW, mcomma: cW, Mcy: uW, mcy: fW, mdash: dW, mDDot: hW, measuredangle: pW, MediumSpace: gW, Mellintrf: vW, Mfr: mW, mfr: yW, mho: bW, micro: wW, midast: xW, midcir: _W, mid: SW, middot: kW, minusb: CW, minus: TW, minusd: EW, minusdu: LW, MinusPlus: AW, mlcp: MW, mldr: NW, mnplus: $W, models: OW, Mopf: PW, mopf: RW, mp: DW, mscr: zW, Mscr: IW, mstpos: FW, Mu: HW, mu: qW, multimap: BW, mumap: WW, nabla: UW, Nacute: VW, nacute: jW, nang: GW, nap: KW, napE: XW, napid: YW, napos: ZW, napprox: JW, natural: QW, naturals: e4, natur: t4, nbsp: n4, nbump: r4, nbumpe: i4, ncap: o4, Ncaron: s4, ncaron: l4, Ncedil: a4, ncedil: c4, ncong: u4, ncongdot: f4, ncup: d4, Ncy: h4, ncy: p4, ndash: g4, nearhk: v4, nearr: m4, neArr: y4, nearrow: b4, ne: w4, nedot: x4, NegativeMediumSpace: _4, NegativeThickSpace: S4, NegativeThinSpace: k4, NegativeVeryThinSpace: C4, nequiv: T4, nesear: E4, nesim: L4, NestedGreaterGreater: A4, NestedLessLess: M4, NewLine: N4, nexist: $4, nexists: O4, Nfr: P4, nfr: R4, ngE: D4, nge: z4, ngeq: I4, ngeqq: F4, ngeqslant: H4, nges: q4, nGg: B4, ngsim: W4, nGt: U4, ngt: V4, ngtr: j4, nGtv: G4, nharr: K4, nhArr: X4, nhpar: Y4, ni: Z4, nis: J4, nisd: Q4, niv: eU, NJcy: tU, njcy: nU, nlarr: rU, nlArr: iU, nldr: oU, nlE: sU, nle: lU, nleftarrow: aU, nLeftarrow: cU, nleftrightarrow: uU, nLeftrightarrow: fU, nleq: dU, nleqq: hU, nleqslant: pU, nles: gU, nless: vU, nLl: mU, nlsim: yU, nLt: bU, nlt: wU, nltri: xU, nltrie: _U, nLtv: SU, nmid: kU, NoBreak: CU, NonBreakingSpace: TU, nopf: EU, Nopf: LU, Not: AU, not: MU, NotCongruent: NU, NotCupCap: $U, NotDoubleVerticalBar: OU, NotElement: PU, NotEqual: RU, NotEqualTilde: DU, NotExists: zU, NotGreater: IU, NotGreaterEqual: FU, NotGreaterFullEqual: HU, NotGreaterGreater: qU, NotGreaterLess: BU, NotGreaterSlantEqual: WU, NotGreaterTilde: UU, NotHumpDownHump: VU, NotHumpEqual: jU, notin: GU, notindot: KU, notinE: XU, notinva: YU, notinvb: ZU, notinvc: JU, NotLeftTriangleBar: QU, NotLeftTriangle: e6, NotLeftTriangleEqual: t6, NotLess: n6, NotLessEqual: r6, NotLessGreater: i6, NotLessLess: o6, NotLessSlantEqual: s6, NotLessTilde: l6, NotNestedGreaterGreater: a6, NotNestedLessLess: c6, notni: u6, notniva: f6, notnivb: d6, notnivc: h6, NotPrecedes: p6, NotPrecedesEqual: g6, NotPrecedesSlantEqual: v6, NotReverseElement: m6, NotRightTriangleBar: y6, NotRightTriangle: b6, NotRightTriangleEqual: w6, NotSquareSubset: x6, NotSquareSubsetEqual: _6, NotSquareSuperset: S6, NotSquareSupersetEqual: k6, NotSubset: C6, NotSubsetEqual: T6, NotSucceeds: E6, NotSucceedsEqual: L6, NotSucceedsSlantEqual: A6, NotSucceedsTilde: M6, NotSuperset: N6, NotSupersetEqual: $6, NotTilde: O6, NotTildeEqual: P6, NotTildeFullEqual: R6, NotTildeTilde: D6, NotVerticalBar: z6, nparallel: I6, npar: F6, nparsl: H6, npart: q6, npolint: B6, npr: W6, nprcue: U6, nprec: V6, npreceq: j6, npre: G6, nrarrc: K6, nrarr: X6, nrArr: Y6, nrarrw: Z6, nrightarrow: J6, nRightarrow: Q6, nrtri: eV, nrtrie: tV, nsc: nV, nsccue: rV, nsce: iV, Nscr: oV, nscr: sV, nshortmid: lV, nshortparallel: aV, nsim: cV, nsime: uV, nsimeq: fV, nsmid: dV, nspar: hV, nsqsube: pV, nsqsupe: gV, nsub: vV, nsubE: mV, nsube: yV, nsubset: bV, nsubseteq: wV, nsubseteqq: xV, nsucc: _V, nsucceq: SV, nsup: kV, nsupE: CV, nsupe: TV, nsupset: EV, nsupseteq: LV, nsupseteqq: AV, ntgl: MV, Ntilde: NV, ntilde: $V, ntlg: OV, ntriangleleft: PV, ntrianglelefteq: RV, ntriangleright: DV, ntrianglerighteq: zV, Nu: IV, nu: FV, num: HV, numero: qV, numsp: BV, nvap: WV, nvdash: UV, nvDash: VV, nVdash: jV, nVDash: GV, nvge: KV, nvgt: XV, nvHarr: YV, nvinfin: ZV, nvlArr: JV, nvle: QV, nvlt: ej, nvltrie: tj, nvrArr: nj, nvrtrie: rj, nvsim: ij, nwarhk: oj, nwarr: sj, nwArr: lj, nwarrow: aj, nwnear: cj, Oacute: uj, oacute: fj, oast: dj, Ocirc: hj, ocirc: pj, ocir: gj, Ocy: vj, ocy: mj, odash: yj, Odblac: bj, odblac: wj, odiv: xj, odot: _j, odsold: Sj, OElig: kj, oelig: Cj, ofcir: Tj, Ofr: Ej, ofr: Lj, ogon: Aj, Ograve: Mj, ograve: Nj, ogt: $j, ohbar: Oj, ohm: Pj, oint: Rj, olarr: Dj, olcir: zj, olcross: Ij, oline: Fj, olt: Hj, Omacr: qj, omacr: Bj, Omega: Wj, omega: Uj, Omicron: Vj, omicron: jj, omid: Gj, ominus: Kj, Oopf: Xj, oopf: Yj, opar: Zj, OpenCurlyDoubleQuote: Jj, OpenCurlyQuote: Qj, operp: eG, oplus: tG, orarr: nG, Or: rG, or: iG, ord: oG, order: sG, orderof: lG, ordf: aG, ordm: cG, origof: uG, oror: fG, orslope: dG, orv: hG, oS: pG, Oscr: gG, oscr: vG, Oslash: mG, oslash: yG, osol: bG, Otilde: wG, otilde: xG, otimesas: _G, Otimes: SG, otimes: kG, Ouml: CG, ouml: TG, ovbar: EG, OverBar: LG, OverBrace: AG, OverBracket: MG, OverParenthesis: NG, para: $G, parallel: OG, par: PG, parsim: RG, parsl: DG, part: zG, PartialD: IG, Pcy: FG, pcy: HG, percnt: qG, period: BG, permil: WG, perp: UG, pertenk: VG, Pfr: jG, pfr: GG, Phi: KG, phi: XG, phiv: YG, phmmat: ZG, phone: JG, Pi: QG, pi: e9, pitchfork: t9, piv: n9, planck: r9, planckh: i9, plankv: o9, plusacir: s9, plusb: l9, pluscir: a9, plus: c9, plusdo: u9, plusdu: f9, pluse: d9, PlusMinus: h9, plusmn: p9, plussim: g9, plustwo: v9, pm: m9, Poincareplane: y9, pointint: b9, popf: w9, Popf: x9, pound: _9, prap: S9, Pr: k9, pr: C9, prcue: T9, precapprox: E9, prec: L9, preccurlyeq: A9, Precedes: M9, PrecedesEqual: N9, PrecedesSlantEqual: $9, PrecedesTilde: O9, preceq: P9, precnapprox: R9, precneqq: D9, precnsim: z9, pre: I9, prE: F9, precsim: H9, prime: q9, Prime: B9, primes: W9, prnap: U9, prnE: V9, prnsim: j9, prod: G9, Product: K9, profalar: X9, profline: Y9, profsurf: Z9, prop: J9, Proportional: Q9, Proportion: e7, propto: t7, prsim: n7, prurel: r7, Pscr: i7, pscr: o7, Psi: s7, psi: l7, puncsp: a7, Qfr: c7, qfr: u7, qint: f7, qopf: d7, Qopf: h7, qprime: p7, Qscr: g7, qscr: v7, quaternions: m7, quatint: y7, quest: b7, questeq: w7, quot: x7, QUOT: _7, rAarr: S7, race: k7, Racute: C7, racute: T7, radic: E7, raemptyv: L7, rang: A7, Rang: M7, rangd: N7, range: $7, rangle: O7, raquo: P7, rarrap: R7, rarrb: D7, rarrbfs: z7, rarrc: I7, rarr: F7, Rarr: H7, rArr: q7, rarrfs: B7, rarrhk: W7, rarrlp: U7, rarrpl: V7, rarrsim: j7, Rarrtl: G7, rarrtl: K7, rarrw: X7, ratail: Y7, rAtail: Z7, ratio: J7, rationals: Q7, rbarr: eK, rBarr: tK, RBarr: nK, rbbrk: rK, rbrace: iK, rbrack: oK, rbrke: sK, rbrksld: lK, rbrkslu: aK, Rcaron: cK, rcaron: uK, Rcedil: fK, rcedil: dK, rceil: hK, rcub: pK, Rcy: gK, rcy: vK, rdca: mK, rdldhar: yK, rdquo: bK, rdquor: wK, rdsh: xK, real: _K, realine: SK, realpart: kK, reals: CK, Re: TK, rect: EK, reg: LK, REG: AK, ReverseElement: MK, ReverseEquilibrium: NK, ReverseUpEquilibrium: $K, rfisht: OK, rfloor: PK, rfr: RK, Rfr: DK, rHar: zK, rhard: IK, rharu: FK, rharul: HK, Rho: qK, rho: BK, rhov: WK, RightAngleBracket: UK, RightArrowBar: VK, rightarrow: jK, RightArrow: GK, Rightarrow: KK, RightArrowLeftArrow: XK, rightarrowtail: YK, RightCeiling: ZK, RightDoubleBracket: JK, RightDownTeeVector: QK, RightDownVectorBar: eX, RightDownVector: tX, RightFloor: nX, rightharpoondown: rX, rightharpoonup: iX, rightleftarrows: oX, rightleftharpoons: sX, rightrightarrows: lX, rightsquigarrow: aX, RightTeeArrow: cX, RightTee: uX, RightTeeVector: fX, rightthreetimes: dX, RightTriangleBar: hX, RightTriangle: pX, RightTriangleEqual: gX, RightUpDownVector: vX, RightUpTeeVector: mX, RightUpVectorBar: yX, RightUpVector: bX, RightVectorBar: wX, RightVector: xX, ring: _X, risingdotseq: SX, rlarr: kX, rlhar: CX, rlm: TX, rmoustache: EX, rmoust: LX, rnmid: AX, roang: MX, roarr: NX, robrk: $X, ropar: OX, ropf: PX, Ropf: RX, roplus: DX, rotimes: zX, RoundImplies: IX, rpar: FX, rpargt: HX, rppolint: qX, rrarr: BX, Rrightarrow: WX, rsaquo: UX, rscr: VX, Rscr: jX, rsh: GX, Rsh: KX, rsqb: XX, rsquo: YX, rsquor: ZX, rthree: JX, rtimes: QX, rtri: eY, rtrie: tY, rtrif: nY, rtriltri: rY, RuleDelayed: iY, ruluhar: oY, rx: sY, Sacute: lY, sacute: aY, sbquo: cY, scap: uY, Scaron: fY, scaron: dY, Sc: hY, sc: pY, sccue: gY, sce: vY, scE: mY, Scedil: yY, scedil: bY, Scirc: wY, scirc: xY, scnap: _Y, scnE: SY, scnsim: kY, scpolint: CY, scsim: TY, Scy: EY, scy: LY, sdotb: AY, sdot: MY, sdote: NY, searhk: $Y, searr: OY, seArr: PY, searrow: RY, sect: DY, semi: zY, seswar: IY, setminus: FY, setmn: HY, sext: qY, Sfr: BY, sfr: WY, sfrown: UY, sharp: VY, SHCHcy: jY, shchcy: GY, SHcy: KY, shcy: XY, ShortDownArrow: YY, ShortLeftArrow: ZY, shortmid: JY, shortparallel: QY, ShortRightArrow: eZ, ShortUpArrow: tZ, shy: nZ, Sigma: rZ, sigma: iZ, sigmaf: oZ, sigmav: sZ, sim: lZ, simdot: aZ, sime: cZ, simeq: uZ, simg: fZ, simgE: dZ, siml: hZ, simlE: pZ, simne: gZ, simplus: vZ, simrarr: mZ, slarr: yZ, SmallCircle: bZ, smallsetminus: wZ, smashp: xZ, smeparsl: _Z, smid: SZ, smile: kZ, smt: CZ, smte: TZ, smtes: EZ, SOFTcy: LZ, softcy: AZ, solbar: MZ, solb: NZ, sol: $Z, Sopf: OZ, sopf: PZ, spades: RZ, spadesuit: DZ, spar: zZ, sqcap: IZ, sqcaps: FZ, sqcup: HZ, sqcups: qZ, Sqrt: BZ, sqsub: WZ, sqsube: UZ, sqsubset: VZ, sqsubseteq: jZ, sqsup: GZ, sqsupe: KZ, sqsupset: XZ, sqsupseteq: YZ, square: ZZ, Square: JZ, SquareIntersection: QZ, SquareSubset: eJ, SquareSubsetEqual: tJ, SquareSuperset: nJ, SquareSupersetEqual: rJ, SquareUnion: iJ, squarf: oJ, squ: sJ, squf: lJ, srarr: aJ, Sscr: cJ, sscr: uJ, ssetmn: fJ, ssmile: dJ, sstarf: hJ, Star: pJ, star: gJ, starf: vJ, straightepsilon: mJ, straightphi: yJ, strns: bJ, sub: wJ, Sub: xJ, subdot: _J, subE: SJ, sube: kJ, subedot: CJ, submult: TJ, subnE: EJ, subne: LJ, subplus: AJ, subrarr: MJ, subset: NJ, Subset: $J, subseteq: OJ, subseteqq: PJ, SubsetEqual: RJ, subsetneq: DJ, subsetneqq: zJ, subsim: IJ, subsub: FJ, subsup: HJ, succapprox: qJ, succ: BJ, succcurlyeq: WJ, Succeeds: UJ, SucceedsEqual: VJ, SucceedsSlantEqual: jJ, SucceedsTilde: GJ, succeq: KJ, succnapprox: XJ, succneqq: YJ, succnsim: ZJ, succsim: JJ, SuchThat: QJ, sum: eQ, Sum: tQ, sung: nQ, sup1: rQ, sup2: iQ, sup3: oQ, sup: sQ, Sup: lQ, supdot: aQ, supdsub: cQ, supE: uQ, supe: fQ, supedot: dQ, Superset: hQ, SupersetEqual: pQ, suphsol: gQ, suphsub: vQ, suplarr: mQ, supmult: yQ, supnE: bQ, supne: wQ, supplus: xQ, supset: _Q, Supset: SQ, supseteq: kQ, supseteqq: CQ, supsetneq: TQ, supsetneqq: EQ, supsim: LQ, supsub: AQ, supsup: MQ, swarhk: NQ, swarr: $Q, swArr: OQ, swarrow: PQ, swnwar: RQ, szlig: DQ, Tab: zQ, target: IQ, Tau: FQ, tau: HQ, tbrk: qQ, Tcaron: BQ, tcaron: WQ, Tcedil: UQ, tcedil: VQ, Tcy: jQ, tcy: GQ, tdot: KQ, telrec: XQ, Tfr: YQ, tfr: ZQ, there4: JQ, therefore: QQ, Therefore: eee, Theta: tee, theta: nee, thetasym: ree, thetav: iee, thickapprox: oee, thicksim: see, ThickSpace: lee, ThinSpace: aee, thinsp: cee, thkap: uee, thksim: fee, THORN: dee, thorn: hee, tilde: pee, Tilde: gee, TildeEqual: vee, TildeFullEqual: mee, TildeTilde: yee, timesbar: bee, timesb: wee, times: xee, timesd: _ee, tint: See, toea: kee, topbot: Cee, topcir: Tee, top: Eee, Topf: Lee, topf: Aee, topfork: Mee, tosa: Nee, tprime: $ee, trade: Oee, TRADE: Pee, triangle: Ree, triangledown: Dee, triangleleft: zee, trianglelefteq: Iee, triangleq: Fee, triangleright: Hee, trianglerighteq: qee, tridot: Bee, trie: Wee, triminus: Uee, TripleDot: Vee, triplus: jee, trisb: Gee, tritime: Kee, trpezium: Xee, Tscr: Yee, tscr: Zee, TScy: Jee, tscy: Qee, TSHcy: ete, tshcy: tte, Tstrok: nte, tstrok: rte, twixt: ite, twoheadleftarrow: ote, twoheadrightarrow: ste, Uacute: lte, uacute: ate, uarr: cte, Uarr: ute, uArr: fte, Uarrocir: dte, Ubrcy: hte, ubrcy: pte, Ubreve: gte, ubreve: vte, Ucirc: mte, ucirc: yte, Ucy: bte, ucy: wte, udarr: xte, Udblac: _te, udblac: Ste, udhar: kte, ufisht: Cte, Ufr: Tte, ufr: Ete, Ugrave: Lte, ugrave: Ate, uHar: Mte, uharl: Nte, uharr: $te, uhblk: Ote, ulcorn: Pte, ulcorner: Rte, ulcrop: Dte, ultri: zte, Umacr: Ite, umacr: Fte, uml: Hte, UnderBar: qte, UnderBrace: Bte, UnderBracket: Wte, UnderParenthesis: Ute, Union: Vte, UnionPlus: jte, Uogon: Gte, uogon: Kte, Uopf: Xte, uopf: Yte, UpArrowBar: Zte, uparrow: Jte, UpArrow: Qte, Uparrow: ene, UpArrowDownArrow: tne, updownarrow: nne, UpDownArrow: rne, Updownarrow: ine, UpEquilibrium: one, upharpoonleft: sne, upharpoonright: lne, uplus: ane, UpperLeftArrow: cne, UpperRightArrow: une, upsi: fne, Upsi: dne, upsih: hne, Upsilon: pne, upsilon: gne, UpTeeArrow: vne, UpTee: mne, upuparrows: yne, urcorn: bne, urcorner: wne, urcrop: xne, Uring: _ne, uring: Sne, urtri: kne, Uscr: Cne, uscr: Tne, utdot: Ene, Utilde: Lne, utilde: Ane, utri: Mne, utrif: Nne, uuarr: $ne, Uuml: One, uuml: Pne, uwangle: Rne, vangrt: Dne, varepsilon: zne, varkappa: Ine, varnothing: Fne, varphi: Hne, varpi: qne, varpropto: Bne, varr: Wne, vArr: Une, varrho: Vne, varsigma: jne, varsubsetneq: Gne, varsubsetneqq: Kne, varsupsetneq: Xne, varsupsetneqq: Yne, vartheta: Zne, vartriangleleft: Jne, vartriangleright: Qne, vBar: ere, Vbar: tre, vBarv: nre, Vcy: rre, vcy: ire, vdash: ore, vDash: sre, Vdash: lre, VDash: are, Vdashl: cre, veebar: ure, vee: fre, Vee: dre, veeeq: hre, vellip: pre, verbar: gre, Verbar: vre, vert: mre, Vert: yre, VerticalBar: bre, VerticalLine: wre, VerticalSeparator: xre, VerticalTilde: _re, VeryThinSpace: Sre, Vfr: kre, vfr: Cre, vltri: Tre, vnsub: Ere, vnsup: Lre, Vopf: Are, vopf: Mre, vprop: Nre, vrtri: $re, Vscr: Ore, vscr: Pre, vsubnE: Rre, vsubne: Dre, vsupnE: zre, vsupne: Ire, Vvdash: Fre, vzigzag: Hre, Wcirc: qre, wcirc: Bre, wedbar: Wre, wedge: Ure, Wedge: Vre, wedgeq: jre, weierp: Gre, Wfr: Kre, wfr: Xre, Wopf: Yre, wopf: Zre, wp: Jre, wr: Qre, wreath: eie, Wscr: tie, wscr: nie, xcap: rie, xcirc: iie, xcup: oie, xdtri: sie, Xfr: lie, xfr: aie, xharr: cie, xhArr: uie, Xi: fie, xi: die, xlarr: hie, xlArr: pie, xmap: gie, xnis: vie, xodot: mie, Xopf: yie, xopf: bie, xoplus: wie, xotime: xie, xrarr: _ie, xrArr: Sie, Xscr: kie, xscr: Cie, xsqcup: Tie, xuplus: Eie, xutri: Lie, xvee: Aie, xwedge: Mie, Yacute: Nie, yacute: $ie, YAcy: Oie, yacy: Pie, Ycirc: Rie, ycirc: Die, Ycy: zie, ycy: Iie, yen: Fie, Yfr: Hie, yfr: qie, YIcy: Bie, yicy: Wie, Yopf: Uie, yopf: Vie, Yscr: jie, yscr: Gie, YUcy: Kie, yucy: Xie, yuml: Yie, Yuml: Zie, Zacute: Jie, zacute: Qie, Zcaron: eoe, zcaron: toe, Zcy: noe, zcy: roe, Zdot: ioe, zdot: ooe, zeetrf: soe, ZeroWidthSpace: loe, Zeta: aoe, zeta: coe, zfr: uoe, Zfr: foe, ZHcy: doe, zhcy: hoe, zigrarr: poe, zopf: goe, Zopf: voe, Zscr: moe, zscr: yoe, zwj: boe, zwnj: woe }; const xoe = ''; const _oe = ''; const Soe = ''; const koe = ''; const Coe = ''; const Toe = ''; const Eoe = ''; const Loe = ''; const Aoe = ''; const Moe = '&'; const Noe = '&'; const $oe = ''; const Ooe = ''; const Poe = ''; const Roe = ''; const Doe = ''; const zoe = ''; const Ioe = ''; const Foe = ''; const Hoe = ''; const qoe = ''; const Boe = ''; const Woe = ''; const Uoe = ''; const Voe = ''; const joe = ''; const Goe = ''; const Koe = ''; const Xoe = ''; const Yoe = ''; const Zoe = ''; const Joe = ''; const Qoe = ''; const ese = ''; const tse = ''; const nse = ''; const rse = ''; const ise = ''; const ose = ''; const sse = ''; const lse = '>'; const ase = '>'; const cse = ''; const use = ''; const fse = ''; const dse = ''; const hse = ''; const pse = ''; const gse = ''; const vse = ''; const mse = ''; const yse = ''; const bse = ''; const wse = '<'; const xse = '<'; const _se = ''; const Sse = ''; const kse = ''; const Cse = ''; const Tse = ''; const Ese = ''; const Lse = ''; const Ase = ''; const Mse = ''; const Nse = ''; const $se = ''; const Ose = ''; const Pse = ''; const Rse = ''; const Dse = ''; const zse = ''; const Ise = ''; const Fse = ''; const Hse = ''; const qse = ''; const Bse = ''; const Wse = ''; const Use = ''; const Vse = ''; const jse = '"'; const Gse = '"'; const Kse = ''; const Xse = ''; const Yse = ''; const Zse = ''; const Jse = ''; const Qse = ''; const ele = ''; const tle = ''; const nle = ''; const rle = ''; const ile = ''; const ole = ''; const sle = ''; const lle = ''; const ale = ''; const cle = ''; const ule = ''; const fle = ''; const dle = ''; const hle = ''; const ple = ''; const gle = ''; const vle = ''; const mle = ''; const yle = ''; const ble = { Aacute: xoe, aacute: _oe, Acirc: Soe, acirc: koe, acute: Coe, AElig: Toe, aelig: Eoe, Agrave: Loe, agrave: Aoe, amp: Moe, AMP: Noe, Aring: $oe, aring: Ooe, Atilde: Poe, atilde: Roe, Auml: Doe, auml: zoe, brvbar: Ioe, Ccedil: Foe, ccedil: Hoe, cedil: qoe, cent: Boe, copy: Woe, COPY: Uoe, curren: Voe, deg: joe, divide: Goe, Eacute: Koe, eacute: Xoe, Ecirc: Yoe, ecirc: Zoe, Egrave: Joe, egrave: Qoe, ETH: ese, eth: tse, Euml: nse, euml: rse, frac12: ise, frac14: ose, frac34: sse, gt: lse, GT: ase, Iacute: cse, iacute: use, Icirc: fse, icirc: dse, iexcl: hse, Igrave: pse, igrave: gse, iquest: vse, Iuml: mse, iuml: yse, laquo: bse, lt: wse, LT: xse, macr: _se, micro: Sse, middot: kse, nbsp: Cse, not: Tse, Ntilde: Ese, ntilde: Lse, Oacute: Ase, oacute: Mse, Ocirc: Nse, ocirc: $se, Ograve: Ose, ograve: Pse, ordf: Rse, ordm: Dse, Oslash: zse, oslash: Ise, Otilde: Fse, otilde: Hse, Ouml: qse, ouml: Bse, para: Wse, plusmn: Use, pound: Vse, quot: jse, QUOT: Gse, raquo: Kse, reg: Xse, REG: Yse, sect: Zse, shy: Jse, sup1: Qse, sup2: ele, sup3: tle, szlig: nle, THORN: rle, thorn: ile, times: ole, Uacute: sle, uacute: lle, Ucirc: ale, ucirc: cle, Ugrave: ule, ugrave: fle, uml: dle, Uuml: hle, uuml: ple, Yacute: gle, yacute: vle, yen: mle, yuml: yle }; const wle = '&'; const xle = '\''; const _le = '>'; const Sle = '<'; const kle = '"'; const Kb = { amp: wle, apos: xle, gt: _le, lt: Sle, quot: kle }; const Hh = {}; const Cle = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 }; const Tle = Mo && Mo.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(Hh, '__esModule', { value: !0 }); const Im = Tle(Cle); const Ele = String.fromCodePoint || function (e) { let t = ''; return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t }; function Lle(e) { return e >= 55296 && e <= 57343 || e > 1114111 ? '' : (e in Im.default && (e = Im.default[e]), Ele(e)) }Hh.default = Lle; const Nu = Mo && Mo.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(oi, '__esModule', { value: !0 }); oi.decodeHTML = oi.decodeHTMLStrict = oi.decodeXML = void 0; const Pd = Nu(Gb); const Ale = Nu(ble); const Mle = Nu(Kb); const Fm = Nu(Hh); const Nle = /&(?:[a-z0-9]+|#x[\da-f]+|#\d+);/gi; oi.decodeXML = Xb(Mle.default); oi.decodeHTMLStrict = Xb(Pd.default); function Xb(e) { const t = Yb(e); return function (r) { return String(r).replace(Nle, t) } } const Hm = function (e, t) { return e < t ? 1 : -1 }; oi.decodeHTML = (function () { for (var e = Object.keys(Ale.default).sort(Hm), t = Object.keys(Pd.default).sort(Hm), r = 0, o = 0; r < t.length; r++)e[o] === t[r] ? (t[r] += ';?', o++) : t[r] += ';'; const s = new RegExp(`&(?:${t.join('|')}|#[xX][\\da-fA-F]+;?|#\\d+;?)`, 'g'); const c = Yb(Pd.default); function f(d) { return d.substr(-1) !== ';' && (d += ';'), c(d) } return function (d) { return String(d).replace(s, f) } }()); function Yb(e) { return function (r) { if (r.charAt(1) === '#') { const o = r.charAt(2); return o === 'X' || o === 'x' ? Fm.default(Number.parseInt(r.substr(3), 16)) : Fm.default(Number.parseInt(r.substr(2), 10)) } return e[r.slice(1, -1)] || r } } const Vn = {}; const Zb = Mo && Mo.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(Vn, '__esModule', { value: !0 }); Vn.escapeUTF8 = Vn.escape = Vn.encodeNonAsciiHTML = Vn.encodeHTML = Vn.encodeXML = void 0; const $le = Zb(Kb); const Jb = ew($le.default); const Qb = tw(Jb); Vn.encodeXML = iw(Jb); const Ole = Zb(Gb); const qh = ew(Ole.default); const Ple = tw(qh); Vn.encodeHTML = Dle(qh, Ple); Vn.encodeNonAsciiHTML = iw(qh); function ew(e) { return Object.keys(e).sort().reduce((t, r) => { return t[e[r]] = `&${r};`, t }, {}) } function tw(e) { for (var t = [], r = [], o = 0, s = Object.keys(e); o < s.length; o++) { const c = s[o]; c.length === 1 ? t.push(`\\${c}`) : r.push(c) }t.sort(); for (let f = 0; f < t.length - 1; f++) { for (var d = f; d < t.length - 1 && t[d].charCodeAt(1) + 1 === t[d + 1].charCodeAt(1);)d += 1; const h = 1 + d - f; h < 3 || t.splice(f, h, `${t[f]}-${t[d]}`) } return r.unshift(`[${t.join('')}]`), new RegExp(r.join('|'), 'g') } const nw = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g; const Rle = String.prototype.codePointAt != null ? function (e) { return e.codePointAt(0) } : function (e) { return (e.charCodeAt(0) - 55296) * 1024 + e.charCodeAt(1) - 56320 + 65536 }; function $u(e) { return `&#x${(e.length > 1 ? Rle(e) : e.charCodeAt(0)).toString(16).toUpperCase()};` } function Dle(e, t) { return function (r) { return r.replace(t, (o) => { return e[o] }).replace(nw, $u) } } const rw = new RegExp(`${Qb.source}|${nw.source}`, 'g'); function zle(e) { return e.replace(rw, $u) }Vn.escape = zle; function Ile(e) { return e.replace(Qb, $u) }Vn.escapeUTF8 = Ile; function iw(e) { return function (t) { return t.replace(rw, (r) => { return e[r] || $u(r) }) } }(function (e) { Object.defineProperty(e, '__esModule', { value: !0 }), e.decodeXMLStrict = e.decodeHTML5Strict = e.decodeHTML4Strict = e.decodeHTML5 = e.decodeHTML4 = e.decodeHTMLStrict = e.decodeHTML = e.decodeXML = e.encodeHTML5 = e.encodeHTML4 = e.escapeUTF8 = e.escape = e.encodeNonAsciiHTML = e.encodeHTML = e.encodeXML = e.encode = e.decodeStrict = e.decode = void 0; const t = oi; const r = Vn; function o(h, g) { return (!g || g <= 0 ? t.decodeXML : t.decodeHTML)(h) }e.decode = o; function s(h, g) { return (!g || g <= 0 ? t.decodeXML : t.decodeHTMLStrict)(h) }e.decodeStrict = s; function c(h, g) { return (!g || g <= 0 ? r.encodeXML : r.encodeHTML)(h) }e.encode = c; const f = Vn; Object.defineProperty(e, 'encodeXML', { enumerable: !0, get() { return f.encodeXML } }), Object.defineProperty(e, 'encodeHTML', { enumerable: !0, get() { return f.encodeHTML } }), Object.defineProperty(e, 'encodeNonAsciiHTML', { enumerable: !0, get() { return f.encodeNonAsciiHTML } }), Object.defineProperty(e, 'escape', { enumerable: !0, get() { return f.escape } }), Object.defineProperty(e, 'escapeUTF8', { enumerable: !0, get() { return f.escapeUTF8 } }), Object.defineProperty(e, 'encodeHTML4', { enumerable: !0, get() { return f.encodeHTML } }), Object.defineProperty(e, 'encodeHTML5', { enumerable: !0, get() { return f.encodeHTML } }); const d = oi; Object.defineProperty(e, 'decodeXML', { enumerable: !0, get() { return d.decodeXML } }), Object.defineProperty(e, 'decodeHTML', { enumerable: !0, get() { return d.decodeHTML } }), Object.defineProperty(e, 'decodeHTMLStrict', { enumerable: !0, get() { return d.decodeHTMLStrict } }), Object.defineProperty(e, 'decodeHTML4', { enumerable: !0, get() { return d.decodeHTML } }), Object.defineProperty(e, 'decodeHTML5', { enumerable: !0, get() { return d.decodeHTML } }), Object.defineProperty(e, 'decodeHTML4Strict', { enumerable: !0, get() { return d.decodeHTMLStrict } }), Object.defineProperty(e, 'decodeHTML5Strict', { enumerable: !0, get() { return d.decodeHTMLStrict } }), Object.defineProperty(e, 'decodeXMLStrict', { enumerable: !0, get() { return d.decodeXML } }) })(jb); function Fle(e, t) {
  if (!(e instanceof t))
    throw new TypeError('Cannot call a class as a function')
} function Hle(e, t) { for (let r = 0; r < t.length; r++) { const o = t[r]; o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } function qle(e, t, r) { return t && Hle(e.prototype, t), e } function ow(e, t) {
  let r = typeof Symbol < 'u' && e[Symbol.iterator] || e['@@iterator']; if (!r) {
    if (Array.isArray(e) || (r = Ble(e)) || t) { r && (e = r); let o = 0; const s = function () {}; return { s, n() { return o >= e.length ? { done: !0 } : { done: !1, value: e[o++] } }, e(g) { throw g }, f: s } } throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  } let c = !0; let f = !1; let d; return { s() { r = r.call(e) }, n() { const g = r.next(); return c = g.done, g }, e(g) { f = !0, d = g }, f() {
    try { !c && r.return != null && r.return() }
    finally {
      if (f)
        throw d
    }
  } }
} function Ble(e, t) {
  if (e) {
    if (typeof e == 'string')
      return qm(e, t); let r = Object.prototype.toString.call(e).slice(8, -1); if (r === 'Object' && e.constructor && (r = e.constructor.name), r === 'Map' || r === 'Set')
      return Array.from(e); if (r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return qm(e, t)
  }
} function qm(e, t) { (t == null || t > e.length) && (t = e.length); for (var r = 0, o = new Array(t); r < t; r++)o[r] = e[r]; return o } const Wle = jb; const Bm = { fg: '#FFF', bg: '#000', newline: !1, escapeXML: !1, stream: !1, colors: Ule() }; function Ule() { const e = { 0: '#000', 1: '#A00', 2: '#0A0', 3: '#A50', 4: '#00A', 5: '#A0A', 6: '#0AA', 7: '#AAA', 8: '#555', 9: '#F55', 10: '#5F5', 11: '#FF5', 12: '#55F', 13: '#F5F', 14: '#5FF', 15: '#FFF' }; return sc(0, 5).forEach((t) => { sc(0, 5).forEach((r) => { sc(0, 5).forEach((o) => { return Vle(t, r, o, e) }) }) }), sc(0, 23).forEach((t) => { const r = t + 232; const o = sw(t * 10 + 8); e[r] = `#${o}${o}${o}` }), e } function Vle(e, t, r, o) { const s = 16 + e * 36 + t * 6 + r; const c = e > 0 ? e * 40 + 55 : 0; const f = t > 0 ? t * 40 + 55 : 0; const d = r > 0 ? r * 40 + 55 : 0; o[s] = jle([c, f, d]) } function sw(e) { for (var t = e.toString(16); t.length < 2;)t = `0${t}`; return t } function jle(e) {
  const t = []; const r = ow(e); let o; try { for (r.s(); !(o = r.n()).done;) { const s = o.value; t.push(sw(s)) } }
  catch (c) { r.e(c) }
  finally { r.f() } return `#${t.join('')}`
} function Wm(e, t, r, o) { let s; return t === 'text' ? s = Yle(r, o) : t === 'display' ? s = Kle(e, r, o) : t === 'xterm256Foreground' ? s = Cc(e, o.colors[r]) : t === 'xterm256Background' ? s = Tc(e, o.colors[r]) : t === 'rgb' && (s = Gle(e, r)), s } function Gle(e, t) { t = t.substring(2).slice(0, -1); const r = +t.substr(0, 2); const o = t.substring(5).split(';'); const s = o.map((c) => { return (`0${Number(c).toString(16)}`).substr(-2) }).join(''); return kc(e, (r === 38 ? 'color:#' : 'background-color:#') + s) } function Kle(e, t, r) { t = Number.parseInt(t, 10); const o = { '-1': function () { return '<br/>' }, '0': function () { return e.length && lw(e) }, '1': function () { return qi(e, 'b') }, '3': function () { return qi(e, 'i') }, '4': function () { return qi(e, 'u') }, '8': function () { return kc(e, 'display:none') }, '9': function () { return qi(e, 'strike') }, '22': function () { return kc(e, 'font-weight:normal;text-decoration:none;font-style:normal') }, '23': function () { return Vm(e, 'i') }, '24': function () { return Vm(e, 'u') }, '39': function () { return Cc(e, r.fg) }, '49': function () { return Tc(e, r.bg) }, '53': function () { return kc(e, 'text-decoration:overline') } }; let s; return o[t] ? s = o[t]() : t > 4 && t < 7 ? s = qi(e, 'blink') : t > 29 && t < 38 ? s = Cc(e, r.colors[t - 30]) : t > 39 && t < 48 ? s = Tc(e, r.colors[t - 40]) : t > 89 && t < 98 ? s = Cc(e, r.colors[8 + (t - 90)]) : t > 99 && t < 108 && (s = Tc(e, r.colors[8 + (t - 100)])), s } function lw(e) { const t = e.slice(0); return e.length = 0, t.reverse().map((r) => { return `</${r}>` }).join('') } function sc(e, t) { for (var r = [], o = e; o <= t; o++)r.push(o); return r } function Xle(e) { return function (t) { return (e === null || t.category !== e) && e !== 'all' } } function Um(e) { e = Number.parseInt(e, 10); let t = null; return e === 0 ? t = 'all' : e === 1 ? t = 'bold' : e > 2 && e < 5 ? t = 'underline' : e > 4 && e < 7 ? t = 'blink' : e === 8 ? t = 'hide' : e === 9 ? t = 'strike' : e > 29 && e < 38 || e === 39 || e > 89 && e < 98 ? t = 'foreground-color' : (e > 39 && e < 48 || e === 49 || e > 99 && e < 108) && (t = 'background-color'), t } function Yle(e, t) { return t.escapeXML ? Wle.encodeXML(e) : e } function qi(e, t, r) { return r || (r = ''), e.push(t), '<'.concat(t).concat(r ? ' style="'.concat(r, '"') : '', '>') } function kc(e, t) { return qi(e, 'span', t) } function Cc(e, t) { return qi(e, 'span', `color:${t}`) } function Tc(e, t) { return qi(e, 'span', `background-color:${t}`) } function Vm(e, t) {
  let r; if (e.slice(-1)[0] === t && (r = e.pop()), r)
    return `</${t}>`
} function Zle(e, t, r) {
  let o = !1; const s = 3; function c() { return '' } function f(H, z) { return r('xterm256Foreground', z), '' } function d(H, z) { return r('xterm256Background', z), '' } function h(H) { return t.newline ? r('display', -1) : r('text', H), '' } function g(H, z) {
    o = !0, z.trim().length === 0 && (z = '0'), z = z.trimRight(';').split(';'); const J = ow(z); let re; try { for (J.s(); !(re = J.n()).done;) { const te = re.value; r('display', te) } }
    catch (j) { J.e(j) }
    finally { J.f() } return ''
  } function v(H) { return r('text', H), '' } function y(H) { return r('rgb', H), '' } const b = [{ pattern: /^\x08+/, sub: c }, { pattern: /^\x1B\[[012]?K/, sub: c }, { pattern: /^\x1B\[\(B/, sub: c }, { pattern: /^\x1B\[[34]8;2;\d+;\d+;\d+m/, sub: y }, { pattern: /^\x1B\[38;5;(\d+)m/, sub: f }, { pattern: /^\x1B\[48;5;(\d+)m/, sub: d }, { pattern: /^\n/, sub: h }, { pattern: /^\r+\n/, sub: h }, { pattern: /^\r/, sub: h }, { pattern: /^\x1B\[((?:\d{1,3};?)+|)m/, sub: g }, { pattern: /^\x1B\[\d?J/, sub: c }, { pattern: /^\x1B\[\d{0,3};\d{0,3}f/, sub: c }, { pattern: /^\x1B\[?[\d;]{0,3}/, sub: c }, { pattern: /^(([^\x1B\x08\r\n])+)/, sub: v }]; function x(H, z) { z > s && o || (o = !1, e = e.replace(H.pattern, H.sub)) } const T = []; const E = e; let M = E.length; e:for (;M > 0;) {
    for (let N = 0, L = 0, O = b.length; L < O; N = ++L) { const A = b[N]; if (x(A, N), e.length !== M) { M = e.length; continue e } } if (e.length === M)
      break; T.push(0), M = e.length
  } return T
} function Jle(e, t, r) { return t !== 'text' && (e = e.filter(Xle(Um(r))), e.push({ token: t, data: r, category: Um(r) })), e } const Qle = (function () { function e(t) { Fle(this, e), t = t || {}, t.colors && (t.colors = Object.assign({}, Bm.colors, t.colors)), this.options = Object.assign({}, Bm, t), this.stack = [], this.stickyStack = [] } return qle(e, [{ key: 'toHtml', value(r) { const o = this; r = typeof r == 'string' ? [r] : r; const s = this.stack; const c = this.options; const f = []; return this.stickyStack.forEach((d) => { const h = Wm(s, d.token, d.data, c); h && f.push(h) }), Zle(r.join(''), c, (d, h) => { const g = Wm(s, d, h, c); g && f.push(g), c.stream && (o.stickyStack = Jle(o.stickyStack, d, h)) }), s.length && f.push(lw(s)), f.join('') } }]), e }()); const eae = Qle; const tae = Vb(eae); const nae = /^[A-Z]:\//i; function rae(e = '') { return e && e.replace(/\\/g, '/').replace(nae, t => t.toUpperCase()) } const iae = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Z]:[/\\]/i; function oae() { return typeof process < 'u' && typeof process.cwd == 'function' ? process.cwd().replace(/\\/g, '/') : '/' } const sae = function (...e) { e = e.map(o => rae(o)); let t = ''; let r = !1; for (let o = e.length - 1; o >= -1 && !r; o--) { const s = o >= 0 ? e[o] : oae(); !s || s.length === 0 || (t = `${s}/${t}`, r = jm(s)) } return t = lae(t, !r), r && !jm(t) ? `/${t}` : t.length > 0 ? t : '.' }; function lae(e, t) {
  let r = ''; let o = 0; let s = -1; let c = 0; let f = null; for (let d = 0; d <= e.length; ++d) {
    if (d < e.length) {
      f = e[d]
    }
    else {
      if (f === '/')
        break; f = '/'
    } if (f === '/') {
      if (!(s === d - 1 || c === 1)) {
        if (c === 2) {
          if (r.length < 2 || o !== 2 || r[r.length - 1] !== '.' || r[r.length - 2] !== '.') {
            if (r.length > 2) { const h = r.lastIndexOf('/'); h === -1 ? (r = '', o = 0) : (r = r.slice(0, h), o = r.length - 1 - r.lastIndexOf('/')), s = d, c = 0; continue }
            else if (r.length > 0) { r = '', o = 0, s = d, c = 0; continue }
          }t && (r += r.length > 0 ? '/..' : '..', o = 2)
        }
        else {
          r.length > 0 ? r += `/${e.slice(s + 1, d)}` : r = e.slice(s + 1, d), o = d - s - 1
        }
      }s = d, c = 0
    }
    else {
      f === '.' && c !== -1 ? ++c : c = -1
    }
  } return r
} const jm = function (e) { return iae.test(e) }; const aae = 44; const Gm = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; const cae = new Uint8Array(64); const aw = new Uint8Array(128); for (let e = 0; e < Gm.length; e++) { const t = Gm.charCodeAt(e); cae[e] = t, aw[t] = e } function uae(e) { const t = new Int32Array(5); const r = []; let o = 0; do { const s = fae(e, o); const c = []; let f = !0; let d = 0; t[0] = 0; for (let h = o; h < s; h++) { let g; h = gl(e, h, t, 0); const v = t[0]; v < d && (f = !1), d = v, Km(e, h, s) ? (h = gl(e, h, t, 1), h = gl(e, h, t, 2), h = gl(e, h, t, 3), Km(e, h, s) ? (h = gl(e, h, t, 4), g = [v, t[1], t[2], t[3], t[4]]) : g = [v, t[1], t[2], t[3]]) : g = [v], c.push(g) }f || dae(c), r.push(c), o = s + 1 } while (o <= e.length); return r } function fae(e, t) { const r = e.indexOf(';', t); return r === -1 ? e.length : r } function gl(e, t, r, o) { let s = 0; let c = 0; let f = 0; do { const h = e.charCodeAt(t++); f = aw[h], s |= (f & 31) << c, c += 5 } while (f & 32); const d = s & 1; return s >>>= 1, d && (s = -2147483648 | -s), r[o] += s, t } function Km(e, t, r) { return t >= r ? !1 : e.charCodeAt(t) !== aae } function dae(e) { e.sort(hae) } function hae(e, t) { return e[0] - t[0] } const pae = /^[\w+.-]+:\/\//; const gae = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/; const vae = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?([^#?]*)(\?[^#]*)?(#.*)?/i; let zt; (function (e) { e[e.Empty = 1] = 'Empty', e[e.Hash = 2] = 'Hash', e[e.Query = 3] = 'Query', e[e.RelativePath = 4] = 'RelativePath', e[e.AbsolutePath = 5] = 'AbsolutePath', e[e.SchemeRelative = 6] = 'SchemeRelative', e[e.Absolute = 7] = 'Absolute' })(zt || (zt = {})); function mae(e) { return pae.test(e) } function yae(e) { return e.startsWith('//') } function cw(e) { return e.startsWith('/') } function bae(e) { return e.startsWith('file:') } function Xm(e) { return /^[.?#]/.test(e) } function lc(e) { const t = gae.exec(e); return uw(t[1], t[2] || '', t[3], t[4] || '', t[5] || '/', t[6] || '', t[7] || '') } function wae(e) { const t = vae.exec(e); const r = t[2]; return uw('file:', '', t[1] || '', '', cw(r) ? r : `/${r}`, t[3] || '', t[4] || '') } function uw(e, t, r, o, s, c, f) { return { scheme: e, user: t, host: r, port: o, path: s, query: c, hash: f, type: zt.Absolute } } function Ym(e) {
  if (yae(e)) { const r = lc(`http:${e}`); return r.scheme = '', r.type = zt.SchemeRelative, r } if (cw(e)) { const r = lc(`http://foo.com${e}`); return r.scheme = '', r.host = '', r.type = zt.AbsolutePath, r } if (bae(e))
    return wae(e); if (mae(e))
    return lc(e); const t = lc(`http://foo.com/${e}`); return t.scheme = '', t.host = '', t.type = e ? e.startsWith('?') ? zt.Query : e.startsWith('#') ? zt.Hash : zt.RelativePath : zt.Empty, t
} function xae(e) {
  if (e.endsWith('/..'))
    return e; const t = e.lastIndexOf('/'); return e.slice(0, t + 1)
} function _ae(e, t) { fw(t, t.type), e.path === '/' ? e.path = t.path : e.path = xae(t.path) + e.path } function fw(e, t) { const r = t <= zt.RelativePath; const o = e.path.split('/'); let s = 1; let c = 0; let f = !1; for (let h = 1; h < o.length; h++) { const g = o[h]; if (!g) { f = !0; continue } if (f = !1, g !== '.') { if (g === '..') { c ? (f = !0, c--, s--) : r && (o[s++] = g); continue }o[s++] = g, c++ } } let d = ''; for (let h = 1; h < s; h++)d += `/${o[h]}`; (!d || f && !d.endsWith('/..')) && (d += '/'), e.path = d } function Sae(e, t) {
  if (!e && !t)
    return ''; const r = Ym(e); let o = r.type; if (t && o !== zt.Absolute) { const c = Ym(t); const f = c.type; switch (o) { case zt.Empty:r.hash = c.hash; case zt.Hash:r.query = c.query; case zt.Query:case zt.RelativePath:_ae(r, c); case zt.AbsolutePath:r.user = c.user, r.host = c.host, r.port = c.port; case zt.SchemeRelative:r.scheme = c.scheme }f > o && (o = f) }fw(r, o); const s = r.query + r.hash; switch (o) { case zt.Hash:case zt.Query:return s; case zt.RelativePath:{ const c = r.path.slice(1); return c ? Xm(t || e) && !Xm(c) ? `./${c}${s}` : c + s : s || '.' } case zt.AbsolutePath:return r.path + s; default:return `${r.scheme}//${r.user}${r.host}${r.port}${r.path}${s}` }
} function Zm(e, t) { return t && !t.endsWith('/') && (t += '/'), Sae(e, t) } function kae(e) {
  if (!e)
    return ''; const t = e.lastIndexOf('/'); return e.slice(0, t + 1)
} const Yi = 0; const Cae = 1; const Tae = 2; const Eae = 3; const Lae = 4; function Aae(e, t) {
  const r = Jm(e, 0); if (r === e.length)
    return e; t || (e = e.slice()); for (let o = r; o < e.length; o = Jm(e, o + 1))e[o] = Nae(e[o], t); return e
} function Jm(e, t) {
  for (let r = t; r < e.length; r++) {
    if (!Mae(e[r]))
      return r
  } return e.length
} function Mae(e) {
  for (let t = 1; t < e.length; t++) {
    if (e[t][Yi] < e[t - 1][Yi])
      return !1
  } return !0
} function Nae(e, t) { return t || (e = e.slice()), e.sort($ae) } function $ae(e, t) { return e[Yi] - t[Yi] } let Yc = !1; function Oae(e, t, r, o) {
  for (;r <= o;) {
    const s = r + (o - r >> 1); const c = e[s][Yi] - t; if (c === 0)
      return Yc = !0, s; c < 0 ? r = s + 1 : o = s - 1
  } return Yc = !1, r - 1
} function Pae(e, t, r) { for (let o = r + 1; o < e.length && e[o][Yi] === t; r = o++);return r } function Rae(e, t, r) { for (let o = r - 1; o >= 0 && e[o][Yi] === t; r = o--);return r } function Dae() { return { lastKey: -1, lastNeedle: -1, lastIndex: -1 } } function zae(e, t, r, o) {
  const { lastKey: s, lastNeedle: c, lastIndex: f } = r; let d = 0; let h = e.length - 1; if (o === s) {
    if (t === c)
      return Yc = f !== -1 && e[f][Yi] === t, f; t >= c ? d = f === -1 ? 0 : f : h = f
  } return r.lastKey = o, r.lastNeedle = t, r.lastIndex = Oae(e, t, d, h)
} const Iae = '`line` must be greater than 0 (lines start at line 1)'; const Fae = '`column` must be greater than or equal to 0 (columns start at column 0)'; const Qm = -1; const Hae = 1; class qae {
  constructor(t, r) {
    const o = typeof t == 'string'; if (!o && t._decodedMemo)
      return t; const s = o ? JSON.parse(t) : t; const { version: c, file: f, names: d, sourceRoot: h, sources: g, sourcesContent: v } = s; this.version = c, this.file = f, this.names = d || [], this.sourceRoot = h, this.sources = g, this.sourcesContent = v, this.ignoreList = s.ignoreList || s.x_google_ignoreList || void 0; const y = Zm(h || '', kae(r)); this.resolvedSources = g.map(x => Zm(x || '', y)); const { mappings: b } = s; typeof b == 'string' ? (this._encoded = b, this._decoded = void 0) : (this._encoded = void 0, this._decoded = Aae(b, o)), this._decodedMemo = Dae(), this._bySources = void 0, this._bySourceMemos = void 0
  }
} function Bae(e) { let t; return (t = e)._decoded || (t._decoded = uae(e._encoded)) } function Wae(e, t) {
  let { line: r, column: o, bias: s } = t; if (r--, r < 0)
    throw new Error(Iae); if (o < 0)
    throw new Error(Fae); const c = Bae(e); if (r >= c.length)
    return ac(null, null, null, null); const f = c[r]; const d = Uae(f, e._decodedMemo, r, o, s || Hae); if (d === -1)
    return ac(null, null, null, null); const h = f[d]; if (h.length === 1)
    return ac(null, null, null, null); const { names: g, resolvedSources: v } = e; return ac(v[h[Cae]], h[Tae] + 1, h[Eae], h.length === 5 ? g[h[Lae]] : null)
} function ac(e, t, r, o) { return { source: e, line: t, column: r, name: o } } function Uae(e, t, r, o, s) { let c = zae(e, o, t, r); return Yc ? c = (s === Qm ? Pae : Rae)(e, o, c) : s === Qm && c++, c === -1 || c === e.length ? -1 : c } const dw = /^\s*at .*(?:\S:\d+|\(native\))/m; const Vae = /^(?:eval@)?(?:\[native code\])?$/; const jae = ['node:internal', /\/packages\/\w+\/dist\//, /\/@vitest\/\w+\/dist\//, '/vitest/dist/', '/vitest/src/', '/vite-node/dist/', '/vite-node/src/', '/node_modules/chai/', '/node_modules/tinypool/', '/node_modules/tinyspy/', '/deps/chunk-', '/deps/@vitest', '/deps/loupe', '/deps/chai', /node:\w+/, /__vitest_test__/, /__vitest_browser__/, /\/deps\/vitest_/]; function hw(e) {
  if (!e.includes(':'))
    return [e]; const r = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/^\(|\)$/g, '')); if (!r)
    return [e]; let o = r[1]; if (o.startsWith('async ') && (o = o.slice(6)), (o.startsWith('http:') || o.startsWith('https:')) && (o = new URL(o).pathname), o.startsWith('/@fs/')) { const s = /^\/@fs\/[a-zA-Z]:\//.test(o); o = o.slice(s ? 5 : 4) } return [o, r[2] || void 0, r[3] || void 0]
} function Gae(e) {
  let t = e.trim(); if (Vae.test(t) || (t.includes(' > eval') && (t = t.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1')), !t.includes('@') && !t.includes(':')))
    return null; const r = /(([^\n\r"\u2028\u2029]*".[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*(?:@[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*)*(?:[\n\r\u2028\u2029][^@]*)?)?[^@]*)(@)/; const o = t.match(r); const s = o && o[1] ? o[1] : void 0; const [c, f, d] = hw(t.replace(r, '')); return !c || !f || !d ? null : { file: c, method: s || '', line: Number.parseInt(f), column: Number.parseInt(d) }
} function Kae(e) {
  let t = e.trim(); if (!dw.test(t))
    return null; t.includes('(eval ') && (t = t.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(,.*$)/g, '')); let r = t.replace(/^\s+/, '').replace(/\(eval code/g, '(').replace(/^.*?\s+/, ''); const o = r.match(/ (\(.+\)$)/); r = o ? r.replace(o[0], '') : r; const [s, c, f] = hw(o ? o[1] : r); let d = o && r || ''; let h = s && ['eval', '<anonymous>'].includes(s) ? void 0 : s; return !h || !c || !f ? null : (d.startsWith('async ') && (d = d.slice(6)), h.startsWith('file://') && (h = h.slice(7)), h = sae(h), d && (d = d.replace(/__vite_ssr_import_\d+__\./g, '')), { method: d, file: h, line: Number.parseInt(c), column: Number.parseInt(f) })
} function Xae(e, t = {}) {
  const { ignoreStackEntries: r = jae } = t; let o = dw.test(e) ? Zae(e) : Yae(e); return r.length && (o = o.filter(s => !r.some(c => s.file.match(c)))), o.map((s) => {
    let c; t.getFileName && (s.file = t.getFileName(s.file)); const f = (c = t.getSourceMap) == null ? void 0 : c.call(t, s.file); if (!f || typeof f != 'object' || !f.version)
      return s; const d = new qae(f); const { line: h, column: g } = Wae(d, s); return h != null && g != null ? { ...s, line: h, column: g } : s
  })
} function Yae(e) {
  return e.split(`
`).map(t => Gae(t)).filter(qb)
} function Zae(e) {
  return e.split(`
`).map(t => Kae(t)).filter(qb)
} function Jae(e, t) { return t && e.endsWith(t) } async function pw(e, t, r) { const o = encodeURI(`${e}:${t}:${r}`); await fetch(`/__open-in-editor?file=${o}`) } function Bh(e) { return new tae({ fg: e ? '#FFF' : '#000', bg: e ? '#000' : '#FFF' }) } function Qae(e) { return e === null || typeof e != 'function' && typeof e != 'object' } function gw(e) { let t = e; if (Qae(e) && (t = { message: String(t).split(/\n/)[0], stack: String(t), name: '' }), !e) { const r = new Error('unknown error'); t = { message: r.message, stack: r.stack, name: '' } } return t.stacks = Xae(t.stack || t.stackStr || '', { ignoreStackEntries: [] }), t } function Ou(e) { return U0() ? (rS(e), !0) : !1 } function li(e) { return typeof e == 'function' ? e() : q(e) } const ece = typeof window < 'u' && typeof document < 'u'; typeof WorkerGlobalScope < 'u' && globalThis instanceof WorkerGlobalScope; const tce = Object.prototype.toString; const nce = e => tce.call(e) === '[object Object]'; function Zl() {} function vw(e, t) { function r(...o) { return new Promise((s, c) => { Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(s).catch(c) }) } return r } const mw = e => e(); function yw(e, t = {}) { let r; let o; let s = Zl; const c = (d) => { clearTimeout(d), s(), s = Zl }; return (d) => { const h = li(e); const g = li(t.maxWait); return r && c(r), h <= 0 || g !== void 0 && g <= 0 ? (o && (c(o), o = null), Promise.resolve(d())) : new Promise((v, y) => { s = t.rejectOnCancel ? y : v, g && !o && (o = setTimeout(() => { r && c(r), o = null, v(d()) }, g)), r = setTimeout(() => { o && c(o), o = null, v(d()) }, h) }) } } function rce(e = mw) { const t = Be(!0); function r() { t.value = !1 } function o() { t.value = !0 } const s = (...c) => { t.value && e(...c) }; return { isActive: oa(t), pause: r, resume: o, eventFilter: s } } function ice(e) { return ca() } function oce(...e) {
  if (e.length !== 1)
    return gu(...e); const t = e[0]; return typeof t == 'function' ? oa(sy(() => ({ get: t, set: Zl }))) : Be(t)
} function e0(e, t = 200, r = {}) { return vw(yw(t, r), e) } function bw(e, t, r = {}) { const { eventFilter: o = mw, ...s } = r; return Ht(e, vw(o, t), s) } function ww(e, t, r = {}) { const { eventFilter: o, ...s } = r; const { eventFilter: c, pause: f, resume: d, isActive: h } = rce(o); return { stop: bw(e, t, { ...s, eventFilter: c }), pause: f, resume: d, isActive: h } } function Wh(e, t = !0, r) { ice() ? Os(e, r) : t ? e() : ln(e) } function sce(e = !1, t = {}) {
  const { truthyValue: r = !0, falsyValue: o = !1 } = t; const s = Ot(e); const c = Be(e); function f(d) {
    if (arguments.length)
      return c.value = d, c.value; { const h = li(r); return c.value = c.value === h ? li(o) : h, c.value }
  } return s ? f : [c, f]
} function xw(e, t, r = {}) { const { debounce: o = 0, maxWait: s = void 0, ...c } = r; return bw(e, t, { ...c, eventFilter: yw(o, { maxWait: s }) }) } function lce(e, t, r) { const o = Ht(e, (...s) => (ln(() => o()), t(...s)), r); return o } function ace(e, t, r) {
  let o; Ot(r) ? o = { evaluating: r } : o = {}; const { lazy: s = !1, evaluating: c = void 0, shallow: f = !0, onError: d = Zl } = o; const h = Be(!s); const g = f ? Fr(t) : Be(t); let v = 0; return Ch(async (y) => {
    if (!h.value)
      return; v++; const b = v; let x = !1; c && Promise.resolve().then(() => { c.value = !0 }); try { const T = await e((E) => { y(() => { c && (c.value = !1), x || E() }) }); b === v && (g.value = T) }
    catch (T) { d(T) }
    finally { c && b === v && (c.value = !1), x = !0 }
  }), s ? Me(() => (h.value = !0, g.value)) : g
} function Zc(e) { let t; const r = li(e); return (t = r == null ? void 0 : r.$el) != null ? t : r } const rr = ece ? window : void 0; function Ls(...e) {
  let t, r, o, s; if (typeof e[0] == 'string' || Array.isArray(e[0]) ? ([r, o, s] = e, t = rr) : [t, r, o, s] = e, !t)
    return Zl; Array.isArray(r) || (r = [r]), Array.isArray(o) || (o = [o]); const c = []; const f = () => { c.forEach(v => v()), c.length = 0 }; const d = (v, y, b, x) => (v.addEventListener(y, b, x), () => v.removeEventListener(y, b, x)); const h = Ht(() => [Zc(t), li(s)], ([v, y]) => {
    if (f(), !v)
      return; const b = nce(y) ? { ...y } : y; c.push(...r.flatMap(x => o.map(T => d(v, x, T, b))))
  }, { immediate: !0, flush: 'post' }); const g = () => { h(), f() }; return Ou(g), g
} function cce(e) { return typeof e == 'function' ? e : typeof e == 'string' ? t => t.key === e : Array.isArray(e) ? t => e.includes(t.key) : () => !0 } function _w(...e) { let t; let r; let o = {}; e.length === 3 ? (t = e[0], r = e[1], o = e[2]) : e.length === 2 ? typeof e[1] == 'object' ? (t = !0, r = e[0], o = e[1]) : (t = e[0], r = e[1]) : (t = !0, r = e[0]); const { target: s = rr, eventName: c = 'keydown', passive: f = !1, dedupe: d = !1 } = o; const h = cce(t); return Ls(s, c, (v) => { v.repeat && li(d) || h(v) && r(v) }, f) } function uce() { const e = Be(!1); const t = ca(); return t && Os(() => { e.value = !0 }, t), e } function Sw(e) { const t = uce(); return Me(() => (t.value, !!e())) } function fce(e, t = {}) {
  const { immediate: r = !0, fpsLimit: o = void 0, window: s = rr } = t; const c = Be(!1); const f = o ? 1e3 / o : null; let d = 0; let h = null; function g(b) {
    if (!c.value || !s)
      return; d || (d = b); const x = b - d; if (f && x < f) { h = s.requestAnimationFrame(g); return }d = b, e({ delta: x, timestamp: b }), h = s.requestAnimationFrame(g)
  } function v() { !c.value && s && (c.value = !0, d = 0, h = s.requestAnimationFrame(g)) } function y() { c.value = !1, h != null && s && (s.cancelAnimationFrame(h), h = null) } return r && v(), Ou(y), { isActive: oa(c), pause: y, resume: v }
} function kw(e, t = {}) { const { window: r = rr } = t; const o = Sw(() => r && 'matchMedia' in r && typeof r.matchMedia == 'function'); let s; const c = Be(!1); const f = (g) => { c.value = g.matches }; const d = () => { s && ('removeEventListener' in s ? s.removeEventListener('change', f) : s.removeListener(f)) }; const h = Ch(() => { o.value && (d(), s = r.matchMedia(li(e)), 'addEventListener' in s ? s.addEventListener('change', f) : s.addListener(f), c.value = s.matches) }); return Ou(() => { h(), d(), s = void 0 }), c } const cc = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {}; const uc = '__vueuse_ssr_handlers__'; const dce = hce(); function hce() { return uc in cc || (cc[uc] = cc[uc] || {}), cc[uc] } function Cw(e, t) { return dce[e] || t } function pce(e) { return e == null ? 'any' : e instanceof Set ? 'set' : e instanceof Map ? 'map' : e instanceof Date ? 'date' : typeof e == 'boolean' ? 'boolean' : typeof e == 'string' ? 'string' : typeof e == 'object' ? 'object' : Number.isNaN(e) ? 'any' : 'number' } const gce = { boolean: { read: e => e === 'true', write: e => String(e) }, object: { read: e => JSON.parse(e), write: e => JSON.stringify(e) }, number: { read: e => Number.parseFloat(e), write: e => String(e) }, any: { read: e => e, write: e => String(e) }, string: { read: e => e, write: e => String(e) }, map: { read: e => new Map(JSON.parse(e)), write: e => JSON.stringify(Array.from(e.entries())) }, set: { read: e => new Set(JSON.parse(e)), write: e => JSON.stringify(Array.from(e)) }, date: { read: e => new Date(e), write: e => e.toISOString() } }; const t0 = 'vueuse-storage'; function Tw(e, t, r, o = {}) {
  let s; const { flush: c = 'pre', deep: f = !0, listenToStorageChanges: d = !0, writeDefaults: h = !0, mergeDefaults: g = !1, shallow: v, window: y = rr, eventFilter: b, onError: x = (j) => { console.error(j) }, initOnMounted: T } = o; const E = (v ? Fr : Be)(typeof t == 'function' ? t() : t); if (!r) {
    try { r = Cw('getDefaultStorage', () => { let j; return (j = rr) == null ? void 0 : j.localStorage })() }
    catch (j) { x(j) }
  } if (!r)
    return E; const M = li(t); const N = pce(M); const L = (s = o.serializer) != null ? s : gce[N]; const { pause: O, resume: A } = ww(E, () => z(E.value), { flush: c, deep: f, eventFilter: b }); y && d && Wh(() => { Ls(y, 'storage', re), Ls(y, t0, te), T && re() }), T || re(); function H(j, ne) { y && y.dispatchEvent(new CustomEvent(t0, { detail: { key: e, oldValue: j, newValue: ne, storageArea: r } })) } function z(j) {
    try {
      const ne = r.getItem(e); if (j == null) {
        H(ne, null), r.removeItem(e)
      }
      else { const K = L.write(j); ne !== K && (r.setItem(e, K), H(ne, K)) }
    }
    catch (ne) { x(ne) }
  } function J(j) {
    const ne = j ? j.newValue : r.getItem(e); if (ne == null)
      return h && M != null && r.setItem(e, L.write(M)), M; if (!j && g) { const K = L.read(ne); return typeof g == 'function' ? g(K, M) : N === 'object' && !Array.isArray(K) ? { ...M, ...K } : K }
    else {
      return typeof ne != 'string' ? ne : L.read(ne)
    }
  } function re(j) {
    if (!(j && j.storageArea !== r)) {
      if (j && j.key == null) { E.value = M; return } if (!(j && j.key !== e)) {
        O(); try { (j == null ? void 0 : j.newValue) !== L.write(E.value) && (E.value = J(j)) }
        catch (ne) { x(ne) }
        finally { j ? ln(A) : A() }
      }
    }
  } function te(j) { re(j.detail) } return E
} function Ew(e) { return kw('(prefers-color-scheme: dark)', e) } function vce(e = {}) {
  const { selector: t = 'html', attribute: r = 'class', initialValue: o = 'auto', window: s = rr, storage: c, storageKey: f = 'vueuse-color-scheme', listenToStorageChanges: d = !0, storageRef: h, emitAuto: g, disableTransition: v = !0 } = e; const y = { auto: '', light: 'light', dark: 'dark', ...e.modes || {} }; const b = Ew({ window: s }); const x = Me(() => b.value ? 'dark' : 'light'); const T = h || (f == null ? oce(o) : Tw(f, o, c, { window: s, listenToStorageChanges: d })); const E = Me(() => T.value === 'auto' ? x.value : T.value); const M = Cw('updateHTMLAttrs', (A, H, z) => {
    const J = typeof A == 'string' ? s == null ? void 0 : s.document.querySelector(A) : Zc(A); if (!J)
      return; let re; if (v && (re = s.document.createElement('style'), re.appendChild(document.createTextNode('*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}')), s.document.head.appendChild(re)), H === 'class') { const te = z.split(/\s/g); Object.values(y).flatMap(j => (j || '').split(/\s/g)).filter(Boolean).forEach((j) => { te.includes(j) ? J.classList.add(j) : J.classList.remove(j) }) }
    else {
      J.setAttribute(H, z)
    }v && (s.getComputedStyle(re).opacity, document.head.removeChild(re))
  }); function N(A) { let H; M(t, r, (H = y[A]) != null ? H : A) } function L(A) { e.onChanged ? e.onChanged(A, N) : N(A) }Ht(E, L, { flush: 'post', immediate: !0 }), Wh(() => L(E.value)); const O = Me({ get() { return g ? T.value : E.value }, set(A) { T.value = A } }); try { return Object.assign(O, { store: T, system: x, state: E }) }
  catch { return O }
} function mce(e = {}) { const { valueDark: t = 'dark', valueLight: r = '', window: o = rr } = e; const s = vce({ ...e, onChanged: (d, h) => { let g; e.onChanged ? (g = e.onChanged) == null || g.call(e, d === 'dark', h, d) : h(d) }, modes: { dark: t, light: r } }); const c = Me(() => s.system ? s.system.value : Ew({ window: o }).value ? 'dark' : 'light'); return Me({ get() { return s.value === 'dark' }, set(d) { const h = d ? 'dark' : 'light'; c.value === h ? s.value = 'auto' : s.value = h } }) } function Lw(e, t, r = {}) { const { window: o = rr, ...s } = r; let c; const f = Sw(() => o && 'ResizeObserver' in o); const d = () => { c && (c.disconnect(), c = void 0) }; const h = Me(() => Array.isArray(e) ? e.map(y => Zc(y)) : [Zc(e)]); const g = Ht(h, (y) => { if (d(), f.value && o) { c = new ResizeObserver(t); for (const b of y)b && c.observe(b, s) } }, { immediate: !0, flush: 'post' }); const v = () => { d(), g() }; return Ou(v), { isSupported: f, stop: v } } function Pu(e, t, r = {}) { const { window: o = rr } = r; return Tw(e, t, o == null ? void 0 : o.localStorage, r) } function yce(e = 'history', t = {}) {
  const { initialValue: r = {}, removeNullishValues: o = !0, removeFalsyValues: s = !1, write: c = !0, window: f = rr } = t; if (!f)
    return er(r); const d = er({}); function h() {
    if (e === 'history')
      return f.location.search || ''; if (e === 'hash') { const N = f.location.hash || ''; const L = N.indexOf('?'); return L > 0 ? N.slice(L) : '' }
    else {
      return (f.location.hash || '').replace(/^#/, '')
    }
  } function g(N) {
    const L = N.toString(); if (e === 'history')
      return `${L ? `?${L}` : ''}${f.location.hash || ''}`; if (e === 'hash-params')
      return `${f.location.search || ''}${L ? `#${L}` : ''}`; const O = f.location.hash || '#'; const A = O.indexOf('?'); return A > 0 ? `${O.slice(0, A)}${L ? `?${L}` : ''}` : `${O}${L ? `?${L}` : ''}`
  } function v() { return new URLSearchParams(h()) } function y(N) { const L = new Set(Object.keys(d)); for (const O of N.keys()) { const A = N.getAll(O); d[O] = A.length > 1 ? A : N.get(O) || '', L.delete(O) }Array.from(L).forEach(O => delete d[O]) } const { pause: b, resume: x } = ww(d, () => { const N = new URLSearchParams(''); Object.keys(d).forEach((L) => { const O = d[L]; Array.isArray(O) ? O.forEach(A => N.append(L, A)) : o && O == null || s && !O ? N.delete(L) : N.set(L, O) }), T(N) }, { deep: !0 }); function T(N, L) { b(), L && y(N), f.history.replaceState(f.history.state, f.document.title, f.location.pathname + g(N)), x() } function E() { c && T(v(), !0) }Ls(f, 'popstate', E, !1), e !== 'history' && Ls(f, 'hashchange', E, !1); const M = v(); return M.keys().next().value ? y(M) : Object.assign(d, r), d
} function bce(e = {}) { const { window: t = rr, initialWidth: r = Number.POSITIVE_INFINITY, initialHeight: o = Number.POSITIVE_INFINITY, listenOrientation: s = !0, includeScrollbar: c = !0 } = e; const f = Be(r); const d = Be(o); const h = () => { t && (c ? (f.value = t.innerWidth, d.value = t.innerHeight) : (f.value = t.document.documentElement.clientWidth, d.value = t.document.documentElement.clientHeight)) }; if (h(), Wh(h), Ls('resize', h, { passive: !0 }), s) { const g = kw('(orientation: portrait)'); Ht(g, () => h()) } return { width: f, height: d } } const Uh = yce('hash', { initialValue: { file: '', view: null, line: null } }); const Zi = gu(Uh, 'file'); const Bn = gu(Uh, 'view'); const Rd = gu(Uh, 'line'); const jn = Uint8Array; const cs = Uint16Array; const wce = Int32Array; const Aw = new jn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]); const Mw = new jn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]); const xce = new jn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); const Nw = function (e, t) {
  for (var r = new cs(31), o = 0; o < 31; ++o)r[o] = t += 1 << e[o - 1]; for (var s = new wce(r[30]), o = 1; o < 30; ++o) {
    for (let c = r[o]; c < r[o + 1]; ++c)s[c] = c - r[o] << 5 | o
  } return { b: r, r: s }
}; const $w = Nw(Aw, 2); const Ow = $w.b; const _ce = $w.r; Ow[28] = 258, _ce[258] = 28; const Sce = Nw(Mw, 0); const kce = Sce.b; const Dd = new cs(32768); for (var Ct = 0; Ct < 32768; ++Ct) { let Ni = (Ct & 43690) >> 1 | (Ct & 21845) << 1; Ni = (Ni & 52428) >> 2 | (Ni & 13107) << 2, Ni = (Ni & 61680) >> 4 | (Ni & 3855) << 4, Dd[Ct] = ((Ni & 65280) >> 8 | (Ni & 255) << 8) >> 1 } const Rl = function (e, t, r) {
  for (var o = e.length, s = 0, c = new cs(t); s < o; ++s)e[s] && ++c[e[s] - 1]; const f = new cs(t); for (s = 1; s < t; ++s)f[s] = f[s - 1] + c[s - 1] << 1; let d; if (r) {
    d = new cs(1 << t); const h = 15 - t; for (s = 0; s < o; ++s) {
      if (e[s]) {
        for (let g = s << 4 | e[s], v = t - e[s], y = f[e[s] - 1]++ << v, b = y | (1 << v) - 1; y <= b; ++y)d[Dd[y] >> h] = g
      }
    }
  }
  else {
    for (d = new cs(o), s = 0; s < o; ++s)e[s] && (d[s] = Dd[f[e[s] - 1]++] >> 15 - e[s])
  } return d
}; const ha = new jn(288); for (var Ct = 0; Ct < 144; ++Ct)ha[Ct] = 8; for (var Ct = 144; Ct < 256; ++Ct)ha[Ct] = 9; for (var Ct = 256; Ct < 280; ++Ct)ha[Ct] = 7; for (var Ct = 280; Ct < 288; ++Ct)ha[Ct] = 8; const Pw = new jn(32); for (var Ct = 0; Ct < 32; ++Ct)Pw[Ct] = 5; const Cce = Rl(ha, 9, 1); const Tce = Rl(Pw, 5, 1); const Qf = function (e) { for (var t = e[0], r = 1; r < e.length; ++r)e[r] > t && (t = e[r]); return t }; const vr = function (e, t, r) { const o = t / 8 | 0; return (e[o] | e[o + 1] << 8) >> (t & 7) & r }; const ed = function (e, t) { const r = t / 8 | 0; return (e[r] | e[r + 1] << 8 | e[r + 2] << 16) >> (t & 7) }; const Ece = function (e) { return (e + 7) / 8 | 0 }; const Rw = function (e, t, r) { return (t == null || t < 0) && (t = 0), (r == null || r > e.length) && (r = e.length), new jn(e.subarray(t, r)) }; const Lce = ['unexpected EOF', 'invalid block type', 'invalid length/literal', 'invalid distance', 'stream finished', 'no stream handler',,'no callback', 'invalid UTF-8 data', 'extra field too long', 'date not in range 1980-2099', 'filename too long', 'stream finishing', 'invalid zip data']; const $n = function (e, t, r) {
  const o = new Error(t || Lce[e]); if (o.code = e, Error.captureStackTrace && Error.captureStackTrace(o, $n), !r)
    throw o; return o
}; const Vh = function (e, t, r, o) {
  const s = e.length; const c = 0; if (!s || t.f && !t.l)
    return r || new jn(0); const f = !r; const d = f || t.i != 2; const h = t.i; f && (r = new jn(s * 3)); const g = function (Te) { const Ye = r.length; if (Te > Ye) { const P = new jn(Math.max(Ye * 2, Te)); P.set(r), r = P } }; let v = t.f || 0; let y = t.p || 0; let b = t.b || 0; let x = t.l; let T = t.d; let E = t.m; let M = t.n; const N = s * 8; do {
    if (!x) {
      v = vr(e, y, 1); const L = vr(e, y + 1, 3); if (y += 3, L) {
        if (L == 1) {
          x = Cce, T = Tce, E = 9, M = 5
        }
        else if (L == 2) {
          const z = vr(e, y, 31) + 257; const J = vr(e, y + 10, 15) + 4; const re = z + vr(e, y + 5, 31) + 1; y += 14; for (var te = new jn(re), j = new jn(19), ne = 0; ne < J; ++ne)j[xce[ne]] = vr(e, y + ne * 3, 7); y += J * 3; for (var K = Qf(j), V = (1 << K) - 1, I = Rl(j, K, 1), ne = 0; ne < re;) {
            const k = I[vr(e, y, V)]; y += k & 15; var O = k >> 4; if (O < 16) {
              te[ne++] = O
            }
            else { var B = 0; let W = 0; for (O == 16 ? (W = 3 + vr(e, y, 3), y += 2, B = te[ne - 1]) : O == 17 ? (W = 3 + vr(e, y, 7), y += 3) : O == 18 && (W = 11 + vr(e, y, 127), y += 7); W--;)te[ne++] = B }
          } const ie = te.subarray(0, z); var ye = te.subarray(z); E = Qf(ie), M = Qf(ye), x = Rl(ie, E, 1), T = Rl(ye, M, 1)
        }
        else {
          $n(1)
        }
      }
      else { var O = Ece(y) + 4; const A = e[O - 4] | e[O - 3] << 8; const H = O + A; if (H > s) { h && $n(0); break }d && g(b + A), r.set(e.subarray(O, H), b), t.b = b += A, t.p = y = H * 8, t.f = v; continue } if (y > N) { h && $n(0); break }
    }d && g(b + 131072); for (var Ne = (1 << E) - 1, We = (1 << M) - 1, je = y; ;je = y) {
      var B = x[ed(e, y) & Ne]; const it = B >> 4; if (y += B & 15, y > N) { h && $n(0); break } if (B || $n(2), it < 256) {
        r[b++] = it
      }
      else if (it == 256) { je = y, x = null; break }
      else { let rt = it - 254; if (it > 264) { var ne = it - 257; var Ze = Aw[ne]; rt = vr(e, y, (1 << Ze) - 1) + Ow[ne], y += Ze } const Ee = T[ed(e, y) & We]; const X = Ee >> 4; Ee || $n(3), y += Ee & 15; var ye = kce[X]; if (X > 3) { var Ze = Mw[X]; ye += ed(e, y) & (1 << Ze) - 1, y += Ze } if (y > N) { h && $n(0); break }d && g(b + 131072); const ae = b + rt; if (b < ye) { const de = c - ye; const $e = Math.min(ye, ae); for (de + b < 0 && $n(3); b < $e; ++b)r[b] = o[de + b] } for (;b < ae; ++b)r[b] = r[b - ye] }
    }t.l = x, t.p = je, t.b = b, t.f = v, x && (v = 1, t.m = E, t.d = T, t.n = M)
  } while (!v); return b != r.length && f ? Rw(r, 0, b) : r.subarray(0, b)
}; const Ace = new jn(0); const Mce = function (e) { (e[0] != 31 || e[1] != 139 || e[2] != 8) && $n(6, 'invalid gzip data'); const t = e[3]; let r = 10; t & 4 && (r += (e[10] | e[11] << 8) + 2); for (let o = (t >> 3 & 1) + (t >> 4 & 1); o > 0; o -= !e[r++]);return r + (t & 2) }; const Nce = function (e) { const t = e.length; return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0 }; const $ce = function (e, t) { return ((e[0] & 15) != 8 || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31) && $n(6, 'invalid zlib data'), (e[1] >> 5 & 1) == +!t && $n(6, `invalid zlib data: ${e[1] & 32 ? 'need' : 'unexpected'} dictionary`), (e[1] >> 3 & 4) + 2 }; function Oce(e, t) { return Vh(e, { i: 2 }, t, t) } function Pce(e, t) { const r = Mce(e); return r + 8 > e.length && $n(6, 'invalid gzip data'), Vh(e.subarray(r, -8), { i: 2 }, new jn(Nce(e)), t) } function Rce(e, t) { return Vh(e.subarray($ce(e, t), -4), { i: 2 }, t, t) } function Dce(e, t) { return e[0] == 31 && e[1] == 139 && e[2] == 8 ? Pce(e, t) : (e[0] & 15) != 8 || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Oce(e, t) : Rce(e, t) } const zd = typeof TextDecoder < 'u' && new TextDecoder(); let zce = 0; try { zd.decode(Ace, { stream: !0 }), zce = 1 }
catch {} const Ice = function (e) {
  for (let t = '', r = 0; ;) {
    let o = e[r++]; const s = (o > 127) + (o > 223) + (o > 239); if (r + s > e.length)
      return { s: t, r: Rw(e, r - 1) }; s ? s == 3 ? (o = ((o & 15) << 18 | (e[r++] & 63) << 12 | (e[r++] & 63) << 6 | e[r++] & 63) - 65536, t += String.fromCharCode(55296 | o >> 10, 56320 | o & 1023)) : s & 1 ? t += String.fromCharCode((o & 31) << 6 | e[r++] & 63) : t += String.fromCharCode((o & 15) << 12 | (e[r++] & 63) << 6 | e[r++] & 63) : t += String.fromCharCode(o)
  }
}; function Fce(e, t) {
  var r; if (zd)
    return zd.decode(e); const o = Ice(e); const s = o.s; var r = o.r; return r.length && $n(8), s
} function td() {} const wn = () => Promise.resolve(); function Hce() {
  const e = er({ state: new Ub(), waitForConnection: f, reconnect: s, ws: new EventTarget() }); e.state.filesMap = er(e.state.filesMap), e.state.idMap = er(e.state.idMap); let t; const r = { getFiles: () => t.files, getPaths: () => t.paths, getConfig: () => t.config, getModuleGraph: async (d, h) => { let g; return (g = t.moduleGraph[d]) == null ? void 0 : g[h] }, getUnhandledErrors: () => t.unhandledErrors, getTransformResult: wn, onDone: td, onTaskUpdate: td, writeFile: wn, rerun: wn, updateSnapshot: wn, resolveSnapshotPath: wn, snapshotSaved: wn, onAfterSuiteRun: wn, onCancel: wn, getCountOfFailedTests: () => 0, sendLog: wn, resolveSnapshotRawPath: wn, readSnapshotFile: wn, saveSnapshotFile: wn, readTestFile: async d => t.sources[d], removeSnapshotFile: wn, onUnhandledError: td, saveTestFile: wn, getProvidedContext: () => ({}), getTestFiles: wn }; e.rpc = r; let o; function s() { c() } async function c() {
    let v; const d = await fetch(window.METADATA_PATH); const h = ((v = d.headers.get('content-type')) == null ? void 0 : v.toLowerCase()) || ''; if (h.includes('application/gzip') || h.includes('application/x-gzip')) { const y = new Uint8Array(await d.arrayBuffer()); const b = Fce(Dce(y)); t = Od(b) }
    else {
      t = Od(await d.text())
    } const g = new Event('open'); e.ws.dispatchEvent(g)
  }c(); function f() { return o } return e
} const Jc = Be('idle'); const qce = Me(() => Jc.value === 'idle'); const Ii = Be([]); const Id = Fr([]); const In = Fr([]); const _r = Pu('vitest-ui_task-tree-opened', [], { shallow: !0 }); const Qc = Me(() => new Set(_r.value)); const on = Pu('vitest-ui_task-tree-filter', { expandAll: void 0, failed: !1, success: !1, skipped: !1, onlyTests: !1, search: '' }); const On = Be(on.value.search); const Bce = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' }; function Dw(e) { return e.replace(/[&<>"']/g, t => Bce[t]) } const Wce = Me(() => { const e = On.value.toLowerCase(); return e.length ? new RegExp(`(${Dw(e)})`, 'gi') : null }); const zw = Me(() => On.value.trim() !== ''); const Qe = er({ failed: on.value.failed, success: on.value.success, skipped: on.value.skipped, onlyTests: on.value.onlyTests }); const Fd = Me(() => !!(Qe.failed || Qe.success || Qe.skipped)); const Ru = Fr([]); const As = Be(!1); const n0 = Me(() => { const e = on.value.expandAll; return _r.value.length > 0 ? e !== !0 : e !== !1 }); const Uce = Me(() => { const e = zw.value; const t = Fd.value; const r = Qe.onlyTests; const o = Ce.summary.filesFailed; const s = Ce.summary.filesSuccess; const c = Ce.summary.filesSkipped; const f = Ce.summary.filesRunning; const d = Ru.value; return Ce.collectTestsTotal(e || t, r, d, { failed: o, success: s, skipped: c, running: f }) }); function Du(e) { return Object.hasOwnProperty.call(e, 'tasks') } function Vce(e, t) { return typeof e != 'string' || typeof t != 'string' ? !1 : e.toLowerCase().includes(t.toLowerCase()) } function Iw(e) {
  if (!e)
    return ''; const t = e.split('').reduce((o, s, c) => o + s.charCodeAt(0) + c, 0); const r = ['blue', 'yellow', 'cyan', 'green', 'magenta']; return r[t % r.length]
} function jce(e) { return e.type === 'test' || e.type === 'custom' } function Gce(e) { return e.mode === 'run' && (e.type === 'test' || e.type === 'custom') } function kn(e) { return e.type === 'file' } function Kce(e) { return e.type === 'suite' } function ai(e) { return e.type === 'file' || e.type === 'suite' } function Xce(e = Ce.root.tasks) { return e.sort((t, r) => `${t.filepath}:${t.projectName}`.localeCompare(`${r.filepath}:${r.projectName}`)) } function Jl(e, t = !1) {
  let o, s, c, f; let r = Ce.nodes.get(e.id); if (r ? (r.state = (o = e.result) == null ? void 0 : o.state, r.mode = e.mode, r.duration = (s = e.result) == null ? void 0 : s.duration, r.collectDuration = e.collectDuration, r.setupDuration = e.setupDuration, r.environmentLoad = e.environmentLoad, r.prepareDuration = e.prepareDuration) : (r = { id: e.id, parentId: 'root', name: e.name, mode: e.mode, expandable: !0, expanded: Qc.value.size > 0 && Qc.value.has(e.id), type: 'file', children: new Set(), tasks: [], indent: 0, duration: (c = e.result) == null ? void 0 : c.duration, filepath: e.filepath, projectName: e.projectName || '', projectNameColor: Iw(e.projectName), collectDuration: e.collectDuration, setupDuration: e.setupDuration, environmentLoad: e.environmentLoad, prepareDuration: e.prepareDuration, state: (f = e.result) == null ? void 0 : f.state }, Ce.nodes.set(e.id, r), Ce.root.tasks.push(r)), t) {
    for (let d = 0; d < e.tasks.length; d++)pa(e.id, e.tasks[d], !0)
  }
} function Fw(e, t) {
  const r = Ce.nodes.get(e); if (!r || !ai(r))
    return; const o = yt.state.idMap.get(e); if (!(!o || !Du(o)))
    return pa(r.parentId, o, t && o.tasks.length > 0), [r, o]
} function Yce(e) {
  const t = Ce.nodes.get(e); if (!t)
    return; const r = yt.state.idMap.get(e); !r || !Es(r) || pa(t.parentId, r, !1)
} function pa(e, t, r) {
  let c, f, d, h, g, v; const o = Ce.nodes.get(e); let s; if (o && (s = Ce.nodes.get(t.id), s ? (o.children.has(t.id) || (o.tasks.push(s), o.children.add(t.id)), s.mode = t.mode, s.duration = (c = t.result) == null ? void 0 : c.duration, s.state = (f = t.result) == null ? void 0 : f.state, Kce(s) && (s.typecheck = !!t.meta && 'typecheck' in t.meta)) : (Es(t) ? s = { id: t.id, fileId: t.file.id, parentId: e, name: t.name, mode: t.mode, type: t.type, expandable: !1, expanded: !1, indent: o.indent + 1, duration: (d = t.result) == null ? void 0 : d.duration, state: (h = t.result) == null ? void 0 : h.state } : s = { id: t.id, fileId: t.file.id, parentId: e, name: t.name, mode: t.mode, typecheck: !!t.meta && 'typecheck' in t.meta, type: 'suite', expandable: !0, expanded: Qc.value.size > 0 && Qc.value.has(t.id), children: new Set(), tasks: [], indent: o.indent + 1, duration: (g = t.result) == null ? void 0 : g.duration, state: (v = t.result) == null ? void 0 : v.state }, Ce.nodes.set(t.id, s), o.tasks.push(s), o.children.add(t.id)), s && r && Du(t))) {
    for (let y = 0; y < t.tasks.length; y++)pa(s.id, t.tasks[y], r)
  }
} function Zce(e, t, r) { return e ? Bw(e, t, r) : !1 } function jh(e, t) { const r = [...Hw(e, t)]; In.value = r, Ru.value = r.filter(kn).map(o => ir(o.id)) } function*Hw(e, t) { for (const r of Xce()) yield * qw(r, e, t) } function*qw(e, t, r) {
  const o = new Set(); const s = new Map(); const c = []; let f; if (r.onlyTests) {
    for (const [y, b] of Hd(e, o, x => r0(x, t, r)))c.push([y, b])
  }
  else { for (const [y, b] of Hd(e, o, x => r0(x, t, r)))ai(b) ? (s.set(b.id, y), kn(b) ? (y && (f = b.id), c.push([y, b])) : c.push([y || s.get(b.parentId) === !0, b])) : c.push([y || s.get(b.parentId) === !0, b]); !f && !kn(e) && 'fileId' in e && (f = e.fileId) } const d = new Set(); const h = [...Qce(c, r.onlyTests, o, d, f)].reverse(); const g = Ce.nodes; const v = new Set(h.filter((y) => { let b; return kn(y) || ai(y) && ((b = g.get(y.parentId)) == null ? void 0 : b.expanded) }).map(y => y.id)); yield * h.filter((y) => { let b; return kn(y) || v.has(y.parentId) && ((b = g.get(y.parentId)) == null ? void 0 : b.expanded) })
} function Jce(e, t, r, o, s) {
  if (o) {
    if (kn(t))
      return s.has(t.id) ? t : void 0; if (r.has(t.id)) { const c = Ce.nodes.get(t.parentId); return c && kn(c) && s.add(c.id), t }
  }
  else if (e || r.has(t.id) || s.has(t.id)) { const c = Ce.nodes.get(t.parentId); return c && kn(c) && s.add(c.id), t }
} function*Qce(e, t, r, o, s) {
  for (let c = e.length - 1; c >= 0; c--) {
    const [f, d] = e[c]; const h = ai(d); if (!t && s && r.has(s) && 'fileId' in d && d.fileId === s) { h && r.add(d.id); let g = Ce.nodes.get(d.parentId); for (;g;)r.add(g.id), kn(g) && o.add(g.id), g = Ce.nodes.get(g.parentId); yield d; continue } if (h) { const g = Jce(f, d, r, t, o); g && (yield g) }
    else if (f) { const g = Ce.nodes.get(d.parentId); g && kn(g) && o.add(g.id), yield d }
  }
} function eue(e, t) { let r, o; return (t.success || t.failed) && 'result' in e && (t.success && ((r = e.result) == null ? void 0 : r.state) === 'pass' || t.failed && ((o = e.result) == null ? void 0 : o.state) === 'fail') ? !0 : t.skipped && 'mode' in e ? e.mode === 'skip' || e.mode === 'todo' : !1 } function Bw(e, t, r) {
  if (t.length === 0 || Vce(e.name, t)) {
    if (r.success || r.failed || r.skipped) {
      if (eue(e, r))
        return !0
    }
    else {
      return !0
    }
  } return !1
} function*Hd(e, t, r) {
  const o = r(e); if (o) {
    if (jce(e)) { let s = Ce.nodes.get(e.parentId); for (;s;)t.add(s.id), s = Ce.nodes.get(s.parentId) }
    else if (kn(e)) {
      t.add(e.id)
    }
    else { t.add(e.id); let s = Ce.nodes.get(e.parentId); for (;s;)t.add(s.id), s = Ce.nodes.get(s.parentId) }
  } if (yield [o, e], ai(e)) {
    for (let s = 0; s < e.tasks.length; s++) yield * Hd(e.tasks[s], t, r)
  }
} function r0(e, t, r) { const o = yt.state.idMap.get(e.id); return o ? Bw(o, t, r) : !1 } function tue(e, t, r) {
  const o = Fw(e, !1); if (!o)
    return; const [s, c] = o; for (const g of c.tasks)pa(s.id, g, !1); s.expanded = !0; const f = new Set(_r.value); f.add(s.id); const d = new Set(qw(s, t, r)); const h = [...iue(s, d)]; _r.value = Array.from(f), In.value = h
} function nue(e, t) { Gh(Ce.root.tasks, !1); const r = [...Hw(e, t)]; on.value.expandAll = !1, _r.value = [], In.value = r, Ru.value = r.filter(kn).map(o => ir(o.id)) } function rue(e, t) {
  if (e.size) {
    for (const r of In.value)e.has(r.id) && (r.expanded = !0)
  }
  else {
    t && Gh(In.value.filter(kn), !0)
  }
} function Gh(e, t) { for (const r of e)ai(r) && (r.expanded = !0, Gh(r.tasks, !1)); t && (on.value.expandAll = !1, _r.value = []) } function*iue(e, t) { const r = e.id; const o = new Set(Array.from(t).map(s => s.id)); for (const s of In.value)s.id === r ? (s.expanded = !0, o.has(s.id) || (yield e), yield * t) : o.has(s.id) || (yield s) } function oue(e, t, r, o) { e.map(s => [`${s.filepath}:${s.projectName || ''}`, s]).sort(([s], [c]) => s.localeCompare(c)).map(([,s]) => Jl(s, t)), Id.value = [...Ce.root.tasks], jh(r.trim(), { failed: o.failed, success: o.success, skipped: o.skipped, onlyTests: o.onlyTests }) } function sue(e) {
  queueMicrotask(() => {
    const t = Ce.pendingTasks; const r = yt.state.idMap; for (const o of e) {
      if (o[1]) { const c = r.get(o[0]); if (c) { let f = t.get(c.file.id); f || (f = new Set(), t.set(c.file.id, f)), f.add(c.id) } }
    }
  })
} function i0(e, t, r, o, s) { e && due(r); const c = !e; queueMicrotask(() => { t ? cue(c) : uue(c) }), queueMicrotask(() => { hue(r) }), queueMicrotask(() => { t && (r.failedSnapshot = Id.value && Fh(Id.value.map(f => ir(f.id))), r.failedSnapshotEnabled = !0) }), queueMicrotask(() => { fue(o, s, t) }) } function*lue() { yield * In.value.filter(Gce) } function aue() { const e = yt.state.idMap; let t; for (const r of lue())t = e.get(r.parentId), t && Du(t) && t.mode === 'todo' && (t = e.get(r.id), t && (t.mode = 'todo')) } function cue(e) {
  const t = yt.state.getFiles(); const r = Ce.nodes; const o = t.filter(c => !r.has(c.id)); for (let c = 0; c < o.length; c++)Jl(o[c], e), eu(o[c].tasks); const s = Ce.root.tasks; for (let c = 0; c < s.length; c++) {
    const f = s[c]; const d = ir(f.id); if (!d)
      continue; Jl(d, e); const h = d.tasks; h != null && h.length && eu(d.tasks)
  }
} function uue(e) {
  const t = new Map(Ce.pendingTasks.entries()); Ce.pendingTasks.clear(); const r = Ce.nodes; const o = Array.from(t.keys()).filter(d => !r.has(d)).map(d => ir(d)).filter(Boolean); let s; for (let d = 0; d < o.length; d++)s = o[d], Jl(s, !1), eu(s.tasks), t.delete(s.id); const c = yt.state.idMap; const f = Ce.root.tasks; for (let d = 0; d < f.length; d++) {
    const h = f[d]; const g = ir(h.id); if (!g)
      continue; const v = t.get(g.id); v && (Jl(g, e), eu(Array.from(v).map(y => c.get(y)).filter(Boolean)))
  }
} function fue(e, t, r = !1) { const o = on.value.expandAll; const s = o !== !0; const c = new Set(_r.value); const f = c.size > 0 && o === !1 || s; queueMicrotask(() => { o0(e, t, r) }), As.value || queueMicrotask(() => { (In.value.length || r) && (As.value = !0) }), f && (queueMicrotask(() => { rue(c, r), s && (on.value.expandAll = !1) }), queueMicrotask(() => { o0(e, t, r) })) } function o0(e, t, r) { jh(e, t), r && aue() } function eu(e) { let t; for (let r = 0; r < e.length; r++)t = e[r], Du(t) ? Fw(t.id, !0) : Yce(t.id) } function due(e) { e.files = 0, e.time = '', e.filesFailed = 0, e.filesSuccess = 0, e.filesIgnore = 0, e.filesRunning = 0, e.filesSkipped = 0, e.filesTodo = 0, e.testsFailed = 0, e.testsSuccess = 0, e.testsIgnore = 0, e.testsSkipped = 0, e.testsTodo = 0, e.totalTests = 0, e.failedSnapshotEnabled = !1 } function hue(e) {
  let f, d, h, g, v; const t = yt.state.idMap; const r = new Map(Ce.root.tasks.filter(y => t.has(y.id)).map(y => [y.id, y])); const o = Array.from(r.values()).map(y => [y.id, ir(y.id)]); const s = { files: r.size, time: '', filesFailed: 0, filesSuccess: 0, filesIgnore: 0, filesRunning: 0, filesSkipped: 0, filesTodo: 0, filesSnapshotFailed: 0, testsFailed: 0, testsSuccess: 0, testsIgnore: 0, testsSkipped: 0, testsTodo: 0, totalTests: 0, failedSnapshot: !1, failedSnapshotEnabled: !1 }; let c = 0; for (const [y, b] of o) {
    if (!b)
      continue; const x = r.get(y); x && (x.mode = b.mode, x.setupDuration = b.setupDuration, x.prepareDuration = b.prepareDuration, x.environmentLoad = b.environmentLoad, x.collectDuration = b.collectDuration, x.duration = (f = b.result) == null ? void 0 : f.duration, x.state = (d = b.result) == null ? void 0 : d.state), c += Math.max(0, b.collectDuration || 0), c += Math.max(0, b.setupDuration || 0), c += Math.max(0, ((h = b.result) == null ? void 0 : h.duration) || 0), c += Math.max(0, b.environmentLoad || 0), c += Math.max(0, b.prepareDuration || 0), s.time = c > 1e3 ? `${(c / 1e3).toFixed(2)}s` : `${Math.round(c)}ms`, ((g = b.result) == null ? void 0 : g.state) === 'fail' ? s.filesFailed++ : ((v = b.result) == null ? void 0 : v.state) === 'pass' ? s.filesSuccess++ : b.mode === 'skip' ? (s.filesIgnore++, s.filesSkipped++) : b.mode === 'todo' ? (s.filesIgnore++, s.filesTodo++) : s.filesRunning++; const { failed: T, success: E, skipped: M, total: N, ignored: L, todo: O } = Ww(b); s.totalTests += N, s.testsFailed += T, s.testsSuccess += E, s.testsSkipped += M, s.testsTodo += O, s.testsIgnore += L
  }e.files = s.files, e.time = s.time, e.filesFailed = s.filesFailed, e.filesSuccess = s.filesSuccess, e.filesIgnore = s.filesIgnore, e.filesRunning = s.filesRunning, e.filesSkipped = s.filesSkipped, e.filesTodo = s.filesTodo, e.testsFailed = s.testsFailed, e.testsSuccess = s.testsSuccess, e.testsFailed = s.testsFailed, e.testsTodo = s.testsTodo, e.testsIgnore = s.testsIgnore, e.testsSkipped = s.testsSkipped, e.totalTests = s.totalTests
} function Ww(e, t = '', r) { let s, c; const o = { failed: 0, success: 0, skipped: 0, running: 0, total: 0, ignored: 0, todo: 0 }; for (const f of Uw(e))(!r || Zce(f, t, r)) && (o.total++, ((s = f.result) == null ? void 0 : s.state) === 'fail' ? o.failed++ : ((c = f.result) == null ? void 0 : c.state) === 'pass' ? o.success++ : f.mode === 'skip' ? (o.ignored++, o.skipped++) : f.mode === 'todo' && (o.ignored++, o.todo++)); return o.running = o.total - o.failed - o.success - o.ignored, o } function pue(e, t, r, o, s, c) {
  let f, d; if (t)
    return r.map(h => Ww(h, s, c)).reduce((h, { failed: g, success: v, ignored: y, running: b }) => (h.failed += g, h.success += v, h.skipped += y, h.running += b, h), { failed: 0, success: 0, skipped: 0, running: 0 }); if (e) { const h = { failed: 0, success: 0, skipped: 0, running: 0 }; const g = !c.success && !c.failed; const v = c.failed || g; const y = c.success || g; for (const b of r)((f = b.result) == null ? void 0 : f.state) === 'fail' ? h.failed += v ? 1 : 0 : ((d = b.result) == null ? void 0 : d.state) === 'pass' ? h.success += y ? 1 : 0 : b.mode === 'skip' || b.mode === 'todo' || h.running++; return h } return o
} function*Uw(e) { const t = zh(e); let r; for (let o = 0; o < t.length; o++)r = t[o], Es(r) ? yield r : yield * Uw(r.tasks) } function gue(e) {
  const t = Ce.nodes.get(e); if (!t || !ai(t))
    return; const r = new Set(_r.value); r.delete(t.id); const o = [...mue(t)]; _r.value = Array.from(r), In.value = o
} function vue() { qd(Ce.root.tasks); const e = [...In.value.filter(kn)]; qd(e), _r.value = [], on.value.expandAll = !0, In.value = e } function qd(e) { for (const t of e)ai(t) && (t.expanded = !1, qd(t.tasks)) } function*Vw(e, t) {
  if (t && (yield e.id), ai(e)) {
    for (let r = 0; r < e.tasks.length; r++) yield * Vw(e.tasks[r], !0)
  }
} function*mue(e) { const t = e.id; const r = new Set(Vw(e, !1)); for (let o = 0; o < In.value.length; o++) { const s = In.value[o]; if (s.id === t) { s.expanded = !1, yield s; continue } if (r.has(s.id)) { r.delete(s.id); continue } yield s } } class yue {constructor(t = !1, r = 500, o = { id: 'vitest-root-node', expandable: !0, expanded: !0, tasks: [] }, s = new Map(), c = new Map(), f = er({ files: 0, time: '', filesFailed: 0, filesSuccess: 0, filesIgnore: 0, filesRunning: 0, filesSkipped: 0, filesSnapshotFailed: 0, filesTodo: 0, testsFailed: 0, testsSuccess: 0, testsIgnore: 0, testsSkipped: 0, testsTodo: 0, totalTests: 0, failedSnapshot: !1, failedSnapshotEnabled: !1 })) { ls(this, 'rafCollector'); ls(this, 'resumeEndRunId'); this.onTaskUpdateCalled = t, this.resumeEndTimeout = r, this.root = o, this.pendingTasks = s, this.nodes = c, this.summary = f, this.rafCollector = fce(this.runCollect.bind(this), { fpsLimit: 10, immediate: !1 }) }loadFiles(t) { oue(t, !0, On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }startRun() { this.resumeEndRunId = setTimeout(() => this.endRun(), this.resumeEndTimeout), this.collect(!0, !1) }resumeRun(t) { sue(t), this.onTaskUpdateCalled || (clearTimeout(this.resumeEndRunId), this.onTaskUpdateCalled = !0, this.collect(!0, !1, !1), this.rafCollector.resume()) }endRun() { this.rafCollector.pause(), this.onTaskUpdateCalled = !1, this.collect(!1, !0) }runCollect() { this.collect(!1, !1) }collect(t, r, o = !0) { o ? queueMicrotask(() => { i0(t, r, this.summary, On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }) : i0(t, r, this.summary, On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }collectTestsTotal(t, r, o, s) { return pue(t, r, o, s, On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }collapseNode(t) { queueMicrotask(() => { gue(t) }) }expandNode(t) { queueMicrotask(() => { tue(t, On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }) }collapseAllNodes() { queueMicrotask(() => { vue() }) }expandAllNodes() { queueMicrotask(() => { nue(On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }) }filterNodes() { queueMicrotask(() => { jh(On.value.trim(), { failed: Qe.failed, success: Qe.success, skipped: Qe.skipped, onlyTests: Qe.onlyTests }) }) }} const Ce = new yue(); const yt = (function () { return Pr ? Hce() : eL(rL, { reactive: (t, r) => r === 'state' ? er(t) : Fr(t), handlers: { onTaskUpdate(t) { Ce.resumeRun(t), Jc.value = 'running' }, onFinished(t, r) { Ce.endRun(), Jc.value = 'idle', Ii.value = (r || []).map(gw) }, onFinishedReportCoverage() { const t = document.querySelector('iframe#vitest-ui-coverage'); t instanceof HTMLIFrameElement && t.contentWindow && t.contentWindow.location.reload() } } }) }()); const zu = Fr({}); const So = Be('CONNECTING'); const Xt = Me(() => { const e = Zi.value; return e ? ir(e) : void 0 }); const jw = Me(() => Ih(Xt.value).map(e => (e == null ? void 0 : e.logs) || []).flat() || []); function ir(e) { const t = yt.state.idMap.get(e); return t || void 0 } const bue = Me(() => So.value === 'OPEN'); const nd = Me(() => So.value === 'CONNECTING'); Me(() => So.value === 'CLOSED'); function wue() { return Kh(yt.state.getFiles()) } function xue(e) { const t = Ce.nodes; e.forEach((r) => { delete r.result, Ih(r).forEach((s) => { if (delete s.result, t.has(s.id)) { const c = t.get(s.id); c && (c.state = void 0, c.duration = void 0) } }); const o = t.get(r.id); o && (o.state = void 0, o.duration = void 0, kn(o) && (o.collectDuration = void 0)) }) } function Kh(e) { return xue(e), Ce.startRun(), yt.rpc.rerun(e.map(t => t.filepath)) } const No = window.__vitest_browser_runner__; Ht(() => yt.ws, (e) => {
  So.value = Pr ? 'OPEN' : 'CONNECTING', e.addEventListener('open', async () => {
    So.value = 'OPEN', yt.state.filesMap.clear(); const [t, r, o] = await Promise.all([yt.rpc.getFiles(), yt.rpc.getConfig(), yt.rpc.getUnhandledErrors()]); if (r.standalone) { const c = (await yt.rpc.getTestFiles()).map(([{ name: f, root: d }, h]) => Bb(h, d, f)); yt.state.collectFiles(c) }
    else {
      Ce.loadFiles(t), yt.state.collectFiles(t), Ce.startRun()
    }Ii.value = (o || []).map(gw), zu.value = r
  }), e.addEventListener('close', () => { setTimeout(() => { So.value === 'CONNECTING' && (So.value = 'CLOSED') }, 1e3) })
}, { immediate: !0 }); const _ue = { 'text-2xl': '' }; const Sue = { 'text-lg': '', 'op50': '' }; const kue = ft({ __name: 'ConnectionOverlay', setup(e) { return (t, r) => q(bue) ? et('', !0) : (oe(), me('div', { 'key': 0, 'fixed': '', 'inset-0': '', 'p2': '', 'z-10': '', 'select-none': '', 'text': 'center sm', 'bg': 'overlay', 'backdrop-blur-sm': '', 'backdrop-saturate-0': '', 'onClick': r[0] || (r[0] = (...o) => q(yt).reconnect && q(yt).reconnect(...o)) }, [Y('div', { 'h-full': '', 'flex': '~ col gap-2', 'items-center': '', 'justify-center': '', 'class': lt(q(nd) ? 'animate-pulse' : '') }, [Y('div', { text: '5xl', class: lt(q(nd) ? 'i-carbon:renew animate-spin animate-reverse' : 'i-carbon-wifi-off') }, null, 2), Y('div', _ue, qe(q(nd) ? 'Connecting...' : 'Disconnected'), 1), Y('div', Sue, ` Check your terminal or start a new server with \`${qe(q(No) ? `vitest --browser=${q(No).config.browser.name}` : 'vitest --ui')}\` `, 1)], 2)])) } }); const Cue = ['aria-label', 'opacity', 'disabled', 'hover']; const hi = ft({ __name: 'IconButton', props: { icon: {}, title: {}, disabled: { type: Boolean }, active: { type: Boolean } }, setup(e) { return (t, r) => (oe(), me('button', { 'aria-label': t.title, 'role': 'button', 'opacity': t.disabled ? 10 : 70, 'rounded': '', 'disabled': t.disabled, 'hover': t.disabled || t.active ? '' : 'bg-active op100', 'class': lt(['w-1.4em h-1.4em flex', [{ 'bg-gray-500:35 op100': t.active }]]) }, [dn(t.$slots, 'default', {}, () => [Y('span', { class: lt(t.icon), ma: '', block: '' }, null, 2)])], 10, Cue)) } }); const Jr = Be('full'); const Bd = Be(); function rd(e) { const t = document.querySelector('#tester-ui'); t && (t.style.pointerEvents = e ? 'none' : '') } const Ms = Be(); const ys = Be(!0); const Ji = Be(!1); const tu = Be(!0); const us = Me(() => { let e; return (e = zu.value) == null ? void 0 : e.coverage }); const Wd = Me(() => { let e; return (e = us.value) == null ? void 0 : e.enabled }); const fs = Me(() => Wd.value && !!us.value.htmlReporter); const Ec = Pu('vitest-ui_splitpanes-detailSizes', [33, 67], { initOnMounted: !0 }); const s0 = Me(() => { let e; if (fs.value) { const t = us.value.reportsDirectory.lastIndexOf('/'); const r = (e = us.value.htmlReporter) == null ? void 0 : e.subdir; return r ? `/${us.value.reportsDirectory.slice(t + 1)}/${r}/index.html` : `/${us.value.reportsDirectory.slice(t + 1)}/index.html` } }); Ht(Jc, (e) => { tu.value = e === 'running' }, { immediate: !0 }); function Tue() { const e = Zi.value; if (e && e.length > 0) { const t = ir(e); t ? (Ms.value = t, ys.value = !1, Ji.value = !1) : lce(() => yt.state.getFiles(), () => { Ms.value = ir(e), ys.value = !1, Ji.value = !1 }) } return ys } function nu(e) { ys.value = e, Ji.value = !1, e && (Ms.value = void 0, Zi.value = '') } function Gw(e, t = null) { Zi.value = e.file.id, Rd.value = null, t != null && (ln(() => { Rd.value = t }), Bn.value = 'editor'), Ms.value = ir(e.file.id), nu(!1) } function Eue() { Ji.value = !0, ys.value = !1, Ms.value = void 0, Zi.value = '' } const Lue = { setCurrentFileId(e) { Zi.value = e, Ms.value = ir(e), nu(!1) }, async setIframeViewport(e, t) { Jr.value = 'custom', Bd.value = [e, t], await Kw(e, t) } }; window.__vitest_ui_api__ = Lue; function Aue() { const e = Xh(); const r = document.querySelector('#details-splitpanes').clientWidth; const o = e.clientWidth; const s = Math.min(o / r * 100, 95); const c = 100 - s; Ec.value = [s, c] } function Xh() { return document.querySelector('#tester-ui iframe[data-vitest]') } async function Kw(e, t) { const r = Xh(); r.style.width = typeof e == 'string' ? e : `${e}px`, r.style.height = typeof t == 'string' ? t : `${t}px`, await new Promise(o => requestAnimationFrame(o)), Aue() } const Mue = { h: 'full', flex: '~ col' }; const Nue = Y('div', { 'p': '3', 'h-10': '', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b base' }, [Y('div', { class: 'i-carbon-content-delivery-network' }), Y('span', { 'pl-1': '', 'font-bold': '', 'text-sm': '', 'flex-auto': '', 'ws-nowrap': '', 'overflow-hidden': '', 'truncate': '' }, 'Browser UI')], -1); const $ue = { 'p': 'l3 y2 r2', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b-2 base' }; const Oue = Y('div', { 'flex-auto': '', 'class': 'scrolls' }, [Y('div', { id: 'tester-ui', class: 'flex h-full justify-center items-center font-light op70', style: { overflow: 'auto', width: '100%', height: '100%' } }, ' Select a test to run ')], -1); const Pue = ft({ __name: 'BrowserIframe', setup(e) { const t = { 'small-mobile': ['320px', '568px'], 'large-mobile': ['414px', '896px'], 'tablet': ['834px', '1112px'], 'full': ['100%', '100%'], 'custom': null }; async function r(o) { if (Jr.value === o ? Jr.value = Bd.value ? 'custom' : 'full' : Jr.value = o, !Xh()) { console.warn('Iframe not found'); return } const [c, f] = t[Jr.value] || Bd.value || t.full; await Kw(c, f) } return (o, s) => { const c = hi; const f = Hr('tooltip'); return oe(), me('div', Mue, [Nue, Y('div', $ue, [_t(Oe(c, { title: 'Flexible', icon: 'i-carbon:fit-to-screen', active: q(Jr) === 'full', onClick: s[0] || (s[0] = d => r('full')) }, null, 8, ['active']), [[f, 'Flexible', void 0, { bottom: !0 }]]), _t(Oe(c, { title: 'Small mobile', icon: 'i-carbon:mobile', active: q(Jr) === 'small-mobile', onClick: s[1] || (s[1] = d => r('small-mobile')) }, null, 8, ['active']), [[f, 'Small mobile', void 0, { bottom: !0 }]]), _t(Oe(c, { title: 'Large mobile', icon: 'i-carbon:mobile-add', active: q(Jr) === 'large-mobile', onClick: s[2] || (s[2] = d => r('large-mobile')) }, null, 8, ['active']), [[f, 'Large mobile', void 0, { bottom: !0 }]]), _t(Oe(c, { title: 'Tablet', icon: 'i-carbon:tablet', active: q(Jr) === 'tablet', onClick: s[3] || (s[3] = d => r('tablet')) }, null, 8, ['active']), [[f, 'Tablet', void 0, { bottom: !0 }]])]), Oue]) } } }); const Xw = ft({ __name: 'Modal', props: Ic({ direction: { default: 'bottom' } }, { modelValue: { type: Boolean, default: !1 }, modelModifiers: {} }), emits: ['update:modelValue'], setup(e) { const t = Th(e, 'modelValue'); const r = Me(() => { switch (e.direction) { case 'bottom':return 'bottom-0 left-0 right-0 border-t'; case 'top':return 'top-0 left-0 right-0 border-b'; case 'left':return 'bottom-0 left-0 top-0 border-r'; case 'right':return 'bottom-0 top-0 right-0 border-l'; default:return '' } }); const o = Me(() => { switch (e.direction) { case 'bottom':return 'translateY(100%)'; case 'top':return 'translateY(-100%)'; case 'left':return 'translateX(-100%)'; case 'right':return 'translateX(100%)'; default:return '' } }); const s = () => t.value = !1; return (c, f) => (oe(), me('div', { class: lt(['fixed inset-0 z-40', t.value ? '' : 'pointer-events-none']) }, [Y('div', { class: lt(['bg-base inset-0 absolute transition-opacity duration-500 ease-out', t.value ? 'opacity-50' : 'opacity-0']), onClick: s }, null, 2), Y('div', { class: lt(['bg-base border-base absolute transition-all duration-200 ease-out scrolls', [q(r)]]), style: Zt(t.value ? {} : { transform: q(o) }) }, [dn(c.$slots, 'default')], 6)], 2)) } }); const Rue = e => (la('data-v-93900314'), e = e(), aa(), e); const Due = { 'w-350': '', 'max-w-screen': '', 'h-full': '', 'flex': '', 'flex-col': '' }; const zue = { 'p-4': '', 'relative': '', 'border': 'base b' }; const Iue = Rue(() => Y('p', null, 'Screenshot error', -1)); const Fue = { 'op50': '', 'font-mono': '', 'text-sm': '' }; const Hue = { 'op50': '', 'font-mono': '', 'text-sm': '' }; const que = { 'class': 'scrolls', 'grid': '~ cols-1 rows-[min-content]', 'p-4': '' }; const Bue = ['src', 'alt']; const Wue = { key: 1 }; const Uue = ft({ __name: 'ScreenshotError', props: { file: {}, name: {}, url: {} }, emits: ['close'], setup(e, { emit: t }) { const r = t; return _w('Escape', () => { r('close') }), (o, s) => { const c = hi; return oe(), me('div', Due, [Y('div', zue, [Iue, Y('p', Fue, qe(o.file), 1), Y('p', Hue, qe(o.name), 1), Oe(c, { 'icon': 'i-carbon:close', 'title': 'Close', 'absolute': '', 'top-5px': '', 'right-5px': '', 'text-2xl': '', 'onClick': s[0] || (s[0] = f => r('close')) })]), Y('div', que, [o.url ? (oe(), me('img', { key: 0, src: o.url, alt: `Screenshot error for '${o.name}' test in file '${o.file}'`, border: 'base t r b l dotted red-500' }, null, 8, Bue)) : (oe(), me('div', Wue, ' Something was wrong, the image cannot be resolved. '))])]) } } }); const Vue = di(Uue, [['__scopeId', 'data-v-93900314']]); function Dl(e) { return e.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;') } const ga = mce(); const jue = sce(ga); const Gue = { class: 'scrolls scrolls-rounded task-error' }; const Kue = ['onClickPassive']; const Xue = ['innerHTML']; const Yue = ft({ __name: 'ViewReportError', props: { root: {}, filename: {}, error: {} }, setup(e) { const t = e; function r(f) { return f.startsWith(t.root) ? f.slice(t.root.length) : f } const o = Me(() => Bh(ga.value)); const s = Me(() => { let f; return !!((f = t.error) != null && f.diff) }); const c = Me(() => t.error.diff ? o.value.toHtml(Dl(t.error.diff)) : void 0); return (f, d) => { const h = Hr('tooltip'); return oe(), me('div', Gue, [Y('pre', null, [Y('b', null, qe(f.error.name || f.error.nameStr), 1), gt(`: ${qe(f.error.message)}`, 1)]), (oe(!0), me(ut, null, si(f.error.stacks, (g, v) => (oe(), me('div', { 'key': v, 'class': 'op80 flex gap-x-2 items-center', 'data-testid': 'stack' }, [Y('pre', null, ` - ${qe(r(g.file))}:${qe(g.line)}:${qe(g.column)}`, 1), q(Jae)(g.file, f.filename) ? _t((oe(), me('div', { 'key': 0, 'class': 'i-carbon-launch c-red-600 dark:c-red-400 hover:cursor-pointer min-w-1em min-h-1em', 'tabindex': '0', 'aria-label': 'Open in Editor', 'onClickPassive': y => q(pw)(g.file, g.line, g.column) }, null, 40, Kue)), [[h, 'Open in Editor', void 0, { bottom: !0 }]]) : et('', !0)]))), 128)), q(s) ? (oe(), me('pre', { 'key': 0, 'data-testid': 'diff', 'innerHTML': q(c) }, null, 8, Xue)) : et('', !0)]) } } }); const Zue = di(Yue, [['__scopeId', 'data-v-9dd6eaea']]); const Jue = { 'h-full': '', 'class': 'scrolls' }; const Que = { flex: '~ gap-2 items-center' }; const efe = { 'key': 0, 'class': 'scrolls scrolls-rounded task-error', 'data-testid': 'task-error' }; const tfe = ['innerHTML']; const nfe = { 'key': 1, 'bg': 'green-500/10', 'text': 'green-500 sm', 'p': 'x4 y2', 'm-2': '', 'rounded': '' }; const rfe = ft({ __name: 'ViewReport', props: { file: {} }, setup(e) {
  const t = e; function r(b, x) { let T; return ((T = b.result) == null ? void 0 : T.state) !== 'fail' ? [] : b.type === 'test' || b.type === 'custom' ? [{ ...b, level: x }] : [{ ...b, level: x }, ...b.tasks.flatMap(E => r(E, x + 1))] } function o(b, x) { let M, N, L; let T = ''; (M = x.message) != null && M.includes('\x1B') && (T = `<b>${x.nameStr || x.name}</b>: ${b.toHtml(Dl(x.message))}`); const E = (N = x.stackStr) == null ? void 0 : N.includes('\x1B'); return (E || (L = x.stack) != null && L.includes('\x1B')) && (T.length > 0 ? T += b.toHtml(Dl(E ? x.stackStr : x.stack)) : T = `<b>${x.nameStr || x.name}</b>: ${x.message}${b.toHtml(Dl(E ? x.stackStr : x.stack))}`), T.length > 0 ? T : null } function s(b, x) {
    const T = Bh(b); return x.map((E) => {
      let L; const M = E.result; if (!M)
        return E; const N = (L = M.errors) == null ? void 0 : L.map(O => o(T, O)).filter(O => O != null).join('<br><br>'); return N != null && N.length && (M.htmlError = N), E
    })
  } const c = Me(() => { let M, N; const b = t.file; const x = ((M = b == null ? void 0 : b.tasks) == null ? void 0 : M.flatMap(L => r(L, 0))) ?? []; const T = b == null ? void 0 : b.result; if ((N = T == null ? void 0 : T.errors) == null ? void 0 : N[0]) { const L = { id: b.id, file: b, name: b.name, level: 0, type: 'suite', mode: 'run', meta: {}, tasks: [], result: T }; x.unshift(L) } return x.length > 0 ? s(ga.value, x) : x }); function f(b) { let T; const x = (T = b.meta) == null ? void 0 : T.failScreenshotPath; x && fetch(`/__open-in-editor?file=${encodeURIComponent(x)}`) } const d = Be(!1); const h = Be(Date.now()); const g = Be(); const v = Me(() => { let T; const b = (T = g.value) == null ? void 0 : T.meta.failScreenshotPath; const x = h.value; return b ? `/__screenshot-error?file=${encodeURIComponent(b)}&t=${x}` : void 0 }); function y(b) { g.value = b, h.value = Date.now(), d.value = !0 } return (b, x) => { const T = hi; const E = Zue; const M = Vue; const N = Xw; const L = Hr('tooltip'); return oe(), me('div', Jue, [q(c).length ? (oe(!0), me(ut, { key: 0 }, si(q(c), (O) => { let A, H, z, J; return oe(), me('div', { key: O.id }, [Y('div', { 'bg': 'red-500/10', 'text': 'red-500 sm', 'p': 'x3 y2', 'm-2': '', 'rounded': '', 'style': Zt({ 'margin-left': `${(A = O.result) != null && A.htmlError ? 0.5 : 2 * O.level + 0.5}rem` }) }, [Y('div', Que, [Y('span', null, qe(O.name), 1), q(No) && ((H = O.meta) != null && H.failScreenshotPath) ? (oe(), me(ut, { key: 0 }, [_t(Oe(T, { class: '!op-100', icon: 'i-carbon:image', title: 'View screenshot error', onClick: re => y(O) }, null, 8, ['onClick']), [[L, 'View screenshot error', void 0, { bottom: !0 }]]), _t(Oe(T, { class: '!op-100', icon: 'i-carbon:image-reference', title: 'Open screenshot error in editor', onClick: re => f(O) }, null, 8, ['onClick']), [[L, 'Open screenshot error in editor', void 0, { bottom: !0 }]])], 64)) : et('', !0)]), (z = O.result) != null && z.htmlError ? (oe(), me('div', efe, [Y('pre', { innerHTML: O.result.htmlError }, null, 8, tfe)])) : (J = O.result) != null && J.errors ? (oe(!0), me(ut, { key: 1 }, si(O.result.errors, (re, te) => { let j; return oe(), ot(E, { key: te, error: re, filename: (j = b.file) == null ? void 0 : j.name, root: q(zu).root }, null, 8, ['error', 'filename', 'root']) }), 128)) : et('', !0)], 4)]) }), 128)) : (oe(), me('div', nfe, ' All tests passed in this file ')), q(No) ? (oe(), ot(N, { 'key': 2, 'modelValue': q(d), 'onUpdate:modelValue': x[1] || (x[1] = O => Ot(d) ? d.value = O : null), 'direction': 'right' }, { default: st(() => [q(g) ? (oe(), ot(zy, { key: 0 }, { default: st(() => [Oe(M, { file: q(g).file.filepath, name: q(g).name, url: q(v), onClose: x[0] || (x[0] = O => d.value = !1) }, null, 8, ['file', 'name', 'url'])]), _: 1 })) : et('', !0)]), _: 1 }, 8, ['modelValue'])) : et('', !0)]) }
} }); const ife = di(rfe, [['__scopeId', 'data-v-8f3dbcaa']]); const ofe = { 'border': 'b base', 'p-4': '' }; const sfe = ['innerHTML']; const lfe = ft({ __name: 'ViewConsoleOutputEntry', props: { taskName: {}, type: {}, time: {}, content: {} }, setup(e) { function t(r) { return new Date(r).toLocaleTimeString() } return (r, o) => (oe(), me('div', ofe, [Y('div', { 'text-xs': '', 'mb-1': '', 'class': lt(r.type === 'stderr' ? 'text-red-600 dark:text-red-300' : 'op30') }, `${qe(t(r.time))} | ${qe(r.taskName)} | ${qe(r.type)}`, 3), Y('pre', { 'data-type': 'html', 'innerHTML': r.content }, null, 8, sfe)])) } }); const afe = { 'key': 0, 'h-full': '', 'class': 'scrolls', 'flex': '', 'flex-col': '', 'data-testid': 'logs' }; const cfe = { key: 1, p6: '' }; const ufe = Y('pre', { inline: '' }, 'console.log(foo)', -1); const ffe = ft({ __name: 'ViewConsoleOutput', setup(e) { const t = Me(() => { const o = jw.value; if (o) { const s = Bh(ga.value); return o.map(({ taskId: c, type: f, time: d, content: h }) => ({ taskId: c, type: f, time: d, content: s.toHtml(Dl(h)) })) } }); function r(o) { const s = o && yt.state.idMap.get(o); return s && 'filepath' in s ? s.name : (s ? QE(s).slice(1).join(' > ') : '-') || '-' } return (o, s) => { let f; const c = lfe; return (f = q(t)) != null && f.length ? (oe(), me('div', afe, [(oe(!0), me(ut, null, si(q(t), ({ taskId: d, type: h, time: g, content: v }) => (oe(), me('div', { 'key': d, 'font-mono': '' }, [Oe(c, { 'task-name': r(d), 'type': h, 'time': g, 'content': v }, null, 8, ['task-name', 'type', 'time', 'content'])]))), 128))])) : (oe(), me('p', cfe, [gt(' Log something in your test and it would print here. (e.g. '), ufe, gt(') ')])) } } }); const Yw = { exports: {} }; (function (e, t) {
  (function (r, o) { e.exports = o() })(Mo, () => {
    const r = navigator.userAgent; const o = navigator.platform; const s = /gecko\/\d/i.test(r); const c = /MSIE \d/.test(r); const f = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(r); const d = /Edge\/(\d+)/.exec(r); const h = c || f || d; const g = h && (c ? document.documentMode || 6 : +(d || f)[1]); let v = !d && /WebKit\//.test(r); const y = v && /Qt\/\d+\.\d+/.test(r); const b = !d && /Chrome\/(\d+)/.exec(r); const x = b && +b[1]; let T = /Opera\//.test(r); const E = /Apple Computer/.test(navigator.vendor); const M = /Mac OS X 1\d\D([89]|\d\d)\D/.test(r); const N = /PhantomJS/.test(r); const L = E && (/Mobile\/\w+/.test(r) || navigator.maxTouchPoints > 2); const O = /Android/.test(r); const A = L || O || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(r); const H = L || /Mac/.test(o); const z = /\bCrOS\b/.test(r); const J = /win/i.test(o); let re = T && r.match(/Version\/(\d*\.\d*)/); re && (re = Number(re[1])), re && re >= 15 && (T = !1, v = !0); const te = H && (y || T && (re == null || re < 12.11)); const j = s || h && g >= 9; function ne(n) { return new RegExp(`(^|\\s)${n}(?:$|\\s)\\s*`) } const K = function (n, i) { const a = n.className; const l = ne(i).exec(a); if (l) { const u = a.slice(l.index + l[0].length); n.className = a.slice(0, l.index) + (u ? l[1] + u : '') } }; function V(n) { for (let i = n.childNodes.length; i > 0; --i)n.removeChild(n.firstChild); return n } function I(n, i) { return V(n).appendChild(i) } function k(n, i, a, l) {
      const u = document.createElement(n); if (a && (u.className = a), l && (u.style.cssText = l), typeof i == 'string') {
        u.appendChild(document.createTextNode(i))
      }
      else if (i) {
        for (let p = 0; p < i.length; ++p)u.appendChild(i[p])
      } return u
    } function B(n, i, a, l) { const u = k(n, i, a, l); return u.setAttribute('role', 'presentation'), u } let W; document.createRange
      ? W = function (n, i, a, l) { const u = document.createRange(); return u.setEnd(l || n, a), u.setStart(n, i), u }
      : W = function (n, i, a) {
        const l = document.body.createTextRange(); try { l.moveToElementText(n.parentNode) }
        catch { return l } return l.collapse(!0), l.moveEnd('character', a), l.moveStart('character', i), l
      }; function ie(n, i) {
      if (i.nodeType == 3 && (i = i.parentNode), n.contains)
        return n.contains(i); do {
        if (i.nodeType == 11 && (i = i.host), i == n)
          return !0
      } while (i = i.parentNode)
    } function ye(n) {
      const i = n.ownerDocument || n; let a; try { a = n.activeElement }
      catch { a = i.body || null } for (;a && a.shadowRoot && a.shadowRoot.activeElement;)a = a.shadowRoot.activeElement; return a
    } function Ne(n, i) { const a = n.className; ne(i).test(a) || (n.className += (a ? ' ' : '') + i) } function We(n, i) { for (let a = n.split(' '), l = 0; l < a.length; l++)a[l] && !ne(a[l]).test(i) && (i += ` ${a[l]}`); return i } let je = function (n) { n.select() }; L
      ? je = function (n) { n.selectionStart = 0, n.selectionEnd = n.value.length }
      : h && (je = function (n) {
        try { n.select() }
        catch {}
      }); function it(n) { return n.display.wrapper.ownerDocument } function rt(n) { return Ze(n.display.wrapper) } function Ze(n) { return n.getRootNode ? n.getRootNode() : n.ownerDocument } function Ee(n) { return it(n).defaultView } function X(n) { const i = Array.prototype.slice.call(arguments, 1); return function () { return n.apply(null, i) } } function ae(n, i, a) { i || (i = {}); for (const l in n)n.hasOwnProperty(l) && (a !== !1 || !i.hasOwnProperty(l)) && (i[l] = n[l]); return i } function de(n, i, a, l, u) {
      i == null && (i = n.search(/\S/), i == -1 && (i = n.length)); for (let p = l || 0, m = u || 0; ;) {
        const w = n.indexOf('	', p); if (w < 0 || w >= i)
          return m + (i - p); m += w - p, m += a - m % a, p = w + 1
      }
    } const $e = function () { this.id = null, this.f = null, this.time = 0, this.handler = X(this.onTimeout, this) }; $e.prototype.onTimeout = function (n) { n.id = 0, n.time <= +new Date() ? n.f() : setTimeout(n.handler, n.time - +new Date()) }, $e.prototype.set = function (n, i) { this.f = i; const a = +new Date() + n; (!this.id || a < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, n), this.time = a) }; function Te(n, i) {
      for (let a = 0; a < n.length; ++a) {
        if (n[a] == i)
          return a
      } return -1
    } const Ye = 50; const P = { toString() { return 'CodeMirror.Pass' } }; const F = { scroll: !1 }; const Z = { origin: '*mouse' }; const ue = { origin: '+move' }; function le(n, i, a) {
      for (let l = 0, u = 0; ;) {
        let p = n.indexOf('	', l); p == -1 && (p = n.length); const m = p - l; if (p == n.length || u + m >= i)
          return l + Math.min(m, i - u); if (u += p - l, u += a - u % a, l = p + 1, u >= i)
          return l
      }
    } const he = ['']; function Se(n) { for (;he.length <= n;)he.push(`${fe(he)} `); return he[n] } function fe(n) { return n[n.length - 1] } function xe(n, i) { for (var a = [], l = 0; l < n.length; l++)a[l] = i(n[l], l); return a } function pe(n, i, a) { for (var l = 0, u = a(i); l < n.length && a(n[l]) <= u;)l++; n.splice(l, 0, i) } function Ae() {} function ze(n, i) { let a; return Object.create ? a = Object.create(n) : (Ae.prototype = n, a = new Ae()), i && ae(i, a), a } const Re = /[\u00DF\u0587\u0590-\u05F4\u0600-\u06FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DB5\u4E00-\u9FCC\uAC00-\uD7AF]/; function Ue(n) { return /\w/.test(n) || n > '' && (n.toUpperCase() != n.toLowerCase() || Re.test(n)) } function Ge(n, i) { return i ? i.source.includes('\\w') && Ue(n) ? !0 : i.test(n) : Ue(n) } function vt(n) {
      for (const i in n) {
        if (n.hasOwnProperty(i) && n[i])
          return !1
      } return !0
    } const tt = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065E\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0900-\u0902\u093C\u0941-\u0948\u094D\u0951-\u0955\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F90-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFD-\u1DFF\u200C\u200D\u20D0-\u20F0\u2CEF-\u2CF1\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uDC00-\uDFFF\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\uFF9E\uFF9F]/; function nt(n) { return n.charCodeAt(0) >= 768 && tt.test(n) } function It(n, i, a) { for (;(a < 0 ? i > 0 : i < n.length) && nt(n.charAt(i));)i += a; return i } function Jt(n, i, a) {
      for (let l = i > a ? -1 : 1; ;) {
        if (i == a)
          return i; const u = (i + a) / 2; const p = l < 0 ? Math.ceil(u) : Math.floor(u); if (p == i)
          return n(p) ? i : a; n(p) ? a = p : i = p + l
      }
    } function or(n, i, a, l) {
      if (!n)
        return l(i, a, 'ltr', 0); for (var u = !1, p = 0; p < n.length; ++p) { const m = n[p]; (m.from < a && m.to > i || i == a && m.to == i) && (l(Math.max(m.from, i), Math.min(m.to, a), m.level == 1 ? 'rtl' : 'ltr', p), u = !0) }u || l(i, a, 'ltr')
    } let Fn = null; function sr(n, i, a) {
      let l; Fn = null; for (let u = 0; u < n.length; ++u) {
        const p = n[u]; if (p.from < i && p.to > i)
          return u; p.to == i && (p.from != p.to && a == 'before' ? l = u : Fn = u), p.from == i && (p.from != p.to && a != 'before' ? l = u : Fn = u)
      } return l ?? Fn
    } const Qt = (function () {
      const n = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN'; const i = 'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111'; function a(S) { return S <= 247 ? n.charAt(S) : S >= 1424 && S <= 1524 ? 'R' : S >= 1536 && S <= 1785 ? i.charAt(S - 1536) : S >= 1774 && S <= 2220 ? 'r' : S >= 8192 && S <= 8203 ? 'w' : S == 8204 ? 'b' : 'L' } const l = /[\u0590-\u05F4\u0600-\u06FF\u0700-\u08AC]/; const u = /[stwN]/; const p = /[LRr]/; const m = /[Lb1n]/; const w = /[1n]/; function _(S, $, D) { this.level = S, this.from = $, this.to = D } return function (S, $) {
        const D = $ == 'ltr' ? 'L' : 'R'; if (S.length == 0 || $ == 'ltr' && !l.test(S))
          return !1; for (var G = S.length, U = [], ee = 0; ee < G; ++ee)U.push(a(S.charCodeAt(ee))); for (let ce = 0, ve = D; ce < G; ++ce) { const be = U[ce]; be == 'm' ? U[ce] = ve : ve = be } for (let ke = 0, we = D; ke < G; ++ke) { const Le = U[ke]; Le == '1' && we == 'r' ? U[ke] = 'n' : p.test(Le) && (we = Le, Le == 'r' && (U[ke] = 'R')) } for (let He = 1, De = U[0]; He < G - 1; ++He) { const Je = U[He]; Je == '+' && De == '1' && U[He + 1] == '1' ? U[He] = '1' : Je == ',' && De == U[He + 1] && (De == '1' || De == 'n') && (U[He] = De), De = Je } for (let wt = 0; wt < G; ++wt) {
          const Vt = U[wt]; if (Vt == ',') {
            U[wt] = 'N'
          }
          else if (Vt == '%') { let Tt = void 0; for (Tt = wt + 1; Tt < G && U[Tt] == '%'; ++Tt);for (let Mn = wt && U[wt - 1] == '!' || Tt < G && U[Tt] == '1' ? '1' : 'N', mn = wt; mn < Tt; ++mn)U[mn] = Mn; wt = Tt - 1 }
        } for (let Pt = 0, yn = D; Pt < G; ++Pt) { const Kt = U[Pt]; yn == 'L' && Kt == '1' ? U[Pt] = 'L' : p.test(Kt) && (yn = Kt) } for (let Ft = 0; Ft < G; ++Ft) {
          if (u.test(U[Ft])) { let Rt = void 0; for (Rt = Ft + 1; Rt < G && u.test(U[Rt]); ++Rt);for (let Mt = (Ft ? U[Ft - 1] : D) == 'L', bn = (Rt < G ? U[Rt] : D) == 'L', os = Mt == bn ? Mt ? 'L' : 'R' : D, Ti = Ft; Ti < Rt; ++Ti)U[Ti] = os; Ft = Rt - 1 }
        } for (var rn = [], Lr, jt = 0; jt < G;) {
          if (m.test(U[jt])) { const Df = jt; for (++jt; jt < G && m.test(U[jt]); ++jt);rn.push(new _(0, Df, jt)) }
          else {
            let Xr = jt; let ho = rn.length; const po = $ == 'rtl' ? 1 : 0; for (++jt; jt < G && U[jt] != 'L'; ++jt);for (let cn = Xr; cn < jt;) {
              if (w.test(U[cn])) { Xr < cn && (rn.splice(ho, 0, new _(1, Xr, cn)), ho += po); const ss = cn; for (++cn; cn < jt && w.test(U[cn]); ++cn);rn.splice(ho, 0, new _(2, ss, cn)), ho += po, Xr = cn }
              else {
                ++cn
              }
            } Xr < jt && rn.splice(ho, 0, new _(1, Xr, jt))
          }
        } return $ == 'ltr' && (rn[0].level == 1 && (Lr = S.match(/^\s+/)) && (rn[0].from = Lr[0].length, rn.unshift(new _(0, 0, Lr[0].length))), fe(rn).level == 1 && (Lr = S.match(/\s+$/)) && (fe(rn).to -= Lr[0].length, rn.push(new _(0, G - Lr[0].length, G)))), $ == 'rtl' ? rn.reverse() : rn
      }
    }()); function Ve(n, i) { let a = n.order; return a == null && (a = n.order = Qt(n.text, i)), a } const no = []; const Fe = function (n, i, a) {
      if (n.addEventListener) {
        n.addEventListener(i, a, !1)
      }
      else if (n.attachEvent) {
        n.attachEvent(`on${i}`, a)
      }
      else { const l = n._handlers || (n._handlers = {}); l[i] = (l[i] || no).concat(a) }
    }; function Br(n, i) { return n._handlers && n._handlers[i] || no } function en(n, i, a) {
      if (n.removeEventListener) {
        n.removeEventListener(i, a, !1)
      }
      else if (n.detachEvent) {
        n.detachEvent(`on${i}`, a)
      }
      else { const l = n._handlers; const u = l && l[i]; if (u) { const p = Te(u, a); p > -1 && (l[i] = u.slice(0, p).concat(u.slice(p + 1))) } }
    } function Et(n, i) {
      const a = Br(n, i); if (a.length) {
        for (let l = Array.prototype.slice.call(arguments, 2), u = 0; u < a.length; ++u)a[u].apply(null, l)
      }
    } function Lt(n, i, a) { return typeof i == 'string' && (i = { type: i, preventDefault() { this.defaultPrevented = !0 } }), Et(n, a || i.type, n, i), hn(i) || i.codemirrorIgnore } function Kn(n) {
      const i = n._handlers && n._handlers.cursorActivity; if (i) {
        for (let a = n.curOp.cursorActivityHandlers || (n.curOp.cursorActivityHandlers = []), l = 0; l < i.length; ++l)Te(a, i[l]) == -1 && a.push(i[l])
      }
    } function Ln(n, i) { return Br(n, i).length > 0 } function lr(n) { n.prototype.on = function (i, a) { Fe(this, i, a) }, n.prototype.off = function (i, a) { en(this, i, a) } } function tn(n) { n.preventDefault ? n.preventDefault() : n.returnValue = !1 } function Po(n) { n.stopPropagation ? n.stopPropagation() : n.cancelBubble = !0 } function hn(n) { return n.defaultPrevented != null ? n.defaultPrevented : n.returnValue == !1 } function pi(n) { tn(n), Po(n) } function Rs(n) { return n.target || n.srcElement } function ar(n) { let i = n.which; return i == null && (n.button & 1 ? i = 1 : n.button & 2 ? i = 3 : n.button & 4 && (i = 2)), H && n.ctrlKey && i == 1 && (i = 3), i } const Bu = (function () {
      if (h && g < 9)
        return !1; const n = k('div'); return 'draggable' in n || 'dragDrop' in n
    }()); let Ro; function ba(n) { if (Ro == null) { const i = k('span', ''); I(n, k('span', [i, document.createTextNode('x')])), n.firstChild.offsetHeight != 0 && (Ro = i.offsetWidth <= 1 && i.offsetHeight > 2 && !(h && g < 8)) } const a = Ro ? k('span', '') : k('span', '', null, 'display: inline-block; width: 1px; margin-right: -1px'); return a.setAttribute('cm-text', ''), a } let Ds; function gi(n) {
      if (Ds != null)
        return Ds; const i = I(n, document.createTextNode('AA')); const a = W(i, 0, 1).getBoundingClientRect(); const l = W(i, 1, 2).getBoundingClientRect(); return V(n), !a || a.left == a.right ? !1 : Ds = l.right - a.right < 3
    } const Xn = `

b`.split(/\n/).length != 3
      ? function (n) {
        for (var i = 0, a = [], l = n.length; i <= l;) {
          let u = n.indexOf(`
`, i); u == -1 && (u = n.length); const p = n.slice(i, n.charAt(u - 1) == '\r' ? u - 1 : u); const m = p.indexOf('\r'); m != -1 ? (a.push(p.slice(0, m)), i += m + 1) : (a.push(p), i = u + 1)
        } return a
      }
      : function (n) { return n.split(/\r\n?|\n/) }; const vi = window.getSelection
      ? function (n) {
        try { return n.selectionStart != n.selectionEnd }
        catch { return !1 }
      }
      : function (n) {
        let i; try { i = n.ownerDocument.selection.createRange() }
        catch {} return !i || i.parentElement() != n ? !1 : i.compareEndPoints('StartToEnd', i) != 0
      }; const wa = (function () { const n = k('div'); return 'oncopy' in n ? !0 : (n.setAttribute('oncopy', 'return;'), typeof n.oncopy == 'function') }()); let cr = null; function Wu(n) {
      if (cr != null)
        return cr; const i = I(n, k('span', 'x')); const a = i.getBoundingClientRect(); const l = W(i, 0, 1).getBoundingClientRect(); return cr = Math.abs(a.left - l.left) > 1
    } const Do = {}; const ur = {}; function fr(n, i) { arguments.length > 2 && (i.dependencies = Array.prototype.slice.call(arguments, 2)), Do[n] = i } function ro(n, i) { ur[n] = i } function zo(n) {
      if (typeof n == 'string' && ur.hasOwnProperty(n)) {
        n = ur[n]
      }
      else if (n && typeof n.name == 'string' && ur.hasOwnProperty(n.name)) { let i = ur[n.name]; typeof i == 'string' && (i = { name: i }), n = ze(i, n), n.name = i.name }
      else {
        if (typeof n == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(n))
          return zo('application/xml'); if (typeof n == 'string' && /^[\w\-]+\/[\w\-]+\+json$/.test(n))
          return zo('application/json')
      } return typeof n == 'string' ? { name: n } : n || { name: 'null' }
    } function Io(n, i) {
      i = zo(i); const a = Do[i.name]; if (!a)
        return Io(n, 'text/plain'); const l = a(n, i); if (mi.hasOwnProperty(i.name)) { const u = mi[i.name]; for (const p in u)u.hasOwnProperty(p) && (l.hasOwnProperty(p) && (l[`_${p}`] = l[p]), l[p] = u[p]) } if (l.name = i.name, i.helperType && (l.helperType = i.helperType), i.modeProps) {
        for (const m in i.modeProps)l[m] = i.modeProps[m]
      } return l
    } var mi = {}; function Fo(n, i) { const a = mi.hasOwnProperty(n) ? mi[n] : mi[n] = {}; ae(i, a) } function kr(n, i) {
      if (i === !0)
        return i; if (n.copyState)
        return n.copyState(i); const a = {}; for (const l in i) { let u = i[l]; Array.isArray(u) && (u = u.concat([])), a[l] = u } return a
    } function zs(n, i) { for (var a; n.innerMode && (a = n.innerMode(i), !(!a || a.mode == n));)i = a.state, n = a.mode; return a || { mode: n, state: i } } function Ho(n, i, a) { return n.startState ? n.startState(i, a) : !0 } const At = function (n, i, a) { this.pos = this.start = 0, this.string = n, this.tabSize = i || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = a }; At.prototype.eol = function () { return this.pos >= this.string.length }, At.prototype.sol = function () { return this.pos == this.lineStart }, At.prototype.peek = function () { return this.string.charAt(this.pos) || void 0 }, At.prototype.next = function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++)
    }, At.prototype.eat = function (n) {
      const i = this.string.charAt(this.pos); let a; if (typeof n == 'string' ? a = i == n : a = i && (n.test ? n.test(i) : n(i)), a)
        return ++this.pos, i
    }, At.prototype.eatWhile = function (n) { for (var i = this.pos; this.eat(n););return this.pos > i }, At.prototype.eatSpace = function () { for (var n = this.pos; /\s/.test(this.string.charAt(this.pos));)++this.pos; return this.pos > n }, At.prototype.skipToEnd = function () { this.pos = this.string.length }, At.prototype.skipTo = function (n) {
      const i = this.string.indexOf(n, this.pos); if (i > -1)
        return this.pos = i, !0
    }, At.prototype.backUp = function (n) { this.pos -= n }, At.prototype.column = function () { return this.lastColumnPos < this.start && (this.lastColumnValue = de(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? de(this.string, this.lineStart, this.tabSize) : 0) }, At.prototype.indentation = function () { return de(this.string, null, this.tabSize) - (this.lineStart ? de(this.string, this.lineStart, this.tabSize) : 0) }, At.prototype.match = function (n, i, a) {
      if (typeof n == 'string') {
        const l = function (m) { return a ? m.toLowerCase() : m }; const u = this.string.substr(this.pos, n.length); if (l(u) == l(n))
          return i !== !1 && (this.pos += n.length), !0
      }
      else { const p = this.string.slice(this.pos).match(n); return p && p.index > 0 ? null : (p && i !== !1 && (this.pos += p[0].length), p) }
    }, At.prototype.current = function () { return this.string.slice(this.start, this.pos) }, At.prototype.hideFirstChars = function (n, i) {
      this.lineStart += n; try { return i() }
      finally { this.lineStart -= n }
    }, At.prototype.lookAhead = function (n) { const i = this.lineOracle; return i && i.lookAhead(n) }, At.prototype.baseToken = function () { const n = this.lineOracle; return n && n.baseToken(this.pos) }; function Pe(n, i) {
      if (i -= n.first, i < 0 || i >= n.size)
        throw new Error(`There is no line ${i + n.first} in the document.`); for (var a = n; !a.lines;) {
        for (let l = 0; ;++l) { const u = a.children[l]; const p = u.chunkSize(); if (i < p) { a = u; break }i -= p }
      } return a.lines[i]
    } function Wr(n, i, a) { const l = []; let u = i.line; return n.iter(i.line, a.line + 1, (p) => { let m = p.text; u == a.line && (m = m.slice(0, a.ch)), u == i.line && (m = m.slice(i.ch)), l.push(m), ++u }), l } function Is(n, i, a) { const l = []; return n.iter(i, a, (u) => { l.push(u.text) }), l } function Hn(n, i) {
      const a = i - n.height; if (a) {
        for (let l = n; l; l = l.parent)l.height += a
      }
    } function C(n) {
      if (n.parent == null)
        return null; for (var i = n.parent, a = Te(i.lines, n), l = i.parent; l; i = l, l = l.parent) {
        for (let u = 0; l.children[u] != i; ++u)a += l.children[u].chunkSize()
      } return a + i.first
    } function R(n, i) {
      let a = n.first; e:do { for (let l = 0; l < n.children.length; ++l) { const u = n.children[l]; const p = u.height; if (i < p) { n = u; continue e }i -= p, a += u.chunkSize() } return a } while (!n.lines); for (var m = 0; m < n.lines.length; ++m) {
        const w = n.lines[m]; const _ = w.height; if (i < _)
          break; i -= _
      } return a + m
    } function se(n, i) { return i >= n.first && i < n.first + n.size } function ge(n, i) { return String(n.lineNumberFormatter(i + n.firstLineNumber)) } function Q(n, i, a) {
      if (a === void 0 && (a = null), !(this instanceof Q))
        return new Q(n, i, a); this.line = n, this.ch = i, this.sticky = a
    } function _e(n, i) { return n.line - i.line || n.ch - i.ch } function dt(n, i) { return n.sticky == i.sticky && _e(n, i) == 0 } function qt(n) { return Q(n.line, n.ch) } function pn(n, i) { return _e(n, i) < 0 ? i : n } function qo(n, i) { return _e(n, i) < 0 ? n : i } function up(n, i) { return Math.max(n.first, Math.min(i, n.first + n.size - 1)) } function Ke(n, i) {
      if (i.line < n.first)
        return Q(n.first, 0); const a = n.first + n.size - 1; return i.line > a ? Q(a, Pe(n, a).text.length) : q1(i, Pe(n, i.line).text.length)
    } function q1(n, i) { const a = n.ch; return a == null || a > i ? Q(n.line, i) : a < 0 ? Q(n.line, 0) : n } function fp(n, i) { for (var a = [], l = 0; l < i.length; l++)a[l] = Ke(n, i[l]); return a } const xa = function (n, i) { this.state = n, this.lookAhead = i }; const Cr = function (n, i, a, l) { this.state = i, this.doc = n, this.line = a, this.maxLookAhead = l || 0, this.baseTokens = null, this.baseTokenPos = 1 }; Cr.prototype.lookAhead = function (n) { const i = this.doc.getLine(this.line + n); return i != null && n > this.maxLookAhead && (this.maxLookAhead = n), i }, Cr.prototype.baseToken = function (n) {
      if (!this.baseTokens)
        return null; for (;this.baseTokens[this.baseTokenPos] <= n;) this.baseTokenPos += 2; const i = this.baseTokens[this.baseTokenPos + 1]; return { type: i && i.replace(/( |^)overlay .*/, ''), size: this.baseTokens[this.baseTokenPos] - n }
    }, Cr.prototype.nextLine = function () { this.line++, this.maxLookAhead > 0 && this.maxLookAhead-- }, Cr.fromSaved = function (n, i, a) { return i instanceof xa ? new Cr(n, kr(n.mode, i.state), a, i.lookAhead) : new Cr(n, kr(n.mode, i), a) }, Cr.prototype.save = function (n) { const i = n !== !1 ? kr(this.doc.mode, this.state) : this.state; return this.maxLookAhead > 0 ? new xa(i, this.maxLookAhead) : i }; function dp(n, i, a, l) {
      const u = [n.state.modeGen]; const p = {}; yp(n, i.text, n.doc.mode, a, (S, $) => { return u.push(S, $) }, p, l); for (var m = a.state, w = function (S) {
          a.baseTokens = u; const $ = n.state.overlays[S]; let D = 1; let G = 0; a.state = !0, yp(n, i.text, $.mode, a, (U, ee) => {
            for (var ce = D; G < U;) { const ve = u[D]; ve > U && u.splice(D, 1, U, u[D + 1], ve), D += 2, G = Math.min(U, ve) } if (ee) {
              if ($.opaque) {
                u.splice(ce, D - ce, U, `overlay ${ee}`), D = ce + 2
              }
              else {
                for (;ce < D; ce += 2) { const be = u[ce + 1]; u[ce + 1] = `${be ? `${be} ` : ''}overlay ${ee}` }
              }
            }
          }, p), a.state = m, a.baseTokens = null, a.baseTokenPos = 1
        }, _ = 0; _ < n.state.overlays.length; ++_)w(_); return { styles: u, classes: p.bgClass || p.textClass ? p : null }
    } function hp(n, i, a) { if (!i.styles || i.styles[0] != n.state.modeGen) { const l = Fs(n, C(i)); const u = i.text.length > n.options.maxHighlightLength && kr(n.doc.mode, l.state); const p = dp(n, i, l); u && (l.state = u), i.stateAfter = l.save(!u), i.styles = p.styles, p.classes ? i.styleClasses = p.classes : i.styleClasses && (i.styleClasses = null), a === n.doc.highlightFrontier && (n.doc.modeFrontier = Math.max(n.doc.modeFrontier, ++n.doc.highlightFrontier)) } return i.styles } function Fs(n, i, a) {
      const l = n.doc; const u = n.display; if (!l.mode.startState)
        return new Cr(l, !0, i); const p = B1(n, i, a); const m = p > l.first && Pe(l, p - 1).stateAfter; const w = m ? Cr.fromSaved(l, m, p) : new Cr(l, Ho(l.mode), p); return l.iter(p, i, (_) => { Uu(n, _.text, w); const S = w.line; _.stateAfter = S == i - 1 || S % 5 == 0 || S >= u.viewFrom && S < u.viewTo ? w.save() : null, w.nextLine() }), a && (l.modeFrontier = w.line), w
    } function Uu(n, i, a, l) { const u = n.doc.mode; const p = new At(i, n.options.tabSize, a); for (p.start = p.pos = l || 0, i == '' && pp(u, a.state); !p.eol();)Vu(u, p, a.state), p.start = p.pos } function pp(n, i) {
      if (n.blankLine)
        return n.blankLine(i); if (n.innerMode) {
        const a = zs(n, i); if (a.mode.blankLine)
          return a.mode.blankLine(a.state)
      }
    } function Vu(n, i, a, l) {
      for (let u = 0; u < 10; u++) {
        l && (l[0] = zs(n, a).mode); const p = n.token(i, a); if (i.pos > i.start)
          return p
      } throw new Error(`Mode ${n.name} failed to advance stream.`)
    } const gp = function (n, i, a) { this.start = n.start, this.end = n.pos, this.string = n.current(), this.type = i || null, this.state = a }; function vp(n, i, a, l) { const u = n.doc; const p = u.mode; let m; i = Ke(u, i); const w = Pe(u, i.line); const _ = Fs(n, i.line, a); const S = new At(w.text, n.options.tabSize, _); let $; for (l && ($ = []); (l || S.pos < i.ch) && !S.eol();)S.start = S.pos, m = Vu(p, S, _.state), l && $.push(new gp(S, m, kr(u.mode, _.state))); return l ? $ : new gp(S, m, _.state) } function mp(n, i) {
      if (n) {
        for (;;) {
          const a = n.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!a)
            break; n = n.slice(0, a.index) + n.slice(a.index + a[0].length); const l = a[1] ? 'bgClass' : 'textClass'; i[l] == null ? i[l] = a[2] : new RegExp(`(?:^|\\s)${a[2]}(?:$|\\s)`).test(i[l]) || (i[l] += ` ${a[2]}`)
        }
      } return n
    } function yp(n, i, a, l, u, p, m) { let w = a.flattenSpans; w == null && (w = n.options.flattenSpans); let _ = 0; let S = null; const $ = new At(i, n.options.tabSize, l); let D; const G = n.options.addModeClass && [null]; for (i == '' && mp(pp(a, l.state), p); !$.eol();) { if ($.pos > n.options.maxHighlightLength ? (w = !1, m && Uu(n, i, l, $.pos), $.pos = i.length, D = null) : D = mp(Vu(a, $, l.state, G), p), G) { const U = G[0].name; U && (D = `m-${D ? `${U} ${D}` : U}`) } if (!w || S != D) { for (;_ < $.start;)_ = Math.min($.start, _ + 5e3), u(_, S); S = D }$.start = $.pos } for (;_ < $.pos;) { const ee = Math.min($.pos, _ + 5e3); u(ee, S), _ = ee } } function B1(n, i, a) {
      for (var l, u, p = n.doc, m = a ? -1 : i - (n.doc.mode.innerMode ? 1e3 : 100), w = i; w > m; --w) {
        if (w <= p.first)
          return p.first; const _ = Pe(p, w - 1); const S = _.stateAfter; if (S && (!a || w + (S instanceof xa ? S.lookAhead : 0) <= p.modeFrontier))
          return w; const $ = de(_.text, null, n.options.tabSize); (u == null || l > $) && (u = w - 1, l = $)
      } return u
    } function W1(n, i) { if (n.modeFrontier = Math.min(n.modeFrontier, i), !(n.highlightFrontier < i - 10)) { for (var a = n.first, l = i - 1; l > a; l--) { const u = Pe(n, l).stateAfter; if (u && (!(u instanceof xa) || l + u.lookAhead < i)) { a = l + 1; break } }n.highlightFrontier = Math.min(n.highlightFrontier, a) } } let bp = !1; let Ur = !1; function U1() { bp = !0 } function V1() { Ur = !0 } function _a(n, i, a) { this.marker = n, this.from = i, this.to = a } function Hs(n, i) {
      if (n) {
        for (let a = 0; a < n.length; ++a) {
          const l = n[a]; if (l.marker == i)
            return l
        }
      }
    } function j1(n, i) { for (var a, l = 0; l < n.length; ++l)n[l] != i && (a || (a = [])).push(n[l]); return a } function G1(n, i, a) { const l = a && window.WeakSet && (a.markedSpans || (a.markedSpans = new WeakSet())); l && n.markedSpans && l.has(n.markedSpans) ? n.markedSpans.push(i) : (n.markedSpans = n.markedSpans ? n.markedSpans.concat([i]) : [i], l && l.add(n.markedSpans)), i.marker.attachLine(n) } function K1(n, i, a) {
      let l; if (n) {
        for (let u = 0; u < n.length; ++u) { const p = n[u]; const m = p.marker; const w = p.from == null || (m.inclusiveLeft ? p.from <= i : p.from < i); if (w || p.from == i && m.type == 'bookmark' && (!a || !p.marker.insertLeft)) { const _ = p.to == null || (m.inclusiveRight ? p.to >= i : p.to > i); (l || (l = [])).push(new _a(m, p.from, _ ? null : p.to)) } }
      } return l
    } function X1(n, i, a) {
      let l; if (n) {
        for (let u = 0; u < n.length; ++u) { const p = n[u]; const m = p.marker; const w = p.to == null || (m.inclusiveRight ? p.to >= i : p.to > i); if (w || p.from == i && m.type == 'bookmark' && (!a || p.marker.insertLeft)) { const _ = p.from == null || (m.inclusiveLeft ? p.from <= i : p.from < i); (l || (l = [])).push(new _a(m, _ ? null : p.from - i, p.to == null ? null : p.to - i)) } }
      } return l
    } function ju(n, i) {
      if (i.full)
        return null; const a = se(n, i.from.line) && Pe(n, i.from.line).markedSpans; const l = se(n, i.to.line) && Pe(n, i.to.line).markedSpans; if (!a && !l)
        return null; const u = i.from.ch; const p = i.to.ch; const m = _e(i.from, i.to) == 0; let w = K1(a, u, m); let _ = X1(l, p, m); const S = i.text.length == 1; const $ = fe(i.text).length + (S ? u : 0); if (w) {
        for (let D = 0; D < w.length; ++D) { const G = w[D]; if (G.to == null) { const U = Hs(_, G.marker); U ? S && (G.to = U.to == null ? null : U.to + $) : G.to = u } }
      } if (_) {
        for (let ee = 0; ee < _.length; ++ee) {
          const ce = _[ee]; if (ce.to != null && (ce.to += $), ce.from == null) { const ve = Hs(w, ce.marker); ve || (ce.from = $, S && (w || (w = [])).push(ce)) }
          else {
            ce.from += $, S && (w || (w = [])).push(ce)
          }
        }
      }w && (w = wp(w)), _ && _ != w && (_ = wp(_)); const be = [w]; if (!S) {
        const ke = i.text.length - 2; let we; if (ke > 0 && w) {
          for (let Le = 0; Le < w.length; ++Le)w[Le].to == null && (we || (we = [])).push(new _a(w[Le].marker, null, null))
        } for (let He = 0; He < ke; ++He)be.push(we); be.push(_)
      } return be
    } function wp(n) { for (let i = 0; i < n.length; ++i) { const a = n[i]; a.from != null && a.from == a.to && a.marker.clearWhenEmpty !== !1 && n.splice(i--, 1) } return n.length ? n : null } function Y1(n, i, a) {
      let l = null; if (n.iter(i.line, a.line + 1, (U) => {
        if (U.markedSpans) {
          for (let ee = 0; ee < U.markedSpans.length; ++ee) { const ce = U.markedSpans[ee].marker; ce.readOnly && (!l || Te(l, ce) == -1) && (l || (l = [])).push(ce) }
        }
      }), !l) {
        return null
      } for (var u = [{ from: i, to: a }], p = 0; p < l.length; ++p) {
        for (let m = l[p], w = m.find(0), _ = 0; _ < u.length; ++_) { const S = u[_]; if (!(_e(S.to, w.from) < 0 || _e(S.from, w.to) > 0)) { const $ = [_, 1]; const D = _e(S.from, w.from); const G = _e(S.to, w.to); (D < 0 || !m.inclusiveLeft && !D) && $.push({ from: S.from, to: w.from }), (G > 0 || !m.inclusiveRight && !G) && $.push({ from: w.to, to: S.to }), u.splice.apply(u, $), _ += $.length - 3 } }
      } return u
    } function xp(n) { const i = n.markedSpans; if (i) { for (let a = 0; a < i.length; ++a)i[a].marker.detachLine(n); n.markedSpans = null } } function _p(n, i) { if (i) { for (let a = 0; a < i.length; ++a)i[a].marker.attachLine(n); n.markedSpans = i } } function Sa(n) { return n.inclusiveLeft ? -1 : 0 } function ka(n) { return n.inclusiveRight ? 1 : 0 } function Gu(n, i) {
      const a = n.lines.length - i.lines.length; if (a != 0)
        return a; const l = n.find(); const u = i.find(); const p = _e(l.from, u.from) || Sa(n) - Sa(i); if (p)
        return -p; const m = _e(l.to, u.to) || ka(n) - ka(i); return m || i.id - n.id
    } function Sp(n, i) {
      const a = Ur && n.markedSpans; let l; if (a) {
        for (let u = void 0, p = 0; p < a.length; ++p)u = a[p], u.marker.collapsed && (i ? u.from : u.to) == null && (!l || Gu(l, u.marker) < 0) && (l = u.marker)
      } return l
    } function kp(n) { return Sp(n, !0) } function Ca(n) { return Sp(n, !1) } function Z1(n, i) {
      const a = Ur && n.markedSpans; let l; if (a) {
        for (let u = 0; u < a.length; ++u) { const p = a[u]; p.marker.collapsed && (p.from == null || p.from < i) && (p.to == null || p.to > i) && (!l || Gu(l, p.marker) < 0) && (l = p.marker) }
      } return l
    } function Cp(n, i, a, l, u) {
      const p = Pe(n, i); const m = Ur && p.markedSpans; if (m) {
        for (let w = 0; w < m.length; ++w) {
          const _ = m[w]; if (_.marker.collapsed) {
            const S = _.marker.find(0); const $ = _e(S.from, a) || Sa(_.marker) - Sa(u); const D = _e(S.to, l) || ka(_.marker) - ka(u); if (!($ >= 0 && D <= 0 || $ <= 0 && D >= 0) && ($ <= 0 && (_.marker.inclusiveRight && u.inclusiveLeft ? _e(S.to, a) >= 0 : _e(S.to, a) > 0) || $ >= 0 && (_.marker.inclusiveRight && u.inclusiveLeft ? _e(S.from, l) <= 0 : _e(S.from, l) < 0)))
              return !0
          }
        }
      }
    } function dr(n) { for (var i; i = kp(n);)n = i.find(-1, !0).line; return n } function J1(n) { for (var i; i = Ca(n);)n = i.find(1, !0).line; return n } function Q1(n) { for (var i, a; i = Ca(n);)n = i.find(1, !0).line, (a || (a = [])).push(n); return a } function Ku(n, i) { const a = Pe(n, i); const l = dr(a); return a == l ? i : C(l) } function Tp(n, i) {
      if (i > n.lastLine())
        return i; let a = Pe(n, i); let l; if (!yi(n, a))
        return i; for (;l = Ca(a);)a = l.find(1, !0).line; return C(a) + 1
    } function yi(n, i) {
      const a = Ur && i.markedSpans; if (a) {
        for (let l = void 0, u = 0; u < a.length; ++u) {
          if (l = a[u], !!l.marker.collapsed) {
            if (l.from == null)
              return !0; if (!l.marker.widgetNode && l.from == 0 && l.marker.inclusiveLeft && Xu(n, i, l))
              return !0
          }
        }
      }
    } function Xu(n, i, a) {
      if (a.to == null) { const l = a.marker.find(1, !0); return Xu(n, l.line, Hs(l.line.markedSpans, a.marker)) } if (a.marker.inclusiveRight && a.to == i.text.length)
        return !0; for (let u = void 0, p = 0; p < i.markedSpans.length; ++p) {
        if (u = i.markedSpans[p], u.marker.collapsed && !u.marker.widgetNode && u.from == a.to && (u.to == null || u.to != a.from) && (u.marker.inclusiveLeft || a.marker.inclusiveRight) && Xu(n, i, u))
          return !0
      }
    } function Vr(n) {
      n = dr(n); for (var i = 0, a = n.parent, l = 0; l < a.lines.length; ++l) {
        const u = a.lines[l]; if (u == n)
          break; i += u.height
      } for (let p = a.parent; p; a = p, p = a.parent) {
        for (let m = 0; m < p.children.length; ++m) {
          const w = p.children[m]; if (w == a)
            break; i += w.height
        }
      } return i
    } function Ta(n) {
      if (n.height == 0)
        return 0; for (var i = n.text.length, a, l = n; a = kp(l);) { const u = a.find(0, !0); l = u.from.line, i += u.from.ch - u.to.ch } for (l = n; a = Ca(l);) { const p = a.find(0, !0); i -= l.text.length - p.from.ch, l = p.to.line, i += l.text.length - p.to.ch } return i
    } function Yu(n) { const i = n.display; const a = n.doc; i.maxLine = Pe(a, a.first), i.maxLineLength = Ta(i.maxLine), i.maxLineChanged = !0, a.iter((l) => { const u = Ta(l); u > i.maxLineLength && (i.maxLineLength = u, i.maxLine = l) }) } const Bo = function (n, i, a) { this.text = n, _p(this, i), this.height = a ? a(this) : 1 }; Bo.prototype.lineNo = function () { return C(this) }, lr(Bo); function ex(n, i, a, l) { n.text = i, n.stateAfter && (n.stateAfter = null), n.styles && (n.styles = null), n.order != null && (n.order = null), xp(n), _p(n, a); const u = l ? l(n) : 1; u != n.height && Hn(n, u) } function tx(n) { n.parent = null, xp(n) } const nx = {}; const rx = {}; function Ep(n, i) {
      if (!n || /^\s*$/.test(n))
        return null; const a = i.addModeClass ? rx : nx; return a[n] || (a[n] = n.replace(/\S+/g, 'cm-$&'))
    } function Lp(n, i) { const a = B('span', null, null, v ? 'padding-right: .1px' : null); const l = { pre: B('pre', [a], 'CodeMirror-line'), content: a, col: 0, pos: 0, cm: n, trailingSpace: !1, splitSpaces: n.getOption('lineWrapping') }; i.measure = {}; for (let u = 0; u <= (i.rest ? i.rest.length : 0); u++) { const p = u ? i.rest[u - 1] : i.line; let m = void 0; l.pos = 0, l.addToken = ox, gi(n.display.measure) && (m = Ve(p, n.doc.direction)) && (l.addToken = lx(l.addToken, m)), l.map = []; const w = i != n.display.externalMeasured && C(p); ax(p, l, hp(n, p, w)), p.styleClasses && (p.styleClasses.bgClass && (l.bgClass = We(p.styleClasses.bgClass, l.bgClass || '')), p.styleClasses.textClass && (l.textClass = We(p.styleClasses.textClass, l.textClass || ''))), l.map.length == 0 && l.map.push(0, 0, l.content.appendChild(ba(n.display.measure))), u == 0 ? (i.measure.map = l.map, i.measure.cache = {}) : ((i.measure.maps || (i.measure.maps = [])).push(l.map), (i.measure.caches || (i.measure.caches = [])).push({})) } if (v) { const _ = l.content.lastChild; (/\bcm-tab\b/.test(_.className) || _.querySelector && _.querySelector('.cm-tab')) && (l.content.className = 'cm-tab-wrap-hack') } return Et(n, 'renderLine', n, i.line, l.pre), l.pre.className && (l.textClass = We(l.pre.className, l.textClass || '')), l } function ix(n) { const i = k('span', '', 'cm-invalidchar'); return i.title = `\\u${n.charCodeAt(0).toString(16)}`, i.setAttribute('aria-label', i.title), i } function ox(n, i, a, l, u, p, m) {
      if (i) {
        const w = n.splitSpaces ? sx(i, n.trailingSpace) : i; const _ = n.cm.state.specialChars; let S = !1; let $; if (!_.test(i)) {
          n.col += i.length, $ = document.createTextNode(w), n.map.push(n.pos, n.pos + i.length, $), h && g < 9 && (S = !0), n.pos += i.length
        }
        else {
          $ = document.createDocumentFragment(); for (let D = 0; ;) {
            _.lastIndex = D; const G = _.exec(i); const U = G ? G.index - D : i.length - D; if (U) { const ee = document.createTextNode(w.slice(D, D + U)); h && g < 9 ? $.appendChild(k('span', [ee])) : $.appendChild(ee), n.map.push(n.pos, n.pos + U, ee), n.col += U, n.pos += U } if (!G)
              break; D += U + 1; let ce = void 0; if (G[0] == '	') { const ve = n.cm.options.tabSize; const be = ve - n.col % ve; ce = $.appendChild(k('span', Se(be), 'cm-tab')), ce.setAttribute('role', 'presentation'), ce.setAttribute('cm-text', '	'), n.col += be }
            else {
              G[0] == '\r' || G[0] == `
`
                ? (ce = $.appendChild(k('span', G[0] == '\r' ? '' : '', 'cm-invalidchar')), ce.setAttribute('cm-text', G[0]), n.col += 1)
                : (ce = n.cm.options.specialCharPlaceholder(G[0]), ce.setAttribute('cm-text', G[0]), h && g < 9 ? $.appendChild(k('span', [ce])) : $.appendChild(ce), n.col += 1)
            }n.map.push(n.pos, n.pos + 1, ce), n.pos++
          }
        } if (n.trailingSpace = w.charCodeAt(i.length - 1) == 32, a || l || u || S || p || m) {
          let ke = a || ''; l && (ke += l), u && (ke += u); const we = k('span', [$], ke, p); if (m) {
            for (const Le in m)m.hasOwnProperty(Le) && Le != 'style' && Le != 'class' && we.setAttribute(Le, m[Le])
          } return n.content.appendChild(we)
        }n.content.appendChild($)
      }
    } function sx(n, i) {
      if (n.length > 1 && !/ {2}/.test(n))
        return n; for (var a = i, l = '', u = 0; u < n.length; u++) { let p = n.charAt(u); p == ' ' && a && (u == n.length - 1 || n.charCodeAt(u + 1) == 32) && (p = ''), l += p, a = p == ' ' } return l
    } function lx(n, i) {
      return function (a, l, u, p, m, w, _) {
        u = u ? `${u} cm-force-border` : 'cm-force-border'; for (let S = a.pos, $ = S + l.length; ;) {
          for (var D = void 0, G = 0; G < i.length && (D = i[G], !(D.to > S && D.from <= S)); G++);if (D.to >= $)
            return n(a, l, u, p, m, w, _); n(a, l.slice(0, D.to - S), u, p, null, w, _), p = null, l = l.slice(D.to - S), S = D.to
        }
      }
    } function Ap(n, i, a, l) { let u = !l && a.widgetNode; u && n.map.push(n.pos, n.pos + i, u), !l && n.cm.display.input.needsContentAttribute && (u || (u = n.content.appendChild(document.createElement('span'))), u.setAttribute('cm-marker', a.id)), u && (n.cm.display.input.setUneditable(u), n.content.appendChild(u)), n.pos += i, n.trailingSpace = !1 } function ax(n, i, a) {
      const l = n.markedSpans; const u = n.text; let p = 0; if (!l) { for (let m = 1; m < a.length; m += 2)i.addToken(i, u.slice(p, p = a[m]), Ep(a[m + 1], i.cm.options)); return } for (var w = u.length, _ = 0, S = 1, $ = '', D, G, U = 0, ee, ce, ve, be, ke; ;) {
        if (U == _) {
          ee = ce = ve = G = '', ke = null, be = null, U = 1 / 0; for (var we = [], Le = void 0, He = 0; He < l.length; ++He) {
            const De = l[He]; const Je = De.marker; if (Je.type == 'bookmark' && De.from == _ && Je.widgetNode) {
              we.push(Je)
            }
            else if (De.from <= _ && (De.to == null || De.to > _ || Je.collapsed && De.to == _ && De.from == _)) {
              if (De.to != null && De.to != _ && U > De.to && (U = De.to, ce = ''), Je.className && (ee += ` ${Je.className}`), Je.css && (G = (G ? `${G};` : '') + Je.css), Je.startStyle && De.from == _ && (ve += ` ${Je.startStyle}`), Je.endStyle && De.to == U && (Le || (Le = [])).push(Je.endStyle, De.to), Je.title && ((ke || (ke = {})).title = Je.title), Je.attributes) {
                for (const wt in Je.attributes)(ke || (ke = {}))[wt] = Je.attributes[wt]
              } Je.collapsed && (!be || Gu(be.marker, Je) < 0) && (be = De)
            }
            else {
              De.from > _ && U > De.from && (U = De.from)
            }
          } if (Le) {
            for (let Vt = 0; Vt < Le.length; Vt += 2)Le[Vt + 1] == U && (ce += ` ${Le[Vt]}`)
          } if (!be || be.from == _) {
            for (let Tt = 0; Tt < we.length; ++Tt)Ap(i, 0, we[Tt])
          } if (be && (be.from || 0) == _) {
            if (Ap(i, (be.to == null ? w + 1 : be.to) - _, be.marker, be.from == null), be.to == null)
              return; be.to == _ && (be = !1)
          }
        } if (_ >= w)
          break; for (let Mn = Math.min(w, U); ;) { if ($) { const mn = _ + $.length; if (!be) { const Pt = mn > Mn ? $.slice(0, Mn - _) : $; i.addToken(i, Pt, D ? D + ee : ee, ve, _ + Pt.length == U ? ce : '', G, ke) } if (mn >= Mn) { $ = $.slice(Mn - _), _ = Mn; break }_ = mn, ve = '' }$ = u.slice(p, p = a[S++]), D = Ep(a[S++], i.cm.options) }
      }
    } function Mp(n, i, a) { this.line = i, this.rest = Q1(i), this.size = this.rest ? C(fe(this.rest)) - a + 1 : 1, this.node = this.text = null, this.hidden = yi(n, i) } function Ea(n, i, a) { for (var l = [], u, p = i; p < a; p = u) { const m = new Mp(n.doc, Pe(n.doc, p), p); u = p + m.size, l.push(m) } return l } let Wo = null; function cx(n) { Wo ? Wo.ops.push(n) : n.ownsGroup = Wo = { ops: [n], delayedCallbacks: [] } } function ux(n) {
      const i = n.delayedCallbacks; let a = 0; do {
        for (;a < i.length; a++)i[a].call(null); for (let l = 0; l < n.ops.length; l++) {
          const u = n.ops[l]; if (u.cursorActivityHandlers) {
            for (;u.cursorActivityCalled < u.cursorActivityHandlers.length;)u.cursorActivityHandlers[u.cursorActivityCalled++].call(null, u.cm)
          }
        }
      } while (a < i.length)
    } function fx(n, i) {
      const a = n.ownsGroup; if (a) {
        try { ux(a) }
        finally { Wo = null, i(a) }
      }
    } let qs = null; function Bt(n, i) { const a = Br(n, i); if (a.length) { const l = Array.prototype.slice.call(arguments, 2); let u; Wo ? u = Wo.delayedCallbacks : qs ? u = qs : (u = qs = [], setTimeout(dx, 0)); for (let p = function (w) { u.push(() => { return a[w].apply(null, l) }) }, m = 0; m < a.length; ++m)p(m) } } function dx() { const n = qs; qs = null; for (let i = 0; i < n.length; ++i)n[i]() } function Np(n, i, a, l) { for (let u = 0; u < i.changes.length; u++) { const p = i.changes[u]; p == 'text' ? px(n, i) : p == 'gutter' ? Op(n, i, a, l) : p == 'class' ? Zu(n, i) : p == 'widget' && gx(n, i, l) }i.changes = null } function Bs(n) { return n.node == n.text && (n.node = k('div', null, null, 'position: relative'), n.text.parentNode && n.text.parentNode.replaceChild(n.node, n.text), n.node.appendChild(n.text), h && g < 8 && (n.node.style.zIndex = 2)), n.node } function hx(n, i) {
      let a = i.bgClass ? `${i.bgClass} ${i.line.bgClass || ''}` : i.line.bgClass; if (a && (a += ' CodeMirror-linebackground'), i.background) {
        a ? i.background.className = a : (i.background.parentNode.removeChild(i.background), i.background = null)
      }
      else if (a) { const l = Bs(i); i.background = l.insertBefore(k('div', null, a), l.firstChild), n.display.input.setUneditable(i.background) }
    } function $p(n, i) { const a = n.display.externalMeasured; return a && a.line == i.line ? (n.display.externalMeasured = null, i.measure = a.measure, a.built) : Lp(n, i) } function px(n, i) { const a = i.text.className; const l = $p(n, i); i.text == i.node && (i.node = l.pre), i.text.parentNode.replaceChild(l.pre, i.text), i.text = l.pre, l.bgClass != i.bgClass || l.textClass != i.textClass ? (i.bgClass = l.bgClass, i.textClass = l.textClass, Zu(n, i)) : a && (i.text.className = a) } function Zu(n, i) { hx(n, i), i.line.wrapClass ? Bs(i).className = i.line.wrapClass : i.node != i.text && (i.node.className = ''); const a = i.textClass ? `${i.textClass} ${i.line.textClass || ''}` : i.line.textClass; i.text.className = a || '' } function Op(n, i, a, l) {
      if (i.gutter && (i.node.removeChild(i.gutter), i.gutter = null), i.gutterBackground && (i.node.removeChild(i.gutterBackground), i.gutterBackground = null), i.line.gutterClass) { const u = Bs(i); i.gutterBackground = k('div', null, `CodeMirror-gutter-background ${i.line.gutterClass}`, `left: ${n.options.fixedGutter ? l.fixedPos : -l.gutterTotalWidth}px; width: ${l.gutterTotalWidth}px`), n.display.input.setUneditable(i.gutterBackground), u.insertBefore(i.gutterBackground, i.text) } const p = i.line.gutterMarkers; if (n.options.lineNumbers || p) {
        const m = Bs(i); const w = i.gutter = k('div', null, 'CodeMirror-gutter-wrapper', `left: ${n.options.fixedGutter ? l.fixedPos : -l.gutterTotalWidth}px`); if (w.setAttribute('aria-hidden', 'true'), n.display.input.setUneditable(w), m.insertBefore(w, i.text), i.line.gutterClass && (w.className += ` ${i.line.gutterClass}`), n.options.lineNumbers && (!p || !p['CodeMirror-linenumbers']) && (i.lineNumber = w.appendChild(k('div', ge(n.options, a), 'CodeMirror-linenumber CodeMirror-gutter-elt', `left: ${l.gutterLeft['CodeMirror-linenumbers']}px; width: ${n.display.lineNumInnerWidth}px`))), p) {
          for (let _ = 0; _ < n.display.gutterSpecs.length; ++_) { const S = n.display.gutterSpecs[_].className; const $ = p.hasOwnProperty(S) && p[S]; $ && w.appendChild(k('div', [$], 'CodeMirror-gutter-elt', `left: ${l.gutterLeft[S]}px; width: ${l.gutterWidth[S]}px`)) }
        }
      }
    } function gx(n, i, a) { i.alignable && (i.alignable = null); for (let l = ne('CodeMirror-linewidget'), u = i.node.firstChild, p = void 0; u; u = p)p = u.nextSibling, l.test(u.className) && i.node.removeChild(u); Pp(n, i, a) } function vx(n, i, a, l) { const u = $p(n, i); return i.text = i.node = u.pre, u.bgClass && (i.bgClass = u.bgClass), u.textClass && (i.textClass = u.textClass), Zu(n, i), Op(n, i, a, l), Pp(n, i, l), i.node } function Pp(n, i, a) {
      if (Rp(n, i.line, i, a, !0), i.rest) {
        for (let l = 0; l < i.rest.length; l++)Rp(n, i.rest[l], i, a, !1)
      }
    } function Rp(n, i, a, l, u) {
      if (i.widgets) {
        for (let p = Bs(a), m = 0, w = i.widgets; m < w.length; ++m) { const _ = w[m]; const S = k('div', [_.node], `CodeMirror-linewidget${_.className ? ` ${_.className}` : ''}`); _.handleMouseEvents || S.setAttribute('cm-ignore-events', 'true'), mx(_, S, a, l), n.display.input.setUneditable(S), u && _.above ? p.insertBefore(S, a.gutter || a.text) : p.appendChild(S), Bt(_, 'redraw') }
      }
    } function mx(n, i, a, l) { if (n.noHScroll) { (a.alignable || (a.alignable = [])).push(i); let u = l.wrapperWidth; i.style.left = `${l.fixedPos}px`, n.coverGutter || (u -= l.gutterTotalWidth, i.style.paddingLeft = `${l.gutterTotalWidth}px`), i.style.width = `${u}px` }n.coverGutter && (i.style.zIndex = 5, i.style.position = 'relative', n.noHScroll || (i.style.marginLeft = `${-l.gutterTotalWidth}px`)) } function Ws(n) {
      if (n.height != null)
        return n.height; const i = n.doc.cm; if (!i)
        return 0; if (!ie(document.body, n.node)) { let a = 'position: relative;'; n.coverGutter && (a += `margin-left: -${i.display.gutters.offsetWidth}px;`), n.noHScroll && (a += `width: ${i.display.wrapper.clientWidth}px;`), I(i.display.measure, k('div', [n.node], null, a)) } return n.height = n.node.parentNode.offsetHeight
    } function jr(n, i) {
      for (let a = Rs(i); a != n.wrapper; a = a.parentNode) {
        if (!a || a.nodeType == 1 && a.getAttribute('cm-ignore-events') == 'true' || a.parentNode == n.sizer && a != n.mover)
          return !0
      }
    } function La(n) { return n.lineSpace.offsetTop } function Ju(n) { return n.mover.offsetHeight - n.lineSpace.offsetHeight } function Dp(n) {
      if (n.cachedPaddingH)
        return n.cachedPaddingH; const i = I(n.measure, k('pre', 'x', 'CodeMirror-line-like')); const a = window.getComputedStyle ? window.getComputedStyle(i) : i.currentStyle; const l = { left: Number.parseInt(a.paddingLeft), right: Number.parseInt(a.paddingRight) }; return !isNaN(l.left) && !isNaN(l.right) && (n.cachedPaddingH = l), l
    } function Tr(n) { return Ye - n.display.nativeBarWidth } function io(n) { return n.display.scroller.clientWidth - Tr(n) - n.display.barWidth } function Qu(n) { return n.display.scroller.clientHeight - Tr(n) - n.display.barHeight } function yx(n, i, a) { const l = n.options.lineWrapping; const u = l && io(n); if (!i.measure.heights || l && i.measure.width != u) { const p = i.measure.heights = []; if (l) { i.measure.width = u; for (let m = i.text.firstChild.getClientRects(), w = 0; w < m.length - 1; w++) { const _ = m[w]; const S = m[w + 1]; Math.abs(_.bottom - S.bottom) > 2 && p.push((_.bottom + S.top) / 2 - a.top) } }p.push(a.bottom - a.top) } } function zp(n, i, a) {
      if (n.line == i)
        return { map: n.measure.map, cache: n.measure.cache }; if (n.rest) {
        for (let l = 0; l < n.rest.length; l++) {
          if (n.rest[l] == i)
            return { map: n.measure.maps[l], cache: n.measure.caches[l] }
        } for (let u = 0; u < n.rest.length; u++) {
          if (C(n.rest[u]) > a)
            return { map: n.measure.maps[u], cache: n.measure.caches[u], before: !0 }
        }
      }
    } function bx(n, i) { i = dr(i); const a = C(i); const l = n.display.externalMeasured = new Mp(n.doc, i, a); l.lineN = a; const u = l.built = Lp(n, l); return l.text = u.pre, I(n.display.lineMeasure, u.pre), l } function Ip(n, i, a, l) { return Er(n, Uo(n, i), a, l) } function ef(n, i) {
      if (i >= n.display.viewFrom && i < n.display.viewTo)
        return n.display.view[lo(n, i)]; const a = n.display.externalMeasured; if (a && i >= a.lineN && i < a.lineN + a.size)
        return a
    } function Uo(n, i) { const a = C(i); let l = ef(n, a); l && !l.text ? l = null : l && l.changes && (Np(n, l, a, sf(n)), n.curOp.forceUpdate = !0), l || (l = bx(n, i)); const u = zp(l, i, a); return { line: i, view: l, rect: null, map: u.map, cache: u.cache, before: u.before, hasHeights: !1 } } function Er(n, i, a, l, u) { i.before && (a = -1); const p = a + (l || ''); let m; return i.cache.hasOwnProperty(p) ? m = i.cache[p] : (i.rect || (i.rect = i.view.text.getBoundingClientRect()), i.hasHeights || (yx(n, i.view, i.rect), i.hasHeights = !0), m = xx(n, i, a, l), m.bogus || (i.cache[p] = m)), { left: m.left, right: m.right, top: u ? m.rtop : m.top, bottom: u ? m.rbottom : m.bottom } } const Fp = { left: 0, right: 0, top: 0, bottom: 0 }; function Hp(n, i, a) {
      for (var l, u, p, m, w, _, S = 0; S < n.length; S += 3) {
        if (w = n[S], _ = n[S + 1], i < w ? (u = 0, p = 1, m = 'left') : i < _ ? (u = i - w, p = u + 1) : (S == n.length - 3 || i == _ && n[S + 3] > i) && (p = _ - w, u = p - 1, i >= _ && (m = 'right')), u != null) {
          if (l = n[S + 2], w == _ && a == (l.insertLeft ? 'left' : 'right') && (m = a), a == 'left' && u == 0) {
            for (;S && n[S - 2] == n[S - 3] && n[S - 1].insertLeft;)l = n[(S -= 3) + 2], m = 'left'
          } if (a == 'right' && u == _ - w) {
            for (;S < n.length - 3 && n[S + 3] == n[S + 4] && !n[S + 5].insertLeft;)l = n[(S += 3) + 2], m = 'right'
          } break
        }
      } return { node: l, start: u, end: p, collapse: m, coverStart: w, coverEnd: _ }
    } function wx(n, i) {
      let a = Fp; if (i == 'left') {
        for (let l = 0; l < n.length && (a = n[l]).left == a.right; l++);
      }
      else {
        for (let u = n.length - 1; u >= 0 && (a = n[u]).left == a.right; u--);
      } return a
    } function xx(n, i, a, l) {
      const u = Hp(i.map, a, l); const p = u.node; let m = u.start; let w = u.end; let _ = u.collapse; let S; if (p.nodeType == 3) {
        for (let $ = 0; $ < 4; $++) {
          for (;m && nt(i.line.text.charAt(u.coverStart + m));)--m; for (;u.coverStart + w < u.coverEnd && nt(i.line.text.charAt(u.coverStart + w));)++w; if (h && g < 9 && m == 0 && w == u.coverEnd - u.coverStart ? S = p.parentNode.getBoundingClientRect() : S = wx(W(p, m, w).getClientRects(), l), S.left || S.right || m == 0)
            break; w = m, m = m - 1, _ = 'right'
        }h && g < 11 && (S = _x(n.display.measure, S))
      }
      else { m > 0 && (_ = l = 'right'); let D; n.options.lineWrapping && (D = p.getClientRects()).length > 1 ? S = D[l == 'right' ? D.length - 1 : 0] : S = p.getBoundingClientRect() } if (h && g < 9 && !m && (!S || !S.left && !S.right)) { const G = p.parentNode.getClientRects()[0]; G ? S = { left: G.left, right: G.left + jo(n.display), top: G.top, bottom: G.bottom } : S = Fp } for (var U = S.top - i.rect.top, ee = S.bottom - i.rect.top, ce = (U + ee) / 2, ve = i.view.measure.heights, be = 0; be < ve.length - 1 && !(ce < ve[be]); be++);const ke = be ? ve[be - 1] : 0; const we = ve[be]; const Le = { left: (_ == 'right' ? S.right : S.left) - i.rect.left, right: (_ == 'left' ? S.left : S.right) - i.rect.left, top: ke, bottom: we }; return !S.left && !S.right && (Le.bogus = !0), n.options.singleCursorHeightPerLine || (Le.rtop = U, Le.rbottom = ee), Le
    } function _x(n, i) {
      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !Wu(n))
        return i; const a = screen.logicalXDPI / screen.deviceXDPI; const l = screen.logicalYDPI / screen.deviceYDPI; return { left: i.left * a, right: i.right * a, top: i.top * l, bottom: i.bottom * l }
    } function qp(n) {
      if (n.measure && (n.measure.cache = {}, n.measure.heights = null, n.rest)) {
        for (let i = 0; i < n.rest.length; i++)n.measure.caches[i] = {}
      }
    } function Bp(n) { n.display.externalMeasure = null, V(n.display.lineMeasure); for (let i = 0; i < n.display.view.length; i++)qp(n.display.view[i]) } function Us(n) { Bp(n), n.display.cachedCharWidth = n.display.cachedTextHeight = n.display.cachedPaddingH = null, n.options.lineWrapping || (n.display.maxLineChanged = !0), n.display.lineNumChars = null } function Wp(n) { return b && O ? -(n.body.getBoundingClientRect().left - Number.parseInt(getComputedStyle(n.body).marginLeft)) : n.defaultView.pageXOffset || (n.documentElement || n.body).scrollLeft } function Up(n) { return b && O ? -(n.body.getBoundingClientRect().top - Number.parseInt(getComputedStyle(n.body).marginTop)) : n.defaultView.pageYOffset || (n.documentElement || n.body).scrollTop } function tf(n) {
      const i = dr(n); const a = i.widgets; let l = 0; if (a) {
        for (let u = 0; u < a.length; ++u)a[u].above && (l += Ws(a[u]))
      } return l
    } function Aa(n, i, a, l, u) {
      if (!u) { const p = tf(i); a.top += p, a.bottom += p } if (l == 'line')
        return a; l || (l = 'local'); let m = Vr(i); if (l == 'local' ? m += La(n.display) : m -= n.display.viewOffset, l == 'page' || l == 'window') { const w = n.display.lineSpace.getBoundingClientRect(); m += w.top + (l == 'window' ? 0 : Up(it(n))); const _ = w.left + (l == 'window' ? 0 : Wp(it(n))); a.left += _, a.right += _ } return a.top += m, a.bottom += m, a
    } function Vp(n, i, a) {
      if (a == 'div')
        return i; let l = i.left; let u = i.top; if (a == 'page') {
        l -= Wp(it(n)), u -= Up(it(n))
      }
      else if (a == 'local' || !a) { const p = n.display.sizer.getBoundingClientRect(); l += p.left, u += p.top } const m = n.display.lineSpace.getBoundingClientRect(); return { left: l - m.left, top: u - m.top }
    } function Ma(n, i, a, l, u) { return l || (l = Pe(n.doc, i.line)), Aa(n, l, Ip(n, l, i.ch, u), a) } function hr(n, i, a, l, u, p) {
      l = l || Pe(n.doc, i.line), u || (u = Uo(n, l)); function m(ee, ce) { const ve = Er(n, u, ee, ce ? 'right' : 'left', p); return ce ? ve.left = ve.right : ve.right = ve.left, Aa(n, l, ve, a) } const w = Ve(l, n.doc.direction); let _ = i.ch; let S = i.sticky; if (_ >= l.text.length ? (_ = l.text.length, S = 'before') : _ <= 0 && (_ = 0, S = 'after'), !w)
        return m(S == 'before' ? _ - 1 : _, S == 'before'); function $(ee, ce, ve) { const be = w[ce]; const ke = be.level == 1; return m(ve ? ee - 1 : ee, ke != ve) } const D = sr(w, _, S); const G = Fn; const U = $(_, D, S == 'before'); return G != null && (U.other = $(_, G, S != 'before')), U
    } function jp(n, i) { let a = 0; i = Ke(n.doc, i), n.options.lineWrapping || (a = jo(n.display) * i.ch); const l = Pe(n.doc, i.line); const u = Vr(l) + La(n.display); return { left: a, right: a, top: u, bottom: u + l.height } } function nf(n, i, a, l, u) { const p = Q(n, i, a); return p.xRel = u, l && (p.outside = l), p } function rf(n, i, a) {
      const l = n.doc; if (a += n.display.viewOffset, a < 0)
        return nf(l.first, 0, null, -1, -1); let u = R(l, a); const p = l.first + l.size - 1; if (u > p)
        return nf(l.first + l.size - 1, Pe(l, p).text.length, null, 1, 1); i < 0 && (i = 0); for (let m = Pe(l, u); ;) {
        const w = Sx(n, m, u, i, a); const _ = Z1(m, w.ch + (w.xRel > 0 || w.outside > 0 ? 1 : 0)); if (!_)
          return w; const S = _.find(1); if (S.line == u)
          return S; m = Pe(l, u = S.line)
      }
    } function Gp(n, i, a, l) { l -= tf(i); let u = i.text.length; const p = Jt((m) => { return Er(n, a, m - 1).bottom <= l }, u, 0); return u = Jt((m) => { return Er(n, a, m).top > l }, p, u), { begin: p, end: u } } function Kp(n, i, a, l) { a || (a = Uo(n, i)); const u = Aa(n, i, Er(n, a, l), 'line').top; return Gp(n, i, a, u) } function of(n, i, a, l) { return n.bottom <= a ? !1 : n.top > a ? !0 : (l ? n.left : n.right) > i } function Sx(n, i, a, l, u) {
      u -= Vr(i); const p = Uo(n, i); const m = tf(i); let w = 0; let _ = i.text.length; let S = !0; const $ = Ve(i, n.doc.direction); if ($) { const D = (n.options.lineWrapping ? Cx : kx)(n, i, a, p, $, l, u); S = D.level != 1, w = S ? D.from : D.to - 1, _ = S ? D.to : D.from - 1 } let G = null; let U = null; let ee = Jt((He) => { const De = Er(n, p, He); return De.top += m, De.bottom += m, of(De, l, u, !1) ? (De.top <= u && De.left <= l && (G = He, U = De), !0) : !1 }, w, _); let ce; let ve; let be = !1; if (U) { const ke = l - U.left < U.right - l; const we = ke == S; ee = G + (we ? 0 : 1), ve = we ? 'after' : 'before', ce = ke ? U.left : U.right }
      else { !S && (ee == _ || ee == w) && ee++, ve = ee == 0 ? 'after' : ee == i.text.length ? 'before' : Er(n, p, ee - (S ? 1 : 0)).bottom + m <= u == S ? 'after' : 'before'; const Le = hr(n, Q(a, ee, ve), 'line', i, p); ce = Le.left, be = u < Le.top ? -1 : u >= Le.bottom ? 1 : 0 } return ee = It(i.text, ee, 1), nf(a, ee, ve, be, l - ce)
    } function kx(n, i, a, l, u, p, m) { const w = Jt((D) => { const G = u[D]; const U = G.level != 1; return of(hr(n, Q(a, U ? G.to : G.from, U ? 'before' : 'after'), 'line', i, l), p, m, !0) }, 0, u.length - 1); let _ = u[w]; if (w > 0) { const S = _.level != 1; const $ = hr(n, Q(a, S ? _.from : _.to, S ? 'after' : 'before'), 'line', i, l); of($, p, m, !0) && $.top > m && (_ = u[w - 1]) } return _ } function Cx(n, i, a, l, u, p, m) { const w = Gp(n, i, l, m); const _ = w.begin; let S = w.end; /\s/.test(i.text.charAt(S - 1)) && S--; for (var $ = null, D = null, G = 0; G < u.length; G++) { const U = u[G]; if (!(U.from >= S || U.to <= _)) { const ee = U.level != 1; const ce = Er(n, l, ee ? Math.min(S, U.to) - 1 : Math.max(_, U.from)).right; const ve = ce < p ? p - ce + 1e9 : ce - p; (!$ || D > ve) && ($ = U, D = ve) } } return $ || ($ = u[u.length - 1]), $.from < _ && ($ = { from: _, to: $.to, level: $.level }), $.to > S && ($ = { from: $.from, to: S, level: $.level }), $ } let oo; function Vo(n) {
      if (n.cachedTextHeight != null)
        return n.cachedTextHeight; if (oo == null) { oo = k('pre', null, 'CodeMirror-line-like'); for (let i = 0; i < 49; ++i)oo.appendChild(document.createTextNode('x')), oo.appendChild(k('br')); oo.appendChild(document.createTextNode('x')) }I(n.measure, oo); const a = oo.offsetHeight / 50; return a > 3 && (n.cachedTextHeight = a), V(n.measure), a || 1
    } function jo(n) {
      if (n.cachedCharWidth != null)
        return n.cachedCharWidth; const i = k('span', 'xxxxxxxxxx'); const a = k('pre', [i], 'CodeMirror-line-like'); I(n.measure, a); const l = i.getBoundingClientRect(); const u = (l.right - l.left) / 10; return u > 2 && (n.cachedCharWidth = u), u || 10
    } function sf(n) { for (var i = n.display, a = {}, l = {}, u = i.gutters.clientLeft, p = i.gutters.firstChild, m = 0; p; p = p.nextSibling, ++m) { const w = n.display.gutterSpecs[m].className; a[w] = p.offsetLeft + p.clientLeft + u, l[w] = p.clientWidth } return { fixedPos: lf(i), gutterTotalWidth: i.gutters.offsetWidth, gutterLeft: a, gutterWidth: l, wrapperWidth: i.wrapper.clientWidth } } function lf(n) { return n.scroller.getBoundingClientRect().left - n.sizer.getBoundingClientRect().left } function Xp(n) {
      const i = Vo(n.display); const a = n.options.lineWrapping; const l = a && Math.max(5, n.display.scroller.clientWidth / jo(n.display) - 3); return function (u) {
        if (yi(n.doc, u))
          return 0; let p = 0; if (u.widgets) {
          for (let m = 0; m < u.widgets.length; m++)u.widgets[m].height && (p += u.widgets[m].height)
        } return a ? p + (Math.ceil(u.text.length / l) || 1) * i : p + i
      }
    } function af(n) { const i = n.doc; const a = Xp(n); i.iter((l) => { const u = a(l); u != l.height && Hn(l, u) }) } function so(n, i, a, l) {
      const u = n.display; if (!a && Rs(i).getAttribute('cm-not-content') == 'true')
        return null; let p; let m; const w = u.lineSpace.getBoundingClientRect(); try { p = i.clientX - w.left, m = i.clientY - w.top }
      catch { return null } let _ = rf(n, p, m); let S; if (l && _.xRel > 0 && (S = Pe(n.doc, _.line).text).length == _.ch) { const $ = de(S, S.length, n.options.tabSize) - S.length; _ = Q(_.line, Math.max(0, Math.round((p - Dp(n.display).left) / jo(n.display)) - $)) } return _
    } function lo(n, i) {
      if (i >= n.display.viewTo || (i -= n.display.viewFrom, i < 0))
        return null; for (let a = n.display.view, l = 0; l < a.length; l++) {
        if (i -= a[l].size, i < 0)
          return l
      }
    } function gn(n, i, a, l) {
      i == null && (i = n.doc.first), a == null && (a = n.doc.first + n.doc.size), l || (l = 0); const u = n.display; if (l && a < u.viewTo && (u.updateLineNumbers == null || u.updateLineNumbers > i) && (u.updateLineNumbers = i), n.curOp.viewChanged = !0, i >= u.viewTo) {
        Ur && Ku(n.doc, i) < u.viewTo && wi(n)
      }
      else if (a <= u.viewFrom) {
        Ur && Tp(n.doc, a + l) > u.viewFrom ? wi(n) : (u.viewFrom += l, u.viewTo += l)
      }
      else if (i <= u.viewFrom && a >= u.viewTo) {
        wi(n)
      }
      else if (i <= u.viewFrom) { const p = Na(n, a, a + l, 1); p ? (u.view = u.view.slice(p.index), u.viewFrom = p.lineN, u.viewTo += l) : wi(n) }
      else if (a >= u.viewTo) { const m = Na(n, i, i, -1); m ? (u.view = u.view.slice(0, m.index), u.viewTo = m.lineN) : wi(n) }
      else { const w = Na(n, i, i, -1); const _ = Na(n, a, a + l, 1); w && _ ? (u.view = u.view.slice(0, w.index).concat(Ea(n, w.lineN, _.lineN)).concat(u.view.slice(_.index)), u.viewTo += l) : wi(n) } const S = u.externalMeasured; S && (a < S.lineN ? S.lineN += l : i < S.lineN + S.size && (u.externalMeasured = null))
    } function bi(n, i, a) { n.curOp.viewChanged = !0; const l = n.display; const u = n.display.externalMeasured; if (u && i >= u.lineN && i < u.lineN + u.size && (l.externalMeasured = null), !(i < l.viewFrom || i >= l.viewTo)) { const p = l.view[lo(n, i)]; if (p.node != null) { const m = p.changes || (p.changes = []); Te(m, a) == -1 && m.push(a) } } } function wi(n) { n.display.viewFrom = n.display.viewTo = n.doc.first, n.display.view = [], n.display.viewOffset = 0 } function Na(n, i, a, l) {
      let u = lo(n, i); let p; const m = n.display.view; if (!Ur || a == n.doc.first + n.doc.size)
        return { index: u, lineN: a }; for (var w = n.display.viewFrom, _ = 0; _ < u; _++)w += m[_].size; if (w != i) {
        if (l > 0) {
          if (u == m.length - 1)
            return null; p = w + m[u].size - i, u++
        }
        else {
          p = w - i
        }i += p, a += p
      } for (;Ku(n.doc, a) != a;) {
        if (u == (l < 0 ? 0 : m.length - 1))
          return null; a += l * m[u - (l < 0 ? 1 : 0)].size, u += l
      } return { index: u, lineN: a }
    } function Tx(n, i, a) { const l = n.display; const u = l.view; u.length == 0 || i >= l.viewTo || a <= l.viewFrom ? (l.view = Ea(n, i, a), l.viewFrom = i) : (l.viewFrom > i ? l.view = Ea(n, i, l.viewFrom).concat(l.view) : l.viewFrom < i && (l.view = l.view.slice(lo(n, i))), l.viewFrom = i, l.viewTo < a ? l.view = l.view.concat(Ea(n, l.viewTo, a)) : l.viewTo > a && (l.view = l.view.slice(0, lo(n, a)))), l.viewTo = a } function Yp(n) { for (var i = n.display.view, a = 0, l = 0; l < i.length; l++) { const u = i[l]; !u.hidden && (!u.node || u.changes) && ++a } return a } function Vs(n) { n.display.input.showSelection(n.display.input.prepareSelection()) } function Zp(n, i) {
      i === void 0 && (i = !0); const a = n.doc; const l = {}; const u = l.cursors = document.createDocumentFragment(); const p = l.selection = document.createDocumentFragment(); const m = n.options.$customCursor; m && (i = !0); for (let w = 0; w < a.sel.ranges.length; w++) {
        if (!(!i && w == a.sel.primIndex)) {
          const _ = a.sel.ranges[w]; if (!(_.from().line >= n.display.viewTo || _.to().line < n.display.viewFrom)) {
            const S = _.empty(); if (m) { const $ = m(n, _); $ && cf(n, $, u) }
            else {
              (S || n.options.showCursorWhenSelecting) && cf(n, _.head, u)
            } S || Ex(n, _, p)
          }
        }
      } return l
    } function cf(n, i, a) { const l = hr(n, i, 'div', null, null, !n.options.singleCursorHeightPerLine); const u = a.appendChild(k('div', '', 'CodeMirror-cursor')); if (u.style.left = `${l.left}px`, u.style.top = `${l.top}px`, u.style.height = `${Math.max(0, l.bottom - l.top) * n.options.cursorHeight}px`, /\bcm-fat-cursor\b/.test(n.getWrapperElement().className)) { const p = Ma(n, i, 'div', null, null); const m = p.right - p.left; u.style.width = `${m > 0 ? m : n.defaultCharWidth()}px` } if (l.other) { const w = a.appendChild(k('div', '', 'CodeMirror-cursor CodeMirror-secondarycursor')); w.style.display = '', w.style.left = `${l.other.left}px`, w.style.top = `${l.other.top}px`, w.style.height = `${(l.other.bottom - l.other.top) * 0.85}px` } } function $a(n, i) { return n.top - i.top || n.left - i.left } function Ex(n, i, a) {
      const l = n.display; const u = n.doc; const p = document.createDocumentFragment(); const m = Dp(n.display); const w = m.left; const _ = Math.max(l.sizerWidth, io(n) - l.sizer.offsetLeft) - m.right; const S = u.direction == 'ltr'; function $(we, Le, He, De) {
        Le < 0 && (Le = 0), Le = Math.round(Le), De = Math.round(De), p.appendChild(k('div', null, 'CodeMirror-selected', `position: absolute; left: ${we}px;
  top: ${Le}px; width: ${He ?? _ - we}px;
height: ${De - Le}px`))
      } function D(we, Le, He) {
        const De = Pe(u, we); const Je = De.text.length; let wt; let Vt; function Tt(Pt, yn) { return Ma(n, Q(we, Pt), 'div', De, yn) } function Mn(Pt, yn, Kt) { const Ft = Kp(n, De, null, Pt); const Rt = yn == 'ltr' == (Kt == 'after') ? 'left' : 'right'; const Mt = Kt == 'after' ? Ft.begin : Ft.end - (/\s/.test(De.text.charAt(Ft.end - 1)) ? 2 : 1); return Tt(Mt, Rt)[Rt] } const mn = Ve(De, u.direction); return or(mn, Le || 0, He ?? Je, (Pt, yn, Kt, Ft) => {
          const Rt = Kt == 'ltr'; const Mt = Tt(Pt, Rt ? 'left' : 'right'); const bn = Tt(yn - 1, Rt ? 'right' : 'left'); const os = Le == null && Pt == 0; const Ti = He == null && yn == Je; const rn = Ft == 0; const Lr = !mn || Ft == mn.length - 1; if (bn.top - Mt.top <= 3) { const jt = (S ? os : Ti) && rn; const Df = (S ? Ti : os) && Lr; const Xr = jt ? w : (Rt ? Mt : bn).left; const ho = Df ? _ : (Rt ? bn : Mt).right; $(Xr, Mt.top, ho - Xr, Mt.bottom) }
          else { let po, cn, ss, zf; Rt ? (po = S && os && rn ? w : Mt.left, cn = S ? _ : Mn(Pt, Kt, 'before'), ss = S ? w : Mn(yn, Kt, 'after'), zf = S && Ti && Lr ? _ : bn.right) : (po = S ? Mn(Pt, Kt, 'before') : w, cn = !S && os && rn ? _ : Mt.right, ss = !S && Ti && Lr ? w : bn.left, zf = S ? Mn(yn, Kt, 'after') : _), $(po, Mt.top, cn - po, Mt.bottom), Mt.bottom < bn.top && $(w, Mt.bottom, null, bn.top), $(ss, bn.top, zf - ss, bn.bottom) }(!wt || $a(Mt, wt) < 0) && (wt = Mt), $a(bn, wt) < 0 && (wt = bn), (!Vt || $a(Mt, Vt) < 0) && (Vt = Mt), $a(bn, Vt) < 0 && (Vt = bn)
        }), { start: wt, end: Vt }
      } const G = i.from(); const U = i.to(); if (G.line == U.line) {
        D(G.line, G.ch, U.ch)
      }
      else { const ee = Pe(u, G.line); const ce = Pe(u, U.line); const ve = dr(ee) == dr(ce); const be = D(G.line, G.ch, ve ? ee.text.length + 1 : null).end; const ke = D(U.line, ve ? 0 : null, U.ch).start; ve && (be.top < ke.top - 2 ? ($(be.right, be.top, null, be.bottom), $(w, ke.top, ke.left, ke.bottom)) : $(be.right, be.top, ke.left - be.right, be.bottom)), be.bottom < ke.top && $(w, be.bottom, null, ke.top) }a.appendChild(p)
    } function uf(n) { if (n.state.focused) { const i = n.display; clearInterval(i.blinker); let a = !0; i.cursorDiv.style.visibility = '', n.options.cursorBlinkRate > 0 ? i.blinker = setInterval(() => { n.hasFocus() || Go(n), i.cursorDiv.style.visibility = (a = !a) ? '' : 'hidden' }, n.options.cursorBlinkRate) : n.options.cursorBlinkRate < 0 && (i.cursorDiv.style.visibility = 'hidden') } } function Jp(n) { n.hasFocus() || (n.display.input.focus(), n.state.focused || df(n)) } function ff(n) { n.state.delayingBlurEvent = !0, setTimeout(() => { n.state.delayingBlurEvent && (n.state.delayingBlurEvent = !1, n.state.focused && Go(n)) }, 100) } function df(n, i) { n.state.delayingBlurEvent && !n.state.draggingText && (n.state.delayingBlurEvent = !1), n.options.readOnly != 'nocursor' && (n.state.focused || (Et(n, 'focus', n, i), n.state.focused = !0, Ne(n.display.wrapper, 'CodeMirror-focused'), !n.curOp && n.display.selForContextMenu != n.doc.sel && (n.display.input.reset(), v && setTimeout(() => { return n.display.input.reset(!0) }, 20)), n.display.input.receivedFocus()), uf(n)) } function Go(n, i) { n.state.delayingBlurEvent || (n.state.focused && (Et(n, 'blur', n, i), n.state.focused = !1, K(n.display.wrapper, 'CodeMirror-focused')), clearInterval(n.display.blinker), setTimeout(() => { n.state.focused || (n.display.shift = !1) }, 150)) } function Oa(n) {
      for (var i = n.display, a = i.lineDiv.offsetTop, l = Math.max(0, i.scroller.getBoundingClientRect().top), u = i.lineDiv.getBoundingClientRect().top, p = 0, m = 0; m < i.view.length; m++) {
        const w = i.view[m]; const _ = n.options.lineWrapping; let S = void 0; let $ = 0; if (!w.hidden) {
          if (u += w.line.height, h && g < 8) { const D = w.node.offsetTop + w.node.offsetHeight; S = D - a, a = D }
          else { const G = w.node.getBoundingClientRect(); S = G.bottom - G.top, !_ && w.text.firstChild && ($ = w.text.firstChild.getBoundingClientRect().right - G.left - 1) } const U = w.line.height - S; if ((U > 0.005 || U < -0.005) && (u < l && (p -= U), Hn(w.line, S), Qp(w.line), w.rest)) {
            for (let ee = 0; ee < w.rest.length; ee++)Qp(w.rest[ee])
          } if ($ > n.display.sizerWidth) { const ce = Math.ceil($ / jo(n.display)); ce > n.display.maxLineLength && (n.display.maxLineLength = ce, n.display.maxLine = w.line, n.display.maxLineChanged = !0) }
        }
      }Math.abs(p) > 2 && (i.scroller.scrollTop += p)
    } function Qp(n) {
      if (n.widgets) {
        for (let i = 0; i < n.widgets.length; ++i) { const a = n.widgets[i]; const l = a.node.parentNode; l && (a.height = l.offsetHeight) }
      }
    } function Pa(n, i, a) { let l = a && a.top != null ? Math.max(0, a.top) : n.scroller.scrollTop; l = Math.floor(l - La(n)); const u = a && a.bottom != null ? a.bottom : l + n.wrapper.clientHeight; let p = R(i, l); let m = R(i, u); if (a && a.ensure) { const w = a.ensure.from.line; const _ = a.ensure.to.line; w < p ? (p = w, m = R(i, Vr(Pe(i, w)) + n.wrapper.clientHeight)) : Math.min(_, i.lastLine()) >= m && (p = R(i, Vr(Pe(i, _)) - n.wrapper.clientHeight), m = _) } return { from: p, to: Math.max(m, p + 1) } } function Lx(n, i) {
      if (!Lt(n, 'scrollCursorIntoView')) {
        const a = n.display; const l = a.sizer.getBoundingClientRect(); let u = null; const p = a.wrapper.ownerDocument; if (i.top + l.top < 0 ? u = !0 : i.bottom + l.top > (p.defaultView.innerHeight || p.documentElement.clientHeight) && (u = !1), u != null && !N) {
          const m = k('div', '', null, `position: absolute;
                             top: ${i.top - a.viewOffset - La(n.display)}px;
                         height: ${i.bottom - i.top + Tr(n) + a.barHeight}px;
                         left: ${i.left}px; width: ${Math.max(2, i.right - i.left)}px;`); n.display.lineSpace.appendChild(m), m.scrollIntoView(u), n.display.lineSpace.removeChild(m)
        }
      }
    } function Ax(n, i, a, l) {
      l == null && (l = 0); let u; !n.options.lineWrapping && i == a && (a = i.sticky == 'before' ? Q(i.line, i.ch + 1, 'before') : i, i = i.ch ? Q(i.line, i.sticky == 'before' ? i.ch - 1 : i.ch, 'after') : i); for (let p = 0; p < 5; p++) {
        let m = !1; const w = hr(n, i); const _ = !a || a == i ? w : hr(n, a); u = { left: Math.min(w.left, _.left), top: Math.min(w.top, _.top) - l, right: Math.max(w.left, _.left), bottom: Math.max(w.bottom, _.bottom) + l }; const S = hf(n, u); const $ = n.doc.scrollTop; const D = n.doc.scrollLeft; if (S.scrollTop != null && (Gs(n, S.scrollTop), Math.abs(n.doc.scrollTop - $) > 1 && (m = !0)), S.scrollLeft != null && (ao(n, S.scrollLeft), Math.abs(n.doc.scrollLeft - D) > 1 && (m = !0)), !m)
          break
      } return u
    } function Mx(n, i) { const a = hf(n, i); a.scrollTop != null && Gs(n, a.scrollTop), a.scrollLeft != null && ao(n, a.scrollLeft) } function hf(n, i) {
      const a = n.display; const l = Vo(n.display); i.top < 0 && (i.top = 0); const u = n.curOp && n.curOp.scrollTop != null ? n.curOp.scrollTop : a.scroller.scrollTop; const p = Qu(n); const m = {}; i.bottom - i.top > p && (i.bottom = i.top + p); const w = n.doc.height + Ju(a); const _ = i.top < l; const S = i.bottom > w - l; if (i.top < u) {
        m.scrollTop = _ ? 0 : i.top
      }
      else if (i.bottom > u + p) { const $ = Math.min(i.top, (S ? w : i.bottom) - p); $ != u && (m.scrollTop = $) } const D = n.options.fixedGutter ? 0 : a.gutters.offsetWidth; const G = n.curOp && n.curOp.scrollLeft != null ? n.curOp.scrollLeft : a.scroller.scrollLeft - D; const U = io(n) - a.gutters.offsetWidth; const ee = i.right - i.left > U; return ee && (i.right = i.left + U), i.left < 10 ? m.scrollLeft = 0 : i.left < G ? m.scrollLeft = Math.max(0, i.left + D - (ee ? 0 : 10)) : i.right > U + G - 3 && (m.scrollLeft = i.right + (ee ? 0 : 10) - U), m
    } function pf(n, i) { i != null && (Ra(n), n.curOp.scrollTop = (n.curOp.scrollTop == null ? n.doc.scrollTop : n.curOp.scrollTop) + i) } function Ko(n) { Ra(n); const i = n.getCursor(); n.curOp.scrollToPos = { from: i, to: i, margin: n.options.cursorScrollMargin } } function js(n, i, a) { (i != null || a != null) && Ra(n), i != null && (n.curOp.scrollLeft = i), a != null && (n.curOp.scrollTop = a) } function Nx(n, i) { Ra(n), n.curOp.scrollToPos = i } function Ra(n) { const i = n.curOp.scrollToPos; if (i) { n.curOp.scrollToPos = null; const a = jp(n, i.from); const l = jp(n, i.to); eg(n, a, l, i.margin) } } function eg(n, i, a, l) { const u = hf(n, { left: Math.min(i.left, a.left), top: Math.min(i.top, a.top) - l, right: Math.max(i.right, a.right), bottom: Math.max(i.bottom, a.bottom) + l }); js(n, u.scrollLeft, u.scrollTop) } function Gs(n, i) { Math.abs(n.doc.scrollTop - i) < 2 || (s || vf(n, { top: i }), tg(n, i, !0), s && vf(n), Ys(n, 100)) } function tg(n, i, a) { i = Math.max(0, Math.min(n.display.scroller.scrollHeight - n.display.scroller.clientHeight, i)), !(n.display.scroller.scrollTop == i && !a) && (n.doc.scrollTop = i, n.display.scrollbars.setScrollTop(i), n.display.scroller.scrollTop != i && (n.display.scroller.scrollTop = i)) } function ao(n, i, a, l) { i = Math.max(0, Math.min(i, n.display.scroller.scrollWidth - n.display.scroller.clientWidth)), !((a ? i == n.doc.scrollLeft : Math.abs(n.doc.scrollLeft - i) < 2) && !l) && (n.doc.scrollLeft = i, sg(n), n.display.scroller.scrollLeft != i && (n.display.scroller.scrollLeft = i), n.display.scrollbars.setScrollLeft(i)) } function Ks(n) { const i = n.display; const a = i.gutters.offsetWidth; const l = Math.round(n.doc.height + Ju(n.display)); return { clientHeight: i.scroller.clientHeight, viewHeight: i.wrapper.clientHeight, scrollWidth: i.scroller.scrollWidth, clientWidth: i.scroller.clientWidth, viewWidth: i.wrapper.clientWidth, barLeft: n.options.fixedGutter ? a : 0, docHeight: l, scrollHeight: l + Tr(n) + i.barHeight, nativeBarWidth: i.nativeBarWidth, gutterWidth: a } } const co = function (n, i, a) { this.cm = a; const l = this.vert = k('div', [k('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar'); const u = this.horiz = k('div', [k('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar'); l.tabIndex = u.tabIndex = -1, n(l), n(u), Fe(l, 'scroll', () => { l.clientHeight && i(l.scrollTop, 'vertical') }), Fe(u, 'scroll', () => { u.clientWidth && i(u.scrollLeft, 'horizontal') }), this.checkedZeroWidth = !1, h && g < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = '18px') }; co.prototype.update = function (n) {
      const i = n.scrollWidth > n.clientWidth + 1; const a = n.scrollHeight > n.clientHeight + 1; const l = n.nativeBarWidth; if (a) { this.vert.style.display = 'block', this.vert.style.bottom = i ? `${l}px` : '0'; const u = n.viewHeight - (i ? l : 0); this.vert.firstChild.style.height = `${Math.max(0, n.scrollHeight - n.clientHeight + u)}px` }
      else {
        this.vert.scrollTop = 0, this.vert.style.display = '', this.vert.firstChild.style.height = '0'
      } if (i) { this.horiz.style.display = 'block', this.horiz.style.right = a ? `${l}px` : '0', this.horiz.style.left = `${n.barLeft}px`; const p = n.viewWidth - n.barLeft - (a ? l : 0); this.horiz.firstChild.style.width = `${Math.max(0, n.scrollWidth - n.clientWidth + p)}px` }
      else {
        this.horiz.style.display = '', this.horiz.firstChild.style.width = '0'
      } return !this.checkedZeroWidth && n.clientHeight > 0 && (l == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: a ? l : 0, bottom: i ? l : 0 }
    }, co.prototype.setScrollLeft = function (n) { this.horiz.scrollLeft != n && (this.horiz.scrollLeft = n), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, 'horiz') }, co.prototype.setScrollTop = function (n) { this.vert.scrollTop != n && (this.vert.scrollTop = n), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, 'vert') }, co.prototype.zeroWidthHack = function () { const n = H && !M ? '12px' : '18px'; this.horiz.style.height = this.vert.style.width = n, this.horiz.style.visibility = this.vert.style.visibility = 'hidden', this.disableHoriz = new $e(), this.disableVert = new $e() }, co.prototype.enableZeroWidthBar = function (n, i, a) { n.style.visibility = ''; function l() { const u = n.getBoundingClientRect(); const p = a == 'vert' ? document.elementFromPoint(u.right - 1, (u.top + u.bottom) / 2) : document.elementFromPoint((u.right + u.left) / 2, u.bottom - 1); p != n ? n.style.visibility = 'hidden' : i.set(1e3, l) }i.set(1e3, l) }, co.prototype.clear = function () { const n = this.horiz.parentNode; n.removeChild(this.horiz), n.removeChild(this.vert) }; const Xs = function () {}; Xs.prototype.update = function () { return { bottom: 0, right: 0 } }, Xs.prototype.setScrollLeft = function () {}, Xs.prototype.setScrollTop = function () {}, Xs.prototype.clear = function () {}; function Xo(n, i) { i || (i = Ks(n)); let a = n.display.barWidth; let l = n.display.barHeight; ng(n, i); for (let u = 0; u < 4 && a != n.display.barWidth || l != n.display.barHeight; u++)a != n.display.barWidth && n.options.lineWrapping && Oa(n), ng(n, Ks(n)), a = n.display.barWidth, l = n.display.barHeight } function ng(n, i) { const a = n.display; const l = a.scrollbars.update(i); a.sizer.style.paddingRight = `${a.barWidth = l.right}px`, a.sizer.style.paddingBottom = `${a.barHeight = l.bottom}px`, a.heightForcer.style.borderBottom = `${l.bottom}px solid transparent`, l.right && l.bottom ? (a.scrollbarFiller.style.display = 'block', a.scrollbarFiller.style.height = `${l.bottom}px`, a.scrollbarFiller.style.width = `${l.right}px`) : a.scrollbarFiller.style.display = '', l.bottom && n.options.coverGutterNextToScrollbar && n.options.fixedGutter ? (a.gutterFiller.style.display = 'block', a.gutterFiller.style.height = `${l.bottom}px`, a.gutterFiller.style.width = `${i.gutterWidth}px`) : a.gutterFiller.style.display = '' } const rg = { native: co, null: Xs }; function ig(n) { n.display.scrollbars && (n.display.scrollbars.clear(), n.display.scrollbars.addClass && K(n.display.wrapper, n.display.scrollbars.addClass)), n.display.scrollbars = new rg[n.options.scrollbarStyle]((i) => { n.display.wrapper.insertBefore(i, n.display.scrollbarFiller), Fe(i, 'mousedown', () => { n.state.focused && setTimeout(() => { return n.display.input.focus() }, 0) }), i.setAttribute('cm-not-content', 'true') }, (i, a) => { a == 'horizontal' ? ao(n, i) : Gs(n, i) }, n), n.display.scrollbars.addClass && Ne(n.display.wrapper, n.display.scrollbars.addClass) } let $x = 0; function uo(n) { n.curOp = { cm: n, viewChanged: !1, startHeight: n.doc.height, forceUpdate: !1, updateInput: 0, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++$x, markArrays: null }, cx(n.curOp) } function fo(n) { const i = n.curOp; i && fx(i, (a) => { for (let l = 0; l < a.ops.length; l++)a.ops[l].cm.curOp = null; Ox(a) }) } function Ox(n) { for (var i = n.ops, a = 0; a < i.length; a++)Px(i[a]); for (let l = 0; l < i.length; l++)Rx(i[l]); for (let u = 0; u < i.length; u++)Dx(i[u]); for (let p = 0; p < i.length; p++)zx(i[p]); for (let m = 0; m < i.length; m++)Ix(i[m]) } function Px(n) { const i = n.cm; const a = i.display; Hx(i), n.updateMaxLine && Yu(i), n.mustUpdate = n.viewChanged || n.forceUpdate || n.scrollTop != null || n.scrollToPos && (n.scrollToPos.from.line < a.viewFrom || n.scrollToPos.to.line >= a.viewTo) || a.maxLineChanged && i.options.lineWrapping, n.update = n.mustUpdate && new Da(i, n.mustUpdate && { top: n.scrollTop, ensure: n.scrollToPos }, n.forceUpdate) } function Rx(n) { n.updatedDisplay = n.mustUpdate && gf(n.cm, n.update) } function Dx(n) { const i = n.cm; const a = i.display; n.updatedDisplay && Oa(i), n.barMeasure = Ks(i), a.maxLineChanged && !i.options.lineWrapping && (n.adjustWidthTo = Ip(i, a.maxLine, a.maxLine.text.length).left + 3, i.display.sizerWidth = n.adjustWidthTo, n.barMeasure.scrollWidth = Math.max(a.scroller.clientWidth, a.sizer.offsetLeft + n.adjustWidthTo + Tr(i) + i.display.barWidth), n.maxScrollLeft = Math.max(0, a.sizer.offsetLeft + n.adjustWidthTo - io(i))), (n.updatedDisplay || n.selectionChanged) && (n.preparedSelection = a.input.prepareSelection()) } function zx(n) { const i = n.cm; n.adjustWidthTo != null && (i.display.sizer.style.minWidth = `${n.adjustWidthTo}px`, n.maxScrollLeft < i.doc.scrollLeft && ao(i, Math.min(i.display.scroller.scrollLeft, n.maxScrollLeft), !0), i.display.maxLineChanged = !1); const a = n.focus && n.focus == ye(rt(i)); n.preparedSelection && i.display.input.showSelection(n.preparedSelection, a), (n.updatedDisplay || n.startHeight != i.doc.height) && Xo(i, n.barMeasure), n.updatedDisplay && yf(i, n.barMeasure), n.selectionChanged && uf(i), i.state.focused && n.updateInput && i.display.input.reset(n.typing), a && Jp(n.cm) } function Ix(n) {
      const i = n.cm; const a = i.display; const l = i.doc; if (n.updatedDisplay && og(i, n.update), a.wheelStartX != null && (n.scrollTop != null || n.scrollLeft != null || n.scrollToPos) && (a.wheelStartX = a.wheelStartY = null), n.scrollTop != null && tg(i, n.scrollTop, n.forceScroll), n.scrollLeft != null && ao(i, n.scrollLeft, !0, !0), n.scrollToPos) { const u = Ax(i, Ke(l, n.scrollToPos.from), Ke(l, n.scrollToPos.to), n.scrollToPos.margin); Lx(i, u) } const p = n.maybeHiddenMarkers; const m = n.maybeUnhiddenMarkers; if (p) {
        for (let w = 0; w < p.length; ++w)p[w].lines.length || Et(p[w], 'hide')
      } if (m) {
        for (let _ = 0; _ < m.length; ++_)m[_].lines.length && Et(m[_], 'unhide')
      } a.wrapper.offsetHeight && (l.scrollTop = i.display.scroller.scrollTop), n.changeObjs && Et(i, 'changes', i, n.changeObjs), n.update && n.update.finish()
    } function An(n, i) {
      if (n.curOp)
        return i(); uo(n); try { return i() }
      finally { fo(n) }
    } function Wt(n, i) {
      return function () {
        if (n.curOp)
          return i.apply(n, arguments); uo(n); try { return i.apply(n, arguments) }
        finally { fo(n) }
      }
    } function an(n) {
      return function () {
        if (this.curOp)
          return n.apply(this, arguments); uo(this); try { return n.apply(this, arguments) }
        finally { fo(this) }
      }
    } function Ut(n) {
      return function () {
        const i = this.cm; if (!i || i.curOp)
          return n.apply(this, arguments); uo(i); try { return n.apply(this, arguments) }
        finally { fo(i) }
      }
    } function Ys(n, i) { n.doc.highlightFrontier < n.display.viewTo && n.state.highlight.set(i, X(Fx, n)) } function Fx(n) {
      const i = n.doc; if (!(i.highlightFrontier >= n.display.viewTo)) {
        const a = +new Date() + n.options.workTime; const l = Fs(n, i.highlightFrontier); const u = []; i.iter(l.line, Math.min(i.first + i.size, n.display.viewTo + 500), (p) => {
          if (l.line >= n.display.viewFrom) { const m = p.styles; const w = p.text.length > n.options.maxHighlightLength ? kr(i.mode, l.state) : null; const _ = dp(n, p, l, !0); w && (l.state = w), p.styles = _.styles; const S = p.styleClasses; const $ = _.classes; $ ? p.styleClasses = $ : S && (p.styleClasses = null); for (var D = !m || m.length != p.styles.length || S != $ && (!S || !$ || S.bgClass != $.bgClass || S.textClass != $.textClass), G = 0; !D && G < m.length; ++G)D = m[G] != p.styles[G]; D && u.push(l.line), p.stateAfter = l.save(), l.nextLine() }
          else {
            p.text.length <= n.options.maxHighlightLength && Uu(n, p.text, l), p.stateAfter = l.line % 5 == 0 ? l.save() : null, l.nextLine()
          } if (+new Date() > a)
            return Ys(n, n.options.workDelay), !0
        }), i.highlightFrontier = l.line, i.modeFrontier = Math.max(i.modeFrontier, l.line), u.length && An(n, () => { for (let p = 0; p < u.length; p++)bi(n, u[p], 'text') })
      }
    } var Da = function (n, i, a) { const l = n.display; this.viewport = i, this.visible = Pa(l, n.doc, i), this.editorIsHidden = !l.wrapper.offsetWidth, this.wrapperHeight = l.wrapper.clientHeight, this.wrapperWidth = l.wrapper.clientWidth, this.oldDisplayWidth = io(n), this.force = a, this.dims = sf(n), this.events = [] }; Da.prototype.signal = function (n, i) { Ln(n, i) && this.events.push(arguments) }, Da.prototype.finish = function () { for (let n = 0; n < this.events.length; n++)Et.apply(null, this.events[n]) }; function Hx(n) { const i = n.display; !i.scrollbarsClipped && i.scroller.offsetWidth && (i.nativeBarWidth = i.scroller.offsetWidth - i.scroller.clientWidth, i.heightForcer.style.height = `${Tr(n)}px`, i.sizer.style.marginBottom = `${-i.nativeBarWidth}px`, i.sizer.style.borderRightWidth = `${Tr(n)}px`, i.scrollbarsClipped = !0) } function qx(n) {
      if (n.hasFocus())
        return null; const i = ye(rt(n)); if (!i || !ie(n.display.lineDiv, i))
        return null; const a = { activeElt: i }; if (window.getSelection) { const l = Ee(n).getSelection(); l.anchorNode && l.extend && ie(n.display.lineDiv, l.anchorNode) && (a.anchorNode = l.anchorNode, a.anchorOffset = l.anchorOffset, a.focusNode = l.focusNode, a.focusOffset = l.focusOffset) } return a
    } function Bx(n) { if (!(!n || !n.activeElt || n.activeElt == ye(Ze(n.activeElt))) && (n.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(n.activeElt.nodeName) && n.anchorNode && ie(document.body, n.anchorNode) && ie(document.body, n.focusNode))) { const i = n.activeElt.ownerDocument; const a = i.defaultView.getSelection(); const l = i.createRange(); l.setEnd(n.anchorNode, n.anchorOffset), l.collapse(!1), a.removeAllRanges(), a.addRange(l), a.extend(n.focusNode, n.focusOffset) } } function gf(n, i) {
      const a = n.display; const l = n.doc; if (i.editorIsHidden)
        return wi(n), !1; if (!i.force && i.visible.from >= a.viewFrom && i.visible.to <= a.viewTo && (a.updateLineNumbers == null || a.updateLineNumbers >= a.viewTo) && a.renderedView == a.view && Yp(n) == 0)
        return !1; lg(n) && (wi(n), i.dims = sf(n)); const u = l.first + l.size; let p = Math.max(i.visible.from - n.options.viewportMargin, l.first); let m = Math.min(u, i.visible.to + n.options.viewportMargin); a.viewFrom < p && p - a.viewFrom < 20 && (p = Math.max(l.first, a.viewFrom)), a.viewTo > m && a.viewTo - m < 20 && (m = Math.min(u, a.viewTo)), Ur && (p = Ku(n.doc, p), m = Tp(n.doc, m)); const w = p != a.viewFrom || m != a.viewTo || a.lastWrapHeight != i.wrapperHeight || a.lastWrapWidth != i.wrapperWidth; Tx(n, p, m), a.viewOffset = Vr(Pe(n.doc, a.viewFrom)), n.display.mover.style.top = `${a.viewOffset}px`; const _ = Yp(n); if (!w && _ == 0 && !i.force && a.renderedView == a.view && (a.updateLineNumbers == null || a.updateLineNumbers >= a.viewTo))
        return !1; const S = qx(n); return _ > 4 && (a.lineDiv.style.display = 'none'), Wx(n, a.updateLineNumbers, i.dims), _ > 4 && (a.lineDiv.style.display = ''), a.renderedView = a.view, Bx(S), V(a.cursorDiv), V(a.selectionDiv), a.gutters.style.height = a.sizer.style.minHeight = 0, w && (a.lastWrapHeight = i.wrapperHeight, a.lastWrapWidth = i.wrapperWidth, Ys(n, 400)), a.updateLineNumbers = null, !0
    } function og(n, i) {
      for (let a = i.viewport, l = !0; ;l = !1) {
        if (!l || !n.options.lineWrapping || i.oldDisplayWidth == io(n)) {
          if (a && a.top != null && (a = { top: Math.min(n.doc.height + Ju(n.display) - Qu(n), a.top) }), i.visible = Pa(n.display, n.doc, a), i.visible.from >= n.display.viewFrom && i.visible.to <= n.display.viewTo)
            break
        }
        else {
          l && (i.visible = Pa(n.display, n.doc, a))
        } if (!gf(n, i))
          break; Oa(n); const u = Ks(n); Vs(n), Xo(n, u), yf(n, u), i.force = !1
      }i.signal(n, 'update', n), (n.display.viewFrom != n.display.reportedViewFrom || n.display.viewTo != n.display.reportedViewTo) && (i.signal(n, 'viewportChange', n, n.display.viewFrom, n.display.viewTo), n.display.reportedViewFrom = n.display.viewFrom, n.display.reportedViewTo = n.display.viewTo)
    } function vf(n, i) { const a = new Da(n, i); if (gf(n, a)) { Oa(n), og(n, a); const l = Ks(n); Vs(n), Xo(n, l), yf(n, l), a.finish() } } function Wx(n, i, a) {
      const l = n.display; const u = n.options.lineNumbers; const p = l.lineDiv; let m = p.firstChild; function w(ee) { const ce = ee.nextSibling; return v && H && n.display.currentWheelTarget == ee ? ee.style.display = 'none' : ee.parentNode.removeChild(ee), ce } for (let _ = l.view, S = l.viewFrom, $ = 0; $ < _.length; $++) {
        const D = _[$]; if (!D.hidden) {
          if (!D.node || D.node.parentNode != p) { const G = vx(n, D, S, a); p.insertBefore(G, m) }
          else { for (;m != D.node;)m = w(m); let U = u && i != null && i <= S && D.lineNumber; D.changes && (Te(D.changes, 'gutter') > -1 && (U = !1), Np(n, D, S, a)), U && (V(D.lineNumber), D.lineNumber.appendChild(document.createTextNode(ge(n.options, S)))), m = D.node.nextSibling }
        }S += D.size
      } for (;m;)m = w(m)
    } function mf(n) { const i = n.gutters.offsetWidth; n.sizer.style.marginLeft = `${i}px`, Bt(n, 'gutterChanged', n) } function yf(n, i) { n.display.sizer.style.minHeight = `${i.docHeight}px`, n.display.heightForcer.style.top = `${i.docHeight}px`, n.display.gutters.style.height = `${i.docHeight + n.display.barHeight + Tr(n)}px` } function sg(n) {
      const i = n.display; const a = i.view; if (!(!i.alignWidgets && (!i.gutters.firstChild || !n.options.fixedGutter))) {
        for (var l = lf(i) - i.scroller.scrollLeft + n.doc.scrollLeft, u = i.gutters.offsetWidth, p = `${l}px`, m = 0; m < a.length; m++) {
          if (!a[m].hidden) {
            n.options.fixedGutter && (a[m].gutter && (a[m].gutter.style.left = p), a[m].gutterBackground && (a[m].gutterBackground.style.left = p)); const w = a[m].alignable; if (w) {
              for (let _ = 0; _ < w.length; _++)w[_].style.left = p
            }
          }
        }n.options.fixedGutter && (i.gutters.style.left = `${l + u}px`)
      }
    } function lg(n) {
      if (!n.options.lineNumbers)
        return !1; const i = n.doc; const a = ge(n.options, i.first + i.size - 1); const l = n.display; if (a.length != l.lineNumChars) { const u = l.measure.appendChild(k('div', [k('div', a)], 'CodeMirror-linenumber CodeMirror-gutter-elt')); const p = u.firstChild.offsetWidth; const m = u.offsetWidth - p; return l.lineGutter.style.width = '', l.lineNumInnerWidth = Math.max(p, l.lineGutter.offsetWidth - m) + 1, l.lineNumWidth = l.lineNumInnerWidth + m, l.lineNumChars = l.lineNumInnerWidth ? a.length : -1, l.lineGutter.style.width = `${l.lineNumWidth}px`, mf(n.display), !0 } return !1
    } function bf(n, i) {
      for (var a = [], l = !1, u = 0; u < n.length; u++) {
        let p = n[u]; let m = null; if (typeof p != 'string' && (m = p.style, p = p.className), p == 'CodeMirror-linenumbers') {
          if (i)
            l = !0; else continue
        } a.push({ className: p, style: m })
      } return i && !l && a.push({ className: 'CodeMirror-linenumbers', style: null }), a
    } function ag(n) { const i = n.gutters; const a = n.gutterSpecs; V(i), n.lineGutter = null; for (let l = 0; l < a.length; ++l) { const u = a[l]; const p = u.className; const m = u.style; const w = i.appendChild(k('div', null, `CodeMirror-gutter ${p}`)); m && (w.style.cssText = m), p == 'CodeMirror-linenumbers' && (n.lineGutter = w, w.style.width = `${n.lineNumWidth || 1}px`) }i.style.display = a.length ? '' : 'none', mf(n) } function Zs(n) { ag(n.display), gn(n), sg(n) } function Ux(n, i, a, l) { const u = this; this.input = a, u.scrollbarFiller = k('div', null, 'CodeMirror-scrollbar-filler'), u.scrollbarFiller.setAttribute('cm-not-content', 'true'), u.gutterFiller = k('div', null, 'CodeMirror-gutter-filler'), u.gutterFiller.setAttribute('cm-not-content', 'true'), u.lineDiv = B('div', null, 'CodeMirror-code'), u.selectionDiv = k('div', null, null, 'position: relative; z-index: 1'), u.cursorDiv = k('div', null, 'CodeMirror-cursors'), u.measure = k('div', null, 'CodeMirror-measure'), u.lineMeasure = k('div', null, 'CodeMirror-measure'), u.lineSpace = B('div', [u.measure, u.lineMeasure, u.selectionDiv, u.cursorDiv, u.lineDiv], null, 'position: relative; outline: none'); const p = B('div', [u.lineSpace], 'CodeMirror-lines'); u.mover = k('div', [p], null, 'position: relative'), u.sizer = k('div', [u.mover], 'CodeMirror-sizer'), u.sizerWidth = null, u.heightForcer = k('div', null, null, `position: absolute; height: ${Ye}px; width: 1px;`), u.gutters = k('div', null, 'CodeMirror-gutters'), u.lineGutter = null, u.scroller = k('div', [u.sizer, u.heightForcer, u.gutters], 'CodeMirror-scroll'), u.scroller.setAttribute('tabIndex', '-1'), u.wrapper = k('div', [u.scrollbarFiller, u.gutterFiller, u.scroller], 'CodeMirror'), b && x >= 105 && (u.wrapper.style.clipPath = 'inset(0px)'), u.wrapper.setAttribute('translate', 'no'), h && g < 8 && (u.gutters.style.zIndex = -1, u.scroller.style.paddingRight = 0), !v && !(s && A) && (u.scroller.draggable = !0), n && (n.appendChild ? n.appendChild(u.wrapper) : n(u.wrapper)), u.viewFrom = u.viewTo = i.first, u.reportedViewFrom = u.reportedViewTo = i.first, u.view = [], u.renderedView = null, u.externalMeasured = null, u.viewOffset = 0, u.lastWrapHeight = u.lastWrapWidth = 0, u.updateLineNumbers = null, u.nativeBarWidth = u.barHeight = u.barWidth = 0, u.scrollbarsClipped = !1, u.lineNumWidth = u.lineNumInnerWidth = u.lineNumChars = null, u.alignWidgets = !1, u.cachedCharWidth = u.cachedTextHeight = u.cachedPaddingH = null, u.maxLine = null, u.maxLineLength = 0, u.maxLineChanged = !1, u.wheelDX = u.wheelDY = u.wheelStartX = u.wheelStartY = null, u.shift = !1, u.selForContextMenu = null, u.activeTouch = null, u.gutterSpecs = bf(l.gutters, l.lineNumbers), ag(u), a.init(u) } let za = 0; let Gr = null; h ? Gr = -0.53 : s ? Gr = 15 : b ? Gr = -0.7 : E && (Gr = -1 / 3); function cg(n) { let i = n.wheelDeltaX; let a = n.wheelDeltaY; return i == null && n.detail && n.axis == n.HORIZONTAL_AXIS && (i = n.detail), a == null && n.detail && n.axis == n.VERTICAL_AXIS ? a = n.detail : a == null && (a = n.wheelDelta), { x: i, y: a } } function Vx(n) { const i = cg(n); return i.x *= Gr, i.y *= Gr, i } function ug(n, i) {
      b && x == 102 && (n.display.chromeScrollHack == null ? n.display.sizer.style.pointerEvents = 'none' : clearTimeout(n.display.chromeScrollHack), n.display.chromeScrollHack = setTimeout(() => { n.display.chromeScrollHack = null, n.display.sizer.style.pointerEvents = '' }, 100)); const a = cg(i); let l = a.x; let u = a.y; let p = Gr; i.deltaMode === 0 && (l = i.deltaX, u = i.deltaY, p = 1); const m = n.display; const w = m.scroller; const _ = w.scrollWidth > w.clientWidth; const S = w.scrollHeight > w.clientHeight; if (l && _ || u && S) {
        if (u && H && v) {
          e:for (let $ = i.target, D = m.view; $ != w; $ = $.parentNode) {
            for (let G = 0; G < D.length; G++) {
              if (D[G].node == $) { n.display.currentWheelTarget = $; break e }
            }
          }
        } if (l && !s && !T && p != null) { u && S && Gs(n, Math.max(0, w.scrollTop + u * p)), ao(n, Math.max(0, w.scrollLeft + l * p)), (!u || u && S) && tn(i), m.wheelStartX = null; return } if (u && p != null) { const U = u * p; let ee = n.doc.scrollTop; let ce = ee + m.wrapper.clientHeight; U < 0 ? ee = Math.max(0, ee + U - 50) : ce = Math.min(n.doc.height, ce + U + 50), vf(n, { top: ee, bottom: ce }) }za < 20 && i.deltaMode !== 0 && (m.wheelStartX == null ? (m.wheelStartX = w.scrollLeft, m.wheelStartY = w.scrollTop, m.wheelDX = l, m.wheelDY = u, setTimeout(() => { if (m.wheelStartX != null) { const ve = w.scrollLeft - m.wheelStartX; const be = w.scrollTop - m.wheelStartY; const ke = be && m.wheelDY && be / m.wheelDY || ve && m.wheelDX && ve / m.wheelDX; m.wheelStartX = m.wheelStartY = null, ke && (Gr = (Gr * za + ke) / (za + 1), ++za) } }, 200)) : (m.wheelDX += l, m.wheelDY += u))
      }
    } const qn = function (n, i) { this.ranges = n, this.primIndex = i }; qn.prototype.primary = function () { return this.ranges[this.primIndex] }, qn.prototype.equals = function (n) {
      if (n == this)
        return !0; if (n.primIndex != this.primIndex || n.ranges.length != this.ranges.length)
        return !1; for (let i = 0; i < this.ranges.length; i++) {
        const a = this.ranges[i]; const l = n.ranges[i]; if (!dt(a.anchor, l.anchor) || !dt(a.head, l.head))
          return !1
      } return !0
    }, qn.prototype.deepCopy = function () { for (var n = [], i = 0; i < this.ranges.length; i++)n[i] = new ht(qt(this.ranges[i].anchor), qt(this.ranges[i].head)); return new qn(n, this.primIndex) }, qn.prototype.somethingSelected = function () {
      for (let n = 0; n < this.ranges.length; n++) {
        if (!this.ranges[n].empty())
          return !0
      } return !1
    }, qn.prototype.contains = function (n, i) {
      i || (i = n); for (let a = 0; a < this.ranges.length; a++) {
        const l = this.ranges[a]; if (_e(i, l.from()) >= 0 && _e(n, l.to()) <= 0)
          return a
      } return -1
    }; var ht = function (n, i) { this.anchor = n, this.head = i }; ht.prototype.from = function () { return qo(this.anchor, this.head) }, ht.prototype.to = function () { return pn(this.anchor, this.head) }, ht.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch }; function pr(n, i, a) { const l = n && n.options.selectionsMayTouch; const u = i[a]; i.sort((G, U) => { return _e(G.from(), U.from()) }), a = Te(i, u); for (let p = 1; p < i.length; p++) { const m = i[p]; const w = i[p - 1]; const _ = _e(w.to(), m.from()); if (l && !m.empty() ? _ > 0 : _ >= 0) { const S = qo(w.from(), m.from()); const $ = pn(w.to(), m.to()); const D = w.empty() ? m.from() == m.head : w.from() == w.head; p <= a && --a, i.splice(--p, 2, new ht(D ? $ : S, D ? S : $)) } } return new qn(i, a) } function xi(n, i) { return new qn([new ht(n, i || n)], 0) } function _i(n) { return n.text ? Q(n.from.line + n.text.length - 1, fe(n.text).length + (n.text.length == 1 ? n.from.ch : 0)) : n.to } function fg(n, i) {
      if (_e(n, i.from) < 0)
        return n; if (_e(n, i.to) <= 0)
        return _i(i); const a = n.line + i.text.length - (i.to.line - i.from.line) - 1; let l = n.ch; return n.line == i.to.line && (l += _i(i).ch - i.to.ch), Q(a, l)
    } function wf(n, i) { for (var a = [], l = 0; l < n.sel.ranges.length; l++) { const u = n.sel.ranges[l]; a.push(new ht(fg(u.anchor, i), fg(u.head, i))) } return pr(n.cm, a, n.sel.primIndex) } function dg(n, i, a) { return n.line == i.line ? Q(a.line, n.ch - i.ch + a.ch) : Q(a.line + (n.line - i.line), n.ch) } function jx(n, i, a) {
      for (var l = [], u = Q(n.first, 0), p = u, m = 0; m < i.length; m++) {
        const w = i[m]; const _ = dg(w.from, u, p); const S = dg(_i(w), u, p); if (u = w.to, p = S, a == 'around') { const $ = n.sel.ranges[m]; const D = _e($.head, $.anchor) < 0; l[m] = new ht(D ? S : _, D ? _ : S) }
        else {
          l[m] = new ht(_, _)
        }
      } return new qn(l, n.sel.primIndex)
    } function xf(n) { n.doc.mode = Io(n.options, n.doc.modeOption), Js(n) } function Js(n) { n.doc.iter((i) => { i.stateAfter && (i.stateAfter = null), i.styles && (i.styles = null) }), n.doc.modeFrontier = n.doc.highlightFrontier = n.doc.first, Ys(n, 100), n.state.modeGen++, n.curOp && gn(n) } function hg(n, i) { return i.from.ch == 0 && i.to.ch == 0 && fe(i.text) == '' && (!n.cm || n.cm.options.wholeLineUpdateBefore) } function _f(n, i, a, l) {
      function u(ke) { return a ? a[ke] : null } function p(ke, we, Le) { ex(ke, we, Le, l), Bt(ke, 'change', ke, i) } function m(ke, we) { for (var Le = [], He = ke; He < we; ++He)Le.push(new Bo(S[He], u(He), l)); return Le } const w = i.from; const _ = i.to; var S = i.text; const $ = Pe(n, w.line); const D = Pe(n, _.line); const G = fe(S); const U = u(S.length - 1); const ee = _.line - w.line; if (i.full) {
        n.insert(0, m(0, S.length)), n.remove(S.length, n.size - S.length)
      }
      else if (hg(n, i)) { const ce = m(0, S.length - 1); p(D, D.text, U), ee && n.remove(w.line, ee), ce.length && n.insert(w.line, ce) }
      else if ($ == D) {
        if (S.length == 1) {
          p($, $.text.slice(0, w.ch) + G + $.text.slice(_.ch), U)
        }
        else { const ve = m(1, S.length - 1); ve.push(new Bo(G + $.text.slice(_.ch), U, l)), p($, $.text.slice(0, w.ch) + S[0], u(0)), n.insert(w.line + 1, ve) }
      }
      else if (S.length == 1) {
        p($, $.text.slice(0, w.ch) + S[0] + D.text.slice(_.ch), u(0)), n.remove(w.line + 1, ee)
      }
      else { p($, $.text.slice(0, w.ch) + S[0], u(0)), p(D, G + D.text.slice(_.ch), U); const be = m(1, S.length - 1); ee > 1 && n.remove(w.line + 1, ee - 1), n.insert(w.line + 1, be) }Bt(n, 'change', n, i)
    } function Si(n, i, a) {
      function l(u, p, m) {
        if (u.linked) {
          for (let w = 0; w < u.linked.length; ++w) { const _ = u.linked[w]; if (_.doc != p) { const S = m && _.sharedHist; a && !S || (i(_.doc, S), l(_.doc, u, S)) } }
        }
      }l(n, null, !0)
    } function pg(n, i) {
      if (i.cm)
        throw new Error('This document is already in use.'); n.doc = i, i.cm = n, af(n), xf(n), gg(n), n.options.direction = i.direction, n.options.lineWrapping || Yu(n), n.options.mode = i.modeOption, gn(n)
    } function gg(n) { (n.doc.direction == 'rtl' ? Ne : K)(n.display.lineDiv, 'CodeMirror-rtl') } function Gx(n) { An(n, () => { gg(n), gn(n) }) } function Ia(n) { this.done = [], this.undone = [], this.undoDepth = n ? n.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = n ? n.maxGeneration : 1 } function Sf(n, i) { const a = { from: qt(i.from), to: _i(i), text: Wr(n, i.from, i.to) }; return yg(n, a, i.from.line, i.to.line + 1), Si(n, (l) => { return yg(l, a, i.from.line, i.to.line + 1) }, !0), a } function vg(n) {
      for (;n.length;) {
        const i = fe(n); if (i.ranges)
          n.pop(); else break
      }
    } function Kx(n, i) {
      if (i)
        return vg(n.done), fe(n.done); if (n.done.length && !fe(n.done).ranges)
        return fe(n.done); if (n.done.length > 1 && !n.done[n.done.length - 2].ranges)
        return n.done.pop(), fe(n.done)
    } function mg(n, i, a, l) {
      const u = n.history; u.undone.length = 0; const p = +new Date(); let m; let w; if ((u.lastOp == l || u.lastOrigin == i.origin && i.origin && (i.origin.charAt(0) == '+' && u.lastModTime > p - (n.cm ? n.cm.options.historyEventDelay : 500) || i.origin.charAt(0) == '*')) && (m = Kx(u, u.lastOp == l))) {
        w = fe(m.changes), _e(i.from, i.to) == 0 && _e(i.from, w.to) == 0 ? w.to = _i(i) : m.changes.push(Sf(n, i))
      }
      else { const _ = fe(u.done); for ((!_ || !_.ranges) && Fa(n.sel, u.done), m = { changes: [Sf(n, i)], generation: u.generation }, u.done.push(m); u.done.length > u.undoDepth;)u.done.shift(), u.done[0].ranges || u.done.shift() }u.done.push(a), u.generation = ++u.maxGeneration, u.lastModTime = u.lastSelTime = p, u.lastOp = u.lastSelOp = l, u.lastOrigin = u.lastSelOrigin = i.origin, w || Et(n, 'historyAdded')
    } function Xx(n, i, a, l) { const u = i.charAt(0); return u == '*' || u == '+' && a.ranges.length == l.ranges.length && a.somethingSelected() == l.somethingSelected() && new Date() - n.history.lastSelTime <= (n.cm ? n.cm.options.historyEventDelay : 500) } function Yx(n, i, a, l) { const u = n.history; const p = l && l.origin; a == u.lastSelOp || p && u.lastSelOrigin == p && (u.lastModTime == u.lastSelTime && u.lastOrigin == p || Xx(n, p, fe(u.done), i)) ? u.done[u.done.length - 1] = i : Fa(i, u.done), u.lastSelTime = +new Date(), u.lastSelOrigin = p, u.lastSelOp = a, l && l.clearRedo !== !1 && vg(u.undone) } function Fa(n, i) { const a = fe(i); a && a.ranges && a.equals(n) || i.push(n) } function yg(n, i, a, l) { let u = i[`spans_${n.id}`]; let p = 0; n.iter(Math.max(n.first, a), Math.min(n.first + n.size, l), (m) => { m.markedSpans && ((u || (u = i[`spans_${n.id}`] = {}))[p] = m.markedSpans), ++p }) } function Zx(n) {
      if (!n)
        return null; for (var i, a = 0; a < n.length; ++a)n[a].marker.explicitlyCleared ? i || (i = n.slice(0, a)) : i && i.push(n[a]); return i ? i.length ? i : null : n
    } function Jx(n, i) {
      const a = i[`spans_${n.id}`]; if (!a)
        return null; for (var l = [], u = 0; u < i.text.length; ++u)l.push(Zx(a[u])); return l
    } function bg(n, i) {
      const a = Jx(n, i); const l = ju(n, i); if (!a)
        return l; if (!l)
        return a; for (let u = 0; u < a.length; ++u) {
        const p = a[u]; const m = l[u]; if (p && m) {
          e:for (let w = 0; w < m.length; ++w) {
            for (var _ = m[w], S = 0; S < p.length; ++S) {
              if (p[S].marker == _.marker)
                continue e
            } p.push(_)
          }
        }
        else {
          m && (a[u] = m)
        }
      } return a
    } function Yo(n, i, a) {
      for (var l = [], u = 0; u < n.length; ++u) {
        const p = n[u]; if (p.ranges) { l.push(a ? qn.prototype.deepCopy.call(p) : p); continue } const m = p.changes; const w = []; l.push({ changes: w }); for (let _ = 0; _ < m.length; ++_) {
          const S = m[_]; let $ = void 0; if (w.push({ from: S.from, to: S.to, text: S.text }), i) {
            for (const D in S)($ = D.match(/^spans_(\d+)$/)) && Te(i, Number($[1])) > -1 && (fe(w)[D] = S[D], delete S[D])
          }
        }
      } return l
    } function kf(n, i, a, l) {
      if (l) { let u = n.anchor; if (a) { const p = _e(i, u) < 0; p != _e(a, u) < 0 ? (u = i, i = a) : p != _e(i, a) < 0 && (i = a) } return new ht(u, i) }
      else {
        return new ht(a || i, i)
      }
    } function Ha(n, i, a, l, u) { u == null && (u = n.cm && (n.cm.display.shift || n.extend)), nn(n, new qn([kf(n.sel.primary(), i, a, u)], 0), l) } function wg(n, i, a) { for (var l = [], u = n.cm && (n.cm.display.shift || n.extend), p = 0; p < n.sel.ranges.length; p++)l[p] = kf(n.sel.ranges[p], i[p], null, u); const m = pr(n.cm, l, n.sel.primIndex); nn(n, m, a) } function Cf(n, i, a, l) { const u = n.sel.ranges.slice(0); u[i] = a, nn(n, pr(n.cm, u, n.sel.primIndex), l) } function xg(n, i, a, l) { nn(n, xi(i, a), l) } function Qx(n, i, a) { const l = { ranges: i.ranges, update(u) { this.ranges = []; for (let p = 0; p < u.length; p++) this.ranges[p] = new ht(Ke(n, u[p].anchor), Ke(n, u[p].head)) }, origin: a && a.origin }; return Et(n, 'beforeSelectionChange', n, l), n.cm && Et(n.cm, 'beforeSelectionChange', n.cm, l), l.ranges != i.ranges ? pr(n.cm, l.ranges, l.ranges.length - 1) : i } function _g(n, i, a) { const l = n.history.done; const u = fe(l); u && u.ranges ? (l[l.length - 1] = i, qa(n, i, a)) : nn(n, i, a) } function nn(n, i, a) { qa(n, i, a), Yx(n, n.sel, n.cm ? n.cm.curOp.id : Number.NaN, a) } function qa(n, i, a) { (Ln(n, 'beforeSelectionChange') || n.cm && Ln(n.cm, 'beforeSelectionChange')) && (i = Qx(n, i, a)); const l = a && a.bias || (_e(i.primary().head, n.sel.primary().head) < 0 ? -1 : 1); Sg(n, Cg(n, i, l, !0)), !(a && a.scroll === !1) && n.cm && n.cm.getOption('readOnly') != 'nocursor' && Ko(n.cm) } function Sg(n, i) { i.equals(n.sel) || (n.sel = i, n.cm && (n.cm.curOp.updateInput = 1, n.cm.curOp.selectionChanged = !0, Kn(n.cm)), Bt(n, 'cursorActivity', n)) } function kg(n) { Sg(n, Cg(n, n.sel, null, !1)) } function Cg(n, i, a, l) { for (var u, p = 0; p < i.ranges.length; p++) { const m = i.ranges[p]; const w = i.ranges.length == n.sel.ranges.length && n.sel.ranges[p]; const _ = Ba(n, m.anchor, w && w.anchor, a, l); const S = m.head == m.anchor ? _ : Ba(n, m.head, w && w.head, a, l); (u || _ != m.anchor || S != m.head) && (u || (u = i.ranges.slice(0, p)), u[p] = new ht(_, S)) } return u ? pr(n.cm, u, i.primIndex) : i } function Zo(n, i, a, l, u) {
      const p = Pe(n, i.line); if (p.markedSpans) {
        for (let m = 0; m < p.markedSpans.length; ++m) {
          const w = p.markedSpans[m]; const _ = w.marker; const S = 'selectLeft' in _ ? !_.selectLeft : _.inclusiveLeft; const $ = 'selectRight' in _ ? !_.selectRight : _.inclusiveRight; if ((w.from == null || (S ? w.from <= i.ch : w.from < i.ch)) && (w.to == null || ($ ? w.to >= i.ch : w.to > i.ch))) {
            if (u && (Et(_, 'beforeCursorEnter'), _.explicitlyCleared)) {
              if (p.markedSpans) { --m; continue }
              else {
                break
              }
            } if (!_.atomic)
              continue; if (a) {
              let D = _.find(l < 0 ? 1 : -1); let G = void 0; if ((l < 0 ? $ : S) && (D = Tg(n, D, -l, D && D.line == i.line ? p : null)), D && D.line == i.line && (G = _e(D, a)) && (l < 0 ? G < 0 : G > 0))
                return Zo(n, D, i, l, u)
            } let U = _.find(l < 0 ? -1 : 1); return (l < 0 ? S : $) && (U = Tg(n, U, l, U.line == i.line ? p : null)), U ? Zo(n, U, i, l, u) : null
          }
        }
      } return i
    } function Ba(n, i, a, l, u) { const p = l || 1; const m = Zo(n, i, a, p, u) || !u && Zo(n, i, a, p, !0) || Zo(n, i, a, -p, u) || !u && Zo(n, i, a, -p, !0); return m || (n.cantEdit = !0, Q(n.first, 0)) } function Tg(n, i, a, l) { return a < 0 && i.ch == 0 ? i.line > n.first ? Ke(n, Q(i.line - 1)) : null : a > 0 && i.ch == (l || Pe(n, i.line)).text.length ? i.line < n.first + n.size - 1 ? Q(i.line + 1, 0) : null : new Q(i.line, i.ch + a) } function Eg(n) { n.setSelection(Q(n.firstLine(), 0), Q(n.lastLine()), F) } function Lg(n, i, a) { var l = { canceled: !1, from: i.from, to: i.to, text: i.text, origin: i.origin, cancel() { return l.canceled = !0 } }; return a && (l.update = function (u, p, m, w) { u && (l.from = Ke(n, u)), p && (l.to = Ke(n, p)), m && (l.text = m), w !== void 0 && (l.origin = w) }), Et(n, 'beforeChange', n, l), n.cm && Et(n.cm, 'beforeChange', n.cm, l), l.canceled ? (n.cm && (n.cm.curOp.updateInput = 2), null) : { from: l.from, to: l.to, text: l.text, origin: l.origin } } function Jo(n, i, a) {
      if (n.cm) {
        if (!n.cm.curOp)
          return Wt(n.cm, Jo)(n, i, a); if (n.cm.state.suppressEdits)
          return
      } if (!((Ln(n, 'beforeChange') || n.cm && Ln(n.cm, 'beforeChange')) && (i = Lg(n, i, !0), !i))) {
        const l = bp && !a && Y1(n, i.from, i.to); if (l) {
          for (let u = l.length - 1; u >= 0; --u)Ag(n, { from: l[u].from, to: l[u].to, text: u ? [''] : i.text, origin: i.origin })
        }
        else {
          Ag(n, i)
        }
      }
    } function Ag(n, i) { if (!(i.text.length == 1 && i.text[0] == '' && _e(i.from, i.to) == 0)) { const a = wf(n, i); mg(n, i, a, n.cm ? n.cm.curOp.id : Number.NaN), Qs(n, i, a, ju(n, i)); const l = []; Si(n, (u, p) => { !p && Te(l, u.history) == -1 && (Og(u.history, i), l.push(u.history)), Qs(u, i, null, ju(u, i)) }) } } function Wa(n, i, a) {
      const l = n.cm && n.cm.state.suppressEdits; if (!(l && !a)) {
        for (var u = n.history, p, m = n.sel, w = i == 'undo' ? u.done : u.undone, _ = i == 'undo' ? u.undone : u.done, S = 0; S < w.length && (p = w[S], !(a ? p.ranges && !p.equals(n.sel) : !p.ranges)); S++);if (S != w.length) {
          for (u.lastOrigin = u.lastSelOrigin = null; ;) {
            if (p = w.pop(), p.ranges) { if (Fa(p, _), a && !p.equals(n.sel)) { nn(n, p, { clearRedo: !1 }); return }m = p }
            else if (l) { w.push(p); return }
            else {
              break
            }
          } const $ = []; Fa(m, _), _.push({ changes: $, generation: u.generation }), u.generation = p.generation || ++u.maxGeneration; for (var D = Ln(n, 'beforeChange') || n.cm && Ln(n.cm, 'beforeChange'), G = function (ce) {
              const ve = p.changes[ce]; if (ve.origin = i, D && !Lg(n, ve, !1))
                return w.length = 0, {}; $.push(Sf(n, ve)); const be = ce ? wf(n, ve) : fe(w); Qs(n, ve, be, bg(n, ve)), !ce && n.cm && n.cm.scrollIntoView({ from: ve.from, to: _i(ve) }); const ke = []; Si(n, (we, Le) => { !Le && Te(ke, we.history) == -1 && (Og(we.history, ve), ke.push(we.history)), Qs(we, ve, null, bg(we, ve)) })
            }, U = p.changes.length - 1; U >= 0; --U) {
            const ee = G(U); if (ee)
              return ee.v
          }
        }
      }
    } function Mg(n, i) { if (i != 0 && (n.first += i, n.sel = new qn(xe(n.sel.ranges, (u) => { return new ht(Q(u.anchor.line + i, u.anchor.ch), Q(u.head.line + i, u.head.ch)) }), n.sel.primIndex), n.cm)) { gn(n.cm, n.first, n.first - i, i); for (let a = n.cm.display, l = a.viewFrom; l < a.viewTo; l++)bi(n.cm, l, 'gutter') } } function Qs(n, i, a, l) {
      if (n.cm && !n.cm.curOp)
        return Wt(n.cm, Qs)(n, i, a, l); if (i.to.line < n.first) { Mg(n, i.text.length - 1 - (i.to.line - i.from.line)); return } if (!(i.from.line > n.lastLine())) { if (i.from.line < n.first) { const u = i.text.length - 1 - (n.first - i.from.line); Mg(n, u), i = { from: Q(n.first, 0), to: Q(i.to.line + u, i.to.ch), text: [fe(i.text)], origin: i.origin } } const p = n.lastLine(); i.to.line > p && (i = { from: i.from, to: Q(p, Pe(n, p).text.length), text: [i.text[0]], origin: i.origin }), i.removed = Wr(n, i.from, i.to), a || (a = wf(n, i)), n.cm ? e_(n.cm, i, l) : _f(n, i, l), qa(n, a, F), n.cantEdit && Ba(n, Q(n.firstLine(), 0)) && (n.cantEdit = !1) }
    } function e_(n, i, a) {
      const l = n.doc; const u = n.display; const p = i.from; const m = i.to; let w = !1; let _ = p.line; n.options.lineWrapping || (_ = C(dr(Pe(l, p.line))), l.iter(_, m.line + 1, (U) => {
        if (U == u.maxLine)
          return w = !0, !0
      })), l.sel.contains(i.from, i.to) > -1 && Kn(n), _f(l, i, a, Xp(n)), n.options.lineWrapping || (l.iter(_, p.line + i.text.length, (U) => { const ee = Ta(U); ee > u.maxLineLength && (u.maxLine = U, u.maxLineLength = ee, u.maxLineChanged = !0, w = !1) }), w && (n.curOp.updateMaxLine = !0)), W1(l, p.line), Ys(n, 400); const S = i.text.length - (m.line - p.line) - 1; i.full ? gn(n) : p.line == m.line && i.text.length == 1 && !hg(n.doc, i) ? bi(n, p.line, 'text') : gn(n, p.line, m.line + 1, S); const $ = Ln(n, 'changes'); const D = Ln(n, 'change'); if (D || $) { const G = { from: p, to: m, text: i.text, removed: i.removed, origin: i.origin }; D && Bt(n, 'change', n, G), $ && (n.curOp.changeObjs || (n.curOp.changeObjs = [])).push(G) }n.display.selForContextMenu = null
    } function Qo(n, i, a, l, u) { let p; l || (l = a), _e(l, a) < 0 && (p = [l, a], a = p[0], l = p[1]), typeof i == 'string' && (i = n.splitLines(i)), Jo(n, { from: a, to: l, text: i, origin: u }) } function Ng(n, i, a, l) { a < n.line ? n.line += l : i < n.line && (n.line = i, n.ch = 0) } function $g(n, i, a, l) {
      for (let u = 0; u < n.length; ++u) {
        let p = n[u]; let m = !0; if (p.ranges) { p.copied || (p = n[u] = p.deepCopy(), p.copied = !0); for (let w = 0; w < p.ranges.length; w++)Ng(p.ranges[w].anchor, i, a, l), Ng(p.ranges[w].head, i, a, l); continue } for (let _ = 0; _ < p.changes.length; ++_) {
          const S = p.changes[_]; if (a < S.from.line) {
            S.from = Q(S.from.line + l, S.from.ch), S.to = Q(S.to.line + l, S.to.ch)
          }
          else if (i <= S.to.line) { m = !1; break }
        }m || (n.splice(0, u + 1), u = 0)
      }
    } function Og(n, i) { const a = i.from.line; const l = i.to.line; const u = i.text.length - (l - a) - 1; $g(n.done, a, l, u), $g(n.undone, a, l, u) } function el(n, i, a, l) { let u = i; let p = i; return typeof i == 'number' ? p = Pe(n, up(n, i)) : u = C(i), u == null ? null : (l(p, u) && n.cm && bi(n.cm, u, a), p) } function tl(n) { this.lines = n, this.parent = null; for (var i = 0, a = 0; a < n.length; ++a)n[a].parent = this, i += n[a].height; this.height = i }tl.prototype = { chunkSize() { return this.lines.length }, removeInner(n, i) { for (let a = n, l = n + i; a < l; ++a) { const u = this.lines[a]; this.height -= u.height, tx(u), Bt(u, 'delete') } this.lines.splice(n, i) }, collapse(n) { n.push.apply(n, this.lines) }, insertInner(n, i, a) { this.height += a, this.lines = this.lines.slice(0, n).concat(i).concat(this.lines.slice(n)); for (let l = 0; l < i.length; ++l)i[l].parent = this }, iterN(n, i, a) {
      for (let l = n + i; n < l; ++n) {
        if (a(this.lines[n]))
          return !0
      }
    } }; function nl(n) { this.children = n; for (var i = 0, a = 0, l = 0; l < n.length; ++l) { const u = n[l]; i += u.chunkSize(), a += u.height, u.parent = this } this.size = i, this.height = a, this.parent = null }nl.prototype = { chunkSize() { return this.size }, removeInner(n, i) {
      this.size -= i; for (let a = 0; a < this.children.length; ++a) {
        const l = this.children[a]; const u = l.chunkSize(); if (n < u) {
          const p = Math.min(i, u - n); const m = l.height; if (l.removeInner(n, p), this.height -= m - l.height, u == p && (this.children.splice(a--, 1), l.parent = null), (i -= p) == 0)
            break; n = 0
        }
        else {
          n -= u
        }
      } if (this.size - i < 25 && (this.children.length > 1 || !(this.children[0] instanceof tl))) { const w = []; this.collapse(w), this.children = [new tl(w)], this.children[0].parent = this }
    }, collapse(n) { for (let i = 0; i < this.children.length; ++i) this.children[i].collapse(n) }, insertInner(n, i, a) { this.size += i.length, this.height += a; for (let l = 0; l < this.children.length; ++l) { const u = this.children[l]; const p = u.chunkSize(); if (n <= p) { if (u.insertInner(n, i, a), u.lines && u.lines.length > 50) { for (var m = u.lines.length % 25 + 25, w = m; w < u.lines.length;) { const _ = new tl(u.lines.slice(w, w += 25)); u.height -= _.height, this.children.splice(++l, 0, _), _.parent = this }u.lines = u.lines.slice(0, m), this.maybeSpill() } break }n -= p } }, maybeSpill() {
      if (!(this.children.length <= 10)) {
        let n = this; do {
          const i = n.children.splice(n.children.length - 5, 5); const a = new nl(i); if (n.parent) { n.size -= a.size, n.height -= a.height; const u = Te(n.parent.children, n); n.parent.children.splice(u + 1, 0, a) }
          else { const l = new nl(n.children); l.parent = n, n.children = [l, a], n = l }a.parent = n.parent
        } while (n.children.length > 10); n.parent.maybeSpill()
      }
    }, iterN(n, i, a) {
      for (let l = 0; l < this.children.length; ++l) {
        const u = this.children[l]; const p = u.chunkSize(); if (n < p) {
          const m = Math.min(i, p - n); if (u.iterN(n, m, a))
            return !0; if ((i -= m) == 0)
            break; n = 0
        }
        else {
          n -= p
        }
      }
    } }; const rl = function (n, i, a) {
      if (a) {
        for (const l in a)a.hasOwnProperty(l) && (this[l] = a[l])
      } this.doc = n, this.node = i
    }; rl.prototype.clear = function () { const n = this.doc.cm; const i = this.line.widgets; const a = this.line; const l = C(a); if (!(l == null || !i)) { for (let u = 0; u < i.length; ++u)i[u] == this && i.splice(u--, 1); i.length || (a.widgets = null); const p = Ws(this); Hn(a, Math.max(0, a.height - p)), n && (An(n, () => { Pg(n, a, -p), bi(n, l, 'widget') }), Bt(n, 'lineWidgetCleared', n, this, l)) } }, rl.prototype.changed = function () { const n = this; const i = this.height; const a = this.doc.cm; const l = this.line; this.height = null; const u = Ws(this) - i; u && (yi(this.doc, l) || Hn(l, l.height + u), a && An(a, () => { a.curOp.forceUpdate = !0, Pg(a, l, u), Bt(a, 'lineWidgetChanged', a, n, C(l)) })) }, lr(rl); function Pg(n, i, a) { Vr(i) < (n.curOp && n.curOp.scrollTop || n.doc.scrollTop) && pf(n, a) } function t_(n, i, a, l) { const u = new rl(n, a, l); const p = n.cm; return p && u.noHScroll && (p.display.alignWidgets = !0), el(n, i, 'widget', (m) => { const w = m.widgets || (m.widgets = []); if (u.insertAt == null ? w.push(u) : w.splice(Math.min(w.length, Math.max(0, u.insertAt)), 0, u), u.line = m, p && !yi(n, m)) { const _ = Vr(m) < n.scrollTop; Hn(m, m.height + Ws(u)), _ && pf(p, u.height), p.curOp.forceUpdate = !0 } return !0 }), p && Bt(p, 'lineWidgetAdded', p, u, typeof i == 'number' ? i : C(i)), u } let Rg = 0; const ki = function (n, i) { this.lines = [], this.type = i, this.doc = n, this.id = ++Rg }; ki.prototype.clear = function () {
      if (!this.explicitlyCleared) {
        const n = this.doc.cm; const i = n && !n.curOp; if (i && uo(n), Ln(this, 'clear')) { const a = this.find(); a && Bt(this, 'clear', a.from, a.to) } for (var l = null, u = null, p = 0; p < this.lines.length; ++p) { const m = this.lines[p]; const w = Hs(m.markedSpans, this); n && !this.collapsed ? bi(n, C(m), 'text') : n && (w.to != null && (u = C(m)), w.from != null && (l = C(m))), m.markedSpans = j1(m.markedSpans, w), w.from == null && this.collapsed && !yi(this.doc, m) && n && Hn(m, Vo(n.display)) } if (n && this.collapsed && !n.options.lineWrapping) {
          for (let _ = 0; _ < this.lines.length; ++_) { const S = dr(this.lines[_]); const $ = Ta(S); $ > n.display.maxLineLength && (n.display.maxLine = S, n.display.maxLineLength = $, n.display.maxLineChanged = !0) }
        }l != null && n && this.collapsed && gn(n, l, u + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, n && kg(n.doc)), n && Bt(n, 'markerCleared', n, this, l, u), i && fo(n), this.parent && this.parent.clear()
      }
    }, ki.prototype.find = function (n, i) {
      n == null && this.type == 'bookmark' && (n = 1); for (var a, l, u = 0; u < this.lines.length; ++u) {
        const p = this.lines[u]; const m = Hs(p.markedSpans, this); if (m.from != null && (a = Q(i ? p : C(p), m.from), n == -1))
          return a; if (m.to != null && (l = Q(i ? p : C(p), m.to), n == 1))
          return l
      } return a && { from: a, to: l }
    }, ki.prototype.changed = function () { const n = this; const i = this.find(-1, !0); const a = this; const l = this.doc.cm; !i || !l || An(l, () => { const u = i.line; const p = C(i.line); const m = ef(l, p); if (m && (qp(m), l.curOp.selectionChanged = l.curOp.forceUpdate = !0), l.curOp.updateMaxLine = !0, !yi(a.doc, u) && a.height != null) { const w = a.height; a.height = null; const _ = Ws(a) - w; _ && Hn(u, u.height + _) }Bt(l, 'markerChanged', l, n) }) }, ki.prototype.attachLine = function (n) { if (!this.lines.length && this.doc.cm) { const i = this.doc.cm.curOp; (!i.maybeHiddenMarkers || Te(i.maybeHiddenMarkers, this) == -1) && (i.maybeUnhiddenMarkers || (i.maybeUnhiddenMarkers = [])).push(this) } this.lines.push(n) }, ki.prototype.detachLine = function (n) { if (this.lines.splice(Te(this.lines, n), 1), !this.lines.length && this.doc.cm) { const i = this.doc.cm.curOp; (i.maybeHiddenMarkers || (i.maybeHiddenMarkers = [])).push(this) } }, lr(ki); function es(n, i, a, l, u) {
      if (l && l.shared)
        return n_(n, i, a, l, u); if (n.cm && !n.cm.curOp)
        return Wt(n.cm, es)(n, i, a, l, u); const p = new ki(n, u); const m = _e(i, a); if (l && ae(l, p, !1), m > 0 || m == 0 && p.clearWhenEmpty !== !1)
        return p; if (p.replacedWith && (p.collapsed = !0, p.widgetNode = B('span', [p.replacedWith], 'CodeMirror-widget'), l.handleMouseEvents || p.widgetNode.setAttribute('cm-ignore-events', 'true'), l.insertLeft && (p.widgetNode.insertLeft = !0)), p.collapsed) {
        if (Cp(n, i.line, i, a, p) || i.line != a.line && Cp(n, a.line, i, a, p))
          throw new Error('Inserting collapsed marker partially overlapping an existing one'); V1()
      }p.addToHistory && mg(n, { from: i, to: a, origin: 'markText' }, n.sel, Number.NaN); let w = i.line; const _ = n.cm; let S; if (n.iter(w, a.line + 1, (D) => { _ && p.collapsed && !_.options.lineWrapping && dr(D) == _.display.maxLine && (S = !0), p.collapsed && w != i.line && Hn(D, 0), G1(D, new _a(p, w == i.line ? i.ch : null, w == a.line ? a.ch : null), n.cm && n.cm.curOp), ++w }), p.collapsed && n.iter(i.line, a.line + 1, (D) => { yi(n, D) && Hn(D, 0) }), p.clearOnEnter && Fe(p, 'beforeCursorEnter', () => { return p.clear() }), p.readOnly && (U1(), (n.history.done.length || n.history.undone.length) && n.clearHistory()), p.collapsed && (p.id = ++Rg, p.atomic = !0), _) {
        if (S && (_.curOp.updateMaxLine = !0), p.collapsed) {
          gn(_, i.line, a.line + 1)
        }
        else if (p.className || p.startStyle || p.endStyle || p.css || p.attributes || p.title) {
          for (let $ = i.line; $ <= a.line; $++)bi(_, $, 'text')
        } p.atomic && kg(_.doc), Bt(_, 'markerAdded', _, p)
      } return p
    } const il = function (n, i) { this.markers = n, this.primary = i; for (let a = 0; a < n.length; ++a)n[a].parent = this }; il.prototype.clear = function () { if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (let n = 0; n < this.markers.length; ++n) this.markers[n].clear(); Bt(this, 'clear') } }, il.prototype.find = function (n, i) { return this.primary.find(n, i) }, lr(il); function n_(n, i, a, l, u) {
      l = ae(l), l.shared = !1; const p = [es(n, i, a, l, u)]; let m = p[0]; const w = l.widgetNode; return Si(n, (_) => {
        w && (l.widgetNode = w.cloneNode(!0)), p.push(es(_, Ke(_, i), Ke(_, a), l, u)); for (let S = 0; S < _.linked.length; ++S) {
          if (_.linked[S].isParent)
            return
        } m = fe(p)
      }), new il(p, m)
    } function Dg(n) { return n.findMarks(Q(n.first, 0), n.clipPos(Q(n.lastLine())), (i) => { return i.parent }) } function r_(n, i) { for (let a = 0; a < i.length; a++) { const l = i[a]; const u = l.find(); const p = n.clipPos(u.from); const m = n.clipPos(u.to); if (_e(p, m)) { const w = es(n, p, m, l.primary, l.primary.type); l.markers.push(w), w.parent = l } } } function i_(n) { for (let i = function (l) { const u = n[l]; const p = [u.primary.doc]; Si(u.primary.doc, (_) => { return p.push(_) }); for (let m = 0; m < u.markers.length; m++) { const w = u.markers[m]; Te(p, w.doc) == -1 && (w.parent = null, u.markers.splice(m--, 1)) } }, a = 0; a < n.length; a++)i(a) } let o_ = 0; const vn = function (n, i, a, l, u) {
      if (!(this instanceof vn))
        return new vn(n, i, a, l, u); a == null && (a = 0), nl.call(this, [new tl([new Bo('', null)])]), this.first = a, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = a; const p = Q(a, 0); this.sel = xi(p), this.history = new Ia(null), this.id = ++o_, this.modeOption = i, this.lineSep = l, this.direction = u == 'rtl' ? 'rtl' : 'ltr', this.extend = !1, typeof n == 'string' && (n = this.splitLines(n)), _f(this, { from: p, to: p, text: n }), nn(this, xi(p), F)
    }; vn.prototype = ze(nl.prototype, { constructor: vn, iter(n, i, a) { a ? this.iterN(n - this.first, i - n, a) : this.iterN(this.first, this.first + this.size, n) }, insert(n, i) { for (var a = 0, l = 0; l < i.length; ++l)a += i[l].height; this.insertInner(n - this.first, i, a) }, remove(n, i) { this.removeInner(n - this.first, i) }, getValue(n) { const i = Is(this, this.first, this.first + this.size); return n === !1 ? i : i.join(n || this.lineSeparator()) }, setValue: Ut(function (n) { const i = Q(this.first, 0); const a = this.first + this.size - 1; Jo(this, { from: i, to: Q(a, Pe(this, a).text.length), text: this.splitLines(n), origin: 'setValue', full: !0 }, !0), this.cm && js(this.cm, 0, 0), nn(this, xi(i), F) }), replaceRange(n, i, a, l) { i = Ke(this, i), a = a ? Ke(this, a) : i, Qo(this, n, i, a, l) }, getRange(n, i, a) { const l = Wr(this, Ke(this, n), Ke(this, i)); return a === !1 ? l : a === '' ? l.join('') : l.join(a || this.lineSeparator()) }, getLine(n) { const i = this.getLineHandle(n); return i && i.text }, getLineHandle(n) {
      if (se(this, n))
        return Pe(this, n)
    }, getLineNumber(n) { return C(n) }, getLineHandleVisualStart(n) { return typeof n == 'number' && (n = Pe(this, n)), dr(n) }, lineCount() { return this.size }, firstLine() { return this.first }, lastLine() { return this.first + this.size - 1 }, clipPos(n) { return Ke(this, n) }, getCursor(n) { const i = this.sel.primary(); let a; return n == null || n == 'head' ? a = i.head : n == 'anchor' ? a = i.anchor : n == 'end' || n == 'to' || n === !1 ? a = i.to() : a = i.from(), a }, listSelections() { return this.sel.ranges }, somethingSelected() { return this.sel.somethingSelected() }, setCursor: Ut(function (n, i, a) { xg(this, Ke(this, typeof n == 'number' ? Q(n, i || 0) : n), null, a) }), setSelection: Ut(function (n, i, a) { xg(this, Ke(this, n), Ke(this, i || n), a) }), extendSelection: Ut(function (n, i, a) { Ha(this, Ke(this, n), i && Ke(this, i), a) }), extendSelections: Ut(function (n, i) { wg(this, fp(this, n), i) }), extendSelectionsBy: Ut(function (n, i) { const a = xe(this.sel.ranges, n); wg(this, fp(this, a), i) }), setSelections: Ut(function (n, i, a) { if (n.length) { for (var l = [], u = 0; u < n.length; u++)l[u] = new ht(Ke(this, n[u].anchor), Ke(this, n[u].head || n[u].anchor)); i == null && (i = Math.min(n.length - 1, this.sel.primIndex)), nn(this, pr(this.cm, l, i), a) } }), addSelection: Ut(function (n, i, a) { const l = this.sel.ranges.slice(0); l.push(new ht(Ke(this, n), Ke(this, i || n))), nn(this, pr(this.cm, l, l.length - 1), a) }), getSelection(n) { for (var i = this.sel.ranges, a, l = 0; l < i.length; l++) { const u = Wr(this, i[l].from(), i[l].to()); a = a ? a.concat(u) : u } return n === !1 ? a : a.join(n || this.lineSeparator()) }, getSelections(n) { for (var i = [], a = this.sel.ranges, l = 0; l < a.length; l++) { let u = Wr(this, a[l].from(), a[l].to()); n !== !1 && (u = u.join(n || this.lineSeparator())), i[l] = u } return i }, replaceSelection(n, i, a) { for (var l = [], u = 0; u < this.sel.ranges.length; u++)l[u] = n; this.replaceSelections(l, i, a || '+input') }, replaceSelections: Ut(function (n, i, a) { for (var l = [], u = this.sel, p = 0; p < u.ranges.length; p++) { const m = u.ranges[p]; l[p] = { from: m.from(), to: m.to(), text: this.splitLines(n[p]), origin: a } } for (var w = i && i != 'end' && jx(this, l, i), _ = l.length - 1; _ >= 0; _--)Jo(this, l[_]); w ? _g(this, w) : this.cm && Ko(this.cm) }), undo: Ut(function () { Wa(this, 'undo') }), redo: Ut(function () { Wa(this, 'redo') }), undoSelection: Ut(function () { Wa(this, 'undo', !0) }), redoSelection: Ut(function () { Wa(this, 'redo', !0) }), setExtending(n) { this.extend = n }, getExtending() { return this.extend }, historySize() { for (var n = this.history, i = 0, a = 0, l = 0; l < n.done.length; l++)n.done[l].ranges || ++i; for (let u = 0; u < n.undone.length; u++)n.undone[u].ranges || ++a; return { undo: i, redo: a } }, clearHistory() { const n = this; this.history = new Ia(this.history), Si(this, (i) => { return i.history = n.history }, !0) }, markClean() { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration(n) { return n && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean(n) { return this.history.generation == (n || this.cleanGeneration) }, getHistory() { return { done: Yo(this.history.done), undone: Yo(this.history.undone) } }, setHistory(n) { const i = this.history = new Ia(this.history); i.done = Yo(n.done.slice(0), null, !0), i.undone = Yo(n.undone.slice(0), null, !0) }, setGutterMarker: Ut(function (n, i, a) { return el(this, n, 'gutter', (l) => { const u = l.gutterMarkers || (l.gutterMarkers = {}); return u[i] = a, !a && vt(u) && (l.gutterMarkers = null), !0 }) }), clearGutter: Ut(function (n) { const i = this; this.iter((a) => { a.gutterMarkers && a.gutterMarkers[n] && el(i, a, 'gutter', () => { return a.gutterMarkers[n] = null, vt(a.gutterMarkers) && (a.gutterMarkers = null), !0 }) }) }), lineInfo(n) {
      let i; if (typeof n == 'number') {
        if (!se(this, n) || (i = n, n = Pe(this, n), !n))
          return null
      }
      else if (i = C(n), i == null) {
        return null
      } return { line: i, handle: n, text: n.text, gutterMarkers: n.gutterMarkers, textClass: n.textClass, bgClass: n.bgClass, wrapClass: n.wrapClass, widgets: n.widgets }
    }, addLineClass: Ut(function (n, i, a) {
      return el(this, n, i == 'gutter' ? 'gutter' : 'class', (l) => {
        const u = i == 'text' ? 'textClass' : i == 'background' ? 'bgClass' : i == 'gutter' ? 'gutterClass' : 'wrapClass'; if (!l[u]) {
          l[u] = a
        }
        else {
          if (ne(a).test(l[u]))
            return !1; l[u] += ` ${a}`
        } return !0
      })
    }), removeLineClass: Ut(function (n, i, a) {
      return el(this, n, i == 'gutter' ? 'gutter' : 'class', (l) => {
        const u = i == 'text' ? 'textClass' : i == 'background' ? 'bgClass' : i == 'gutter' ? 'gutterClass' : 'wrapClass'; const p = l[u]; if (p) {
          if (a == null) {
            l[u] = null
          }
          else {
            const m = p.match(ne(a)); if (!m)
              return !1; const w = m.index + m[0].length; l[u] = p.slice(0, m.index) + (!m.index || w == p.length ? '' : ' ') + p.slice(w) || null
          }
        }
        else {
          return !1
        } return !0
      })
    }), addLineWidget: Ut(function (n, i, a) { return t_(this, n, i, a) }), removeLineWidget(n) { n.clear() }, markText(n, i, a) { return es(this, Ke(this, n), Ke(this, i), a, a && a.type || 'range') }, setBookmark(n, i) { const a = { replacedWith: i && (i.nodeType == null ? i.widget : i), insertLeft: i && i.insertLeft, clearWhenEmpty: !1, shared: i && i.shared, handleMouseEvents: i && i.handleMouseEvents }; return n = Ke(this, n), es(this, n, n, a, 'bookmark') }, findMarksAt(n) {
      n = Ke(this, n); const i = []; const a = Pe(this, n.line).markedSpans; if (a) {
        for (let l = 0; l < a.length; ++l) { const u = a[l]; (u.from == null || u.from <= n.ch) && (u.to == null || u.to >= n.ch) && i.push(u.marker.parent || u.marker) }
      } return i
    }, findMarks(n, i, a) {
      n = Ke(this, n), i = Ke(this, i); const l = []; let u = n.line; return this.iter(n.line, i.line + 1, (p) => {
        const m = p.markedSpans; if (m) {
          for (let w = 0; w < m.length; w++) { const _ = m[w]; !(_.to != null && u == n.line && n.ch >= _.to || _.from == null && u != n.line || _.from != null && u == i.line && _.from >= i.ch) && (!a || a(_.marker)) && l.push(_.marker.parent || _.marker) }
        }++u
      }), l
    }, getAllMarks() {
      const n = []; return this.iter((i) => {
        const a = i.markedSpans; if (a) {
          for (let l = 0; l < a.length; ++l)a[l].from != null && n.push(a[l].marker)
        }
      }), n
    }, posFromIndex(n) {
      let i; let a = this.first; const l = this.lineSeparator().length; return this.iter((u) => {
        const p = u.text.length + l; if (p > n)
          return i = n, !0; n -= p, ++a
      }), Ke(this, Q(a, i))
    }, indexFromPos(n) {
      n = Ke(this, n); let i = n.ch; if (n.line < this.first || n.ch < 0)
        return 0; const a = this.lineSeparator().length; return this.iter(this.first, n.line, (l) => { i += l.text.length + a }), i
    }, copy(n) { const i = new vn(Is(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction); return i.scrollTop = this.scrollTop, i.scrollLeft = this.scrollLeft, i.sel = this.sel, i.extend = !1, n && (i.history.undoDepth = this.history.undoDepth, i.setHistory(this.getHistory())), i }, linkedDoc(n) { n || (n = {}); let i = this.first; let a = this.first + this.size; n.from != null && n.from > i && (i = n.from), n.to != null && n.to < a && (a = n.to); const l = new vn(Is(this, i, a), n.mode || this.modeOption, i, this.lineSep, this.direction); return n.sharedHist && (l.history = this.history), (this.linked || (this.linked = [])).push({ doc: l, sharedHist: n.sharedHist }), l.linked = [{ doc: this, isParent: !0, sharedHist: n.sharedHist }], r_(l, Dg(this)), l }, unlinkDoc(n) {
      if (n instanceof kt && (n = n.doc), this.linked) {
        for (let i = 0; i < this.linked.length; ++i) { const a = this.linked[i]; if (a.doc == n) { this.linked.splice(i, 1), n.unlinkDoc(this), i_(Dg(this)); break } }
      } if (n.history == this.history) { const l = [n.id]; Si(n, (u) => { return l.push(u.id) }, !0), n.history = new Ia(null), n.history.done = Yo(this.history.done, l), n.history.undone = Yo(this.history.undone, l) }
    }, iterLinkedDocs(n) { Si(this, n) }, getMode() { return this.mode }, getEditor() { return this.cm }, splitLines(n) { return this.lineSep ? n.split(this.lineSep) : Xn(n) }, lineSeparator() {
      return this.lineSep || `
`
    }, setDirection: Ut(function (n) { n != 'rtl' && (n = 'ltr'), n != this.direction && (this.direction = n, this.iter((i) => { return i.order = null }), this.cm && Gx(this.cm)) }) }), vn.prototype.eachLine = vn.prototype.iter; let zg = 0; function s_(n) {
      const i = this; if (Ig(i), !(Lt(i, n) || jr(i.display, n))) {
        tn(n), h && (zg = +new Date()); let a = so(i, n, !0); const l = n.dataTransfer.files; if (!(!a || i.isReadOnly())) {
          if (l && l.length && window.FileReader && window.File) {
            for (var u = l.length, p = Array(u), m = 0, w = function () { ++m == u && Wt(i, () => { a = Ke(i.doc, a); const U = { from: a, to: a, text: i.doc.splitLines(p.filter((ee) => { return ee != null }).join(i.doc.lineSeparator())), origin: 'paste' }; Jo(i.doc, U), _g(i.doc, xi(Ke(i.doc, a), Ke(i.doc, _i(U)))) })() }, _ = function (U, ee) { if (i.options.allowDropFileTypes && Te(i.options.allowDropFileTypes, U.type) == -1) { w(); return } const ce = new FileReader(); ce.onerror = function () { return w() }, ce.onload = function () { const ve = ce.result; if (/[\x00-\x08\x0E-\x1F]{2}/.test(ve)) { w(); return }p[ee] = ve, w() }, ce.readAsText(U) }, S = 0; S < l.length; S++)_(l[S], S)
          }
          else {
            if (i.state.draggingText && i.doc.sel.contains(a) > -1) { i.state.draggingText(n), setTimeout(() => { return i.display.input.focus() }, 20); return } try {
              const $ = n.dataTransfer.getData('Text'); if ($) {
                let D; if (i.state.draggingText && !i.state.draggingText.copy && (D = i.listSelections()), qa(i.doc, xi(a, a)), D) {
                  for (let G = 0; G < D.length; ++G)Qo(i.doc, '', D[G].anchor, D[G].head, 'drag')
                } i.replaceSelection($, 'around', 'paste'), i.display.input.focus()
              }
            }
            catch {}
          }
        }
      }
    } function l_(n, i) { if (h && (!n.state.draggingText || +new Date() - zg < 100)) { pi(i); return } if (!(Lt(n, i) || jr(n.display, i)) && (i.dataTransfer.setData('Text', n.getSelection()), i.dataTransfer.effectAllowed = 'copyMove', i.dataTransfer.setDragImage && !E)) { const a = k('img', null, null, 'position: fixed; left: 0; top: 0;'); a.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==', T && (a.width = a.height = 1, n.display.wrapper.appendChild(a), a._top = a.offsetTop), i.dataTransfer.setDragImage(a, 0, 0), T && a.parentNode.removeChild(a) } } function a_(n, i) { const a = so(n, i); if (a) { const l = document.createDocumentFragment(); cf(n, a, l), n.display.dragCursor || (n.display.dragCursor = k('div', null, 'CodeMirror-cursors CodeMirror-dragcursors'), n.display.lineSpace.insertBefore(n.display.dragCursor, n.display.cursorDiv)), I(n.display.dragCursor, l) } } function Ig(n) { n.display.dragCursor && (n.display.lineSpace.removeChild(n.display.dragCursor), n.display.dragCursor = null) } function Fg(n) { if (document.getElementsByClassName) { for (var i = document.getElementsByClassName('CodeMirror'), a = [], l = 0; l < i.length; l++) { const u = i[l].CodeMirror; u && a.push(u) }a.length && a[0].operation(() => { for (let p = 0; p < a.length; p++)n(a[p]) }) } } let Hg = !1; function c_() { Hg || (u_(), Hg = !0) } function u_() { let n; Fe(window, 'resize', () => { n == null && (n = setTimeout(() => { n = null, Fg(f_) }, 100)) }), Fe(window, 'blur', () => { return Fg(Go) }) } function f_(n) { const i = n.display; i.cachedCharWidth = i.cachedTextHeight = i.cachedPaddingH = null, i.scrollbarsClipped = !1, n.setSize() } for (var Ci = { 3: 'Pause', 8: 'Backspace', 9: 'Tab', 13: 'Enter', 16: 'Shift', 17: 'Ctrl', 18: 'Alt', 19: 'Pause', 20: 'CapsLock', 27: 'Esc', 32: 'Space', 33: 'PageUp', 34: 'PageDown', 35: 'End', 36: 'Home', 37: 'Left', 38: 'Up', 39: 'Right', 40: 'Down', 44: 'PrintScrn', 45: 'Insert', 46: 'Delete', 59: ';', 61: '=', 91: 'Mod', 92: 'Mod', 93: 'Mod', 106: '*', 107: '=', 109: '-', 110: '.', 111: '/', 145: 'ScrollLock', 173: '-', 186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\', 221: ']', 222: '\'', 224: 'Mod', 63232: 'Up', 63233: 'Down', 63234: 'Left', 63235: 'Right', 63272: 'Delete', 63273: 'Home', 63275: 'End', 63276: 'PageUp', 63277: 'PageDown', 63302: 'Insert' }, ol = 0; ol < 10; ol++)Ci[ol + 48] = Ci[ol + 96] = String(ol); for (let Ua = 65; Ua <= 90; Ua++)Ci[Ua] = String.fromCharCode(Ua); for (let sl = 1; sl <= 12; sl++)Ci[sl + 111] = Ci[sl + 63235] = `F${sl}`; const Kr = {}; Kr.basic = { 'Left': 'goCharLeft', 'Right': 'goCharRight', 'Up': 'goLineUp', 'Down': 'goLineDown', 'End': 'goLineEnd', 'Home': 'goLineStartSmart', 'PageUp': 'goPageUp', 'PageDown': 'goPageDown', 'Delete': 'delCharAfter', 'Backspace': 'delCharBefore', 'Shift-Backspace': 'delCharBefore', 'Tab': 'defaultTab', 'Shift-Tab': 'indentAuto', 'Enter': 'newlineAndIndent', 'Insert': 'toggleOverwrite', 'Esc': 'singleSelection' }, Kr.pcDefault = { 'Ctrl-A': 'selectAll', 'Ctrl-D': 'deleteLine', 'Ctrl-Z': 'undo', 'Shift-Ctrl-Z': 'redo', 'Ctrl-Y': 'redo', 'Ctrl-Home': 'goDocStart', 'Ctrl-End': 'goDocEnd', 'Ctrl-Up': 'goLineUp', 'Ctrl-Down': 'goLineDown', 'Ctrl-Left': 'goGroupLeft', 'Ctrl-Right': 'goGroupRight', 'Alt-Left': 'goLineStart', 'Alt-Right': 'goLineEnd', 'Ctrl-Backspace': 'delGroupBefore', 'Ctrl-Delete': 'delGroupAfter', 'Ctrl-S': 'save', 'Ctrl-F': 'find', 'Ctrl-G': 'findNext', 'Shift-Ctrl-G': 'findPrev', 'Shift-Ctrl-F': 'replace', 'Shift-Ctrl-R': 'replaceAll', 'Ctrl-[': 'indentLess', 'Ctrl-]': 'indentMore', 'Ctrl-U': 'undoSelection', 'Shift-Ctrl-U': 'redoSelection', 'Alt-U': 'redoSelection', 'fallthrough': 'basic' }, Kr.emacsy = { 'Ctrl-F': 'goCharRight', 'Ctrl-B': 'goCharLeft', 'Ctrl-P': 'goLineUp', 'Ctrl-N': 'goLineDown', 'Ctrl-A': 'goLineStart', 'Ctrl-E': 'goLineEnd', 'Ctrl-V': 'goPageDown', 'Shift-Ctrl-V': 'goPageUp', 'Ctrl-D': 'delCharAfter', 'Ctrl-H': 'delCharBefore', 'Alt-Backspace': 'delWordBefore', 'Ctrl-K': 'killLine', 'Ctrl-T': 'transposeChars', 'Ctrl-O': 'openLine' }, Kr.macDefault = { 'Cmd-A': 'selectAll', 'Cmd-D': 'deleteLine', 'Cmd-Z': 'undo', 'Shift-Cmd-Z': 'redo', 'Cmd-Y': 'redo', 'Cmd-Home': 'goDocStart', 'Cmd-Up': 'goDocStart', 'Cmd-End': 'goDocEnd', 'Cmd-Down': 'goDocEnd', 'Alt-Left': 'goGroupLeft', 'Alt-Right': 'goGroupRight', 'Cmd-Left': 'goLineLeft', 'Cmd-Right': 'goLineRight', 'Alt-Backspace': 'delGroupBefore', 'Ctrl-Alt-Backspace': 'delGroupAfter', 'Alt-Delete': 'delGroupAfter', 'Cmd-S': 'save', 'Cmd-F': 'find', 'Cmd-G': 'findNext', 'Shift-Cmd-G': 'findPrev', 'Cmd-Alt-F': 'replace', 'Shift-Cmd-Alt-F': 'replaceAll', 'Cmd-[': 'indentLess', 'Cmd-]': 'indentMore', 'Cmd-Backspace': 'delWrappedLineLeft', 'Cmd-Delete': 'delWrappedLineRight', 'Cmd-U': 'undoSelection', 'Shift-Cmd-U': 'redoSelection', 'Ctrl-Up': 'goDocStart', 'Ctrl-Down': 'goDocEnd', 'fallthrough': ['basic', 'emacsy'] }, Kr.default = H ? Kr.macDefault : Kr.pcDefault; function d_(n) {
      const i = n.split(/-(?!$)/); n = i[i.length - 1]; for (var a, l, u, p, m = 0; m < i.length - 1; m++) {
        const w = i[m]; if (/^(cmd|meta|m)$/i.test(w))
          p = !0; else if (/^a(lt)?$/i.test(w))
          a = !0; else if (/^(c|ctrl|control)$/i.test(w))
          l = !0; else if (/^s(hift)?$/i.test(w))
          u = !0; else throw new Error(`Unrecognized modifier name: ${w}`)
      } return a && (n = `Alt-${n}`), l && (n = `Ctrl-${n}`), p && (n = `Cmd-${n}`), u && (n = `Shift-${n}`), n
    } function h_(n) {
      const i = {}; for (const a in n) {
        if (n.hasOwnProperty(a)) {
          const l = n[a]; if (/^(name|fallthrough|(de|at)tach)$/.test(a))
            continue; if (l == '...') { delete n[a]; continue } for (let u = xe(a.split(' '), d_), p = 0; p < u.length; p++) {
            let m = void 0; let w = void 0; p == u.length - 1 ? (w = u.join(' '), m = l) : (w = u.slice(0, p + 1).join(' '), m = '...'); const _ = i[w]; if (!_)
              i[w] = m; else if (_ != m)
              throw new Error(`Inconsistent bindings for ${w}`)
          } delete n[a]
        }
      } for (const S in i)n[S] = i[S]; return n
    } function ts(n, i, a, l) {
      i = Va(i); const u = i.call ? i.call(n, l) : i[n]; if (u === !1)
        return 'nothing'; if (u === '...')
        return 'multi'; if (u != null && a(u))
        return 'handled'; if (i.fallthrough) {
        if (Object.prototype.toString.call(i.fallthrough) != '[object Array]')
          return ts(n, i.fallthrough, a, l); for (let p = 0; p < i.fallthrough.length; p++) {
          const m = ts(n, i.fallthrough[p], a, l); if (m)
            return m
        }
      }
    } function qg(n) { const i = typeof n == 'string' ? n : Ci[n.keyCode]; return i == 'Ctrl' || i == 'Alt' || i == 'Shift' || i == 'Mod' } function Bg(n, i, a) { const l = n; return i.altKey && l != 'Alt' && (n = `Alt-${n}`), (te ? i.metaKey : i.ctrlKey) && l != 'Ctrl' && (n = `Ctrl-${n}`), (te ? i.ctrlKey : i.metaKey) && l != 'Mod' && (n = `Cmd-${n}`), !a && i.shiftKey && l != 'Shift' && (n = `Shift-${n}`), n } function Wg(n, i) {
      if (T && n.keyCode == 34 && n.char)
        return !1; let a = Ci[n.keyCode]; return a == null || n.altGraphKey ? !1 : (n.keyCode == 3 && n.code && (a = n.code), Bg(a, n, i))
    } function Va(n) { return typeof n == 'string' ? Kr[n] : n } function ns(n, i) { for (var a = n.doc.sel.ranges, l = [], u = 0; u < a.length; u++) { for (var p = i(a[u]); l.length && _e(p.from, fe(l).to) <= 0;) { const m = l.pop(); if (_e(m.from, p.from) < 0) { p.from = m.from; break } }l.push(p) }An(n, () => { for (let w = l.length - 1; w >= 0; w--)Qo(n.doc, '', l[w].from, l[w].to, '+delete'); Ko(n) }) } function Tf(n, i, a) { const l = It(n.text, i + a, a); return l < 0 || l > n.text.length ? null : l } function Ef(n, i, a) { const l = Tf(n, i.ch, a); return l == null ? null : new Q(i.line, l, a < 0 ? 'after' : 'before') } function Lf(n, i, a, l, u) {
      if (n) {
        i.doc.direction == 'rtl' && (u = -u); const p = Ve(a, i.doc.direction); if (p) {
          const m = u < 0 ? fe(p) : p[0]; const w = u < 0 == (m.level == 1); const _ = w ? 'after' : 'before'; let S; if (m.level > 0 || i.doc.direction == 'rtl') { const $ = Uo(i, a); S = u < 0 ? a.text.length - 1 : 0; const D = Er(i, $, S).top; S = Jt((G) => { return Er(i, $, G).top == D }, u < 0 == (m.level == 1) ? m.from : m.to - 1, S), _ == 'before' && (S = Tf(a, S, 1)) }
          else {
            S = u < 0 ? m.to : m.from
          } return new Q(l, S, _)
        }
      } return new Q(l, u < 0 ? a.text.length : 0, u < 0 ? 'before' : 'after')
    } function p_(n, i, a, l) {
      const u = Ve(i, n.doc.direction); if (!u)
        return Ef(i, a, l); a.ch >= i.text.length ? (a.ch = i.text.length, a.sticky = 'before') : a.ch <= 0 && (a.ch = 0, a.sticky = 'after'); const p = sr(u, a.ch, a.sticky); const m = u[p]; if (n.doc.direction == 'ltr' && m.level % 2 == 0 && (l > 0 ? m.to > a.ch : m.from < a.ch))
        return Ef(i, a, l); const w = function (be, ke) { return Tf(i, be instanceof Q ? be.ch : be, ke) }; let _; const S = function (be) { return n.options.lineWrapping ? (_ = _ || Uo(n, i), Kp(n, i, _, be)) : { begin: 0, end: i.text.length } }; const $ = S(a.sticky == 'before' ? w(a, -1) : a.ch); if (n.doc.direction == 'rtl' || m.level == 1) { const D = m.level == 1 == l < 0; const G = w(a, D ? 1 : -1); if (G != null && (D ? G <= m.to && G <= $.end : G >= m.from && G >= $.begin)) { const U = D ? 'before' : 'after'; return new Q(a.line, G, U) } } const ee = function (be, ke, we) {
        for (let Le = function (wt, Vt) { return Vt ? new Q(a.line, w(wt, 1), 'before') : new Q(a.line, wt, 'after') }; be >= 0 && be < u.length; be += ke) {
          const He = u[be]; const De = ke > 0 == (He.level != 1); let Je = De ? we.begin : w(we.end, -1); if (He.from <= Je && Je < He.to || (Je = De ? He.from : w(He.to, -1), we.begin <= Je && Je < we.end))
            return Le(Je, De)
        }
      }; let ce = ee(p + l, l, $); if (ce)
        return ce; const ve = l > 0 ? $.end : w($.begin, -1); return ve != null && !(l > 0 && ve == i.text.length) && (ce = ee(l > 0 ? 0 : u.length - 1, l, S(ve)), ce) ? ce : null
    } const ll = { selectAll: Eg, singleSelection(n) { return n.setSelection(n.getCursor('anchor'), n.getCursor('head'), F) }, killLine(n) {
      return ns(n, (i) => {
        if (i.empty()) { const a = Pe(n.doc, i.head.line).text.length; return i.head.ch == a && i.head.line < n.lastLine() ? { from: i.head, to: Q(i.head.line + 1, 0) } : { from: i.head, to: Q(i.head.line, a) } }
        else {
          return { from: i.from(), to: i.to() }
        }
      })
    }, deleteLine(n) { return ns(n, (i) => { return { from: Q(i.from().line, 0), to: Ke(n.doc, Q(i.to().line + 1, 0)) } }) }, delLineLeft(n) { return ns(n, (i) => { return { from: Q(i.from().line, 0), to: i.from() } }) }, delWrappedLineLeft(n) { return ns(n, (i) => { const a = n.charCoords(i.head, 'div').top + 5; const l = n.coordsChar({ left: 0, top: a }, 'div'); return { from: l, to: i.from() } }) }, delWrappedLineRight(n) { return ns(n, (i) => { const a = n.charCoords(i.head, 'div').top + 5; const l = n.coordsChar({ left: n.display.lineDiv.offsetWidth + 100, top: a }, 'div'); return { from: i.from(), to: l } }) }, undo(n) { return n.undo() }, redo(n) { return n.redo() }, undoSelection(n) { return n.undoSelection() }, redoSelection(n) { return n.redoSelection() }, goDocStart(n) { return n.extendSelection(Q(n.firstLine(), 0)) }, goDocEnd(n) { return n.extendSelection(Q(n.lastLine())) }, goLineStart(n) { return n.extendSelectionsBy((i) => { return Ug(n, i.head.line) }, { origin: '+move', bias: 1 }) }, goLineStartSmart(n) { return n.extendSelectionsBy((i) => { return Vg(n, i.head) }, { origin: '+move', bias: 1 }) }, goLineEnd(n) { return n.extendSelectionsBy((i) => { return g_(n, i.head.line) }, { origin: '+move', bias: -1 }) }, goLineRight(n) { return n.extendSelectionsBy((i) => { const a = n.cursorCoords(i.head, 'div').top + 5; return n.coordsChar({ left: n.display.lineDiv.offsetWidth + 100, top: a }, 'div') }, ue) }, goLineLeft(n) { return n.extendSelectionsBy((i) => { const a = n.cursorCoords(i.head, 'div').top + 5; return n.coordsChar({ left: 0, top: a }, 'div') }, ue) }, goLineLeftSmart(n) { return n.extendSelectionsBy((i) => { const a = n.cursorCoords(i.head, 'div').top + 5; const l = n.coordsChar({ left: 0, top: a }, 'div'); return l.ch < n.getLine(l.line).search(/\S/) ? Vg(n, i.head) : l }, ue) }, goLineUp(n) { return n.moveV(-1, 'line') }, goLineDown(n) { return n.moveV(1, 'line') }, goPageUp(n) { return n.moveV(-1, 'page') }, goPageDown(n) { return n.moveV(1, 'page') }, goCharLeft(n) { return n.moveH(-1, 'char') }, goCharRight(n) { return n.moveH(1, 'char') }, goColumnLeft(n) { return n.moveH(-1, 'column') }, goColumnRight(n) { return n.moveH(1, 'column') }, goWordLeft(n) { return n.moveH(-1, 'word') }, goGroupRight(n) { return n.moveH(1, 'group') }, goGroupLeft(n) { return n.moveH(-1, 'group') }, goWordRight(n) { return n.moveH(1, 'word') }, delCharBefore(n) { return n.deleteH(-1, 'codepoint') }, delCharAfter(n) { return n.deleteH(1, 'char') }, delWordBefore(n) { return n.deleteH(-1, 'word') }, delWordAfter(n) { return n.deleteH(1, 'word') }, delGroupBefore(n) { return n.deleteH(-1, 'group') }, delGroupAfter(n) { return n.deleteH(1, 'group') }, indentAuto(n) { return n.indentSelection('smart') }, indentMore(n) { return n.indentSelection('add') }, indentLess(n) { return n.indentSelection('subtract') }, insertTab(n) { return n.replaceSelection('	') }, insertSoftTab(n) { for (var i = [], a = n.listSelections(), l = n.options.tabSize, u = 0; u < a.length; u++) { const p = a[u].from(); const m = de(n.getLine(p.line), p.ch, l); i.push(Se(l - m % l)) }n.replaceSelections(i) }, defaultTab(n) { n.somethingSelected() ? n.indentSelection('add') : n.execCommand('insertTab') }, transposeChars(n) {
      return An(n, () => {
        for (var i = n.listSelections(), a = [], l = 0; l < i.length; l++) {
          if (i[l].empty()) {
            let u = i[l].head; const p = Pe(n.doc, u.line).text; if (p) {
              if (u.ch == p.length && (u = new Q(u.line, u.ch - 1)), u.ch > 0) {
                u = new Q(u.line, u.ch + 1), n.replaceRange(p.charAt(u.ch - 1) + p.charAt(u.ch - 2), Q(u.line, u.ch - 2), u, '+transpose')
              }
              else if (u.line > n.doc.first) { const m = Pe(n.doc, u.line - 1).text; m && (u = new Q(u.line, 1), n.replaceRange(p.charAt(0) + n.doc.lineSeparator() + m.charAt(m.length - 1), Q(u.line - 1, m.length - 1), u, '+transpose')) }
            }a.push(new ht(u, u))
          }
        }n.setSelections(a)
      })
    }, newlineAndIndent(n) { return An(n, () => { for (var i = n.listSelections(), a = i.length - 1; a >= 0; a--)n.replaceRange(n.doc.lineSeparator(), i[a].anchor, i[a].head, '+input'); i = n.listSelections(); for (let l = 0; l < i.length; l++)n.indentLine(i[l].from().line, null, !0); Ko(n) }) }, openLine(n) {
      return n.replaceSelection(`
`, 'start')
    }, toggleOverwrite(n) { return n.toggleOverwrite() } }; function Ug(n, i) { const a = Pe(n.doc, i); const l = dr(a); return l != a && (i = C(l)), Lf(!0, n, l, i, 1) } function g_(n, i) { const a = Pe(n.doc, i); const l = J1(a); return l != a && (i = C(l)), Lf(!0, n, a, i, -1) } function Vg(n, i) { const a = Ug(n, i.line); const l = Pe(n.doc, a.line); const u = Ve(l, n.doc.direction); if (!u || u[0].level == 0) { const p = Math.max(a.ch, l.text.search(/\S/)); const m = i.line == a.line && i.ch <= p && i.ch; return Q(a.line, m ? 0 : p, a.sticky) } return a } function ja(n, i, a) {
      if (typeof i == 'string' && (i = ll[i], !i))
        return !1; n.display.input.ensurePolled(); const l = n.display.shift; let u = !1; try { n.isReadOnly() && (n.state.suppressEdits = !0), a && (n.display.shift = !1), u = i(n) != P }
      finally { n.display.shift = l, n.state.suppressEdits = !1 } return u
    } function v_(n, i, a) {
      for (let l = 0; l < n.state.keyMaps.length; l++) {
        const u = ts(i, n.state.keyMaps[l], a, n); if (u)
          return u
      } return n.options.extraKeys && ts(i, n.options.extraKeys, a, n) || ts(i, n.options.keyMap, a, n)
    } const m_ = new $e(); function al(n, i, a, l) {
      const u = n.state.keySeq; if (u) {
        if (qg(i))
          return 'handled'; if (i.endsWith('\'') ? n.state.keySeq = null : m_.set(50, () => { n.state.keySeq == u && (n.state.keySeq = null, n.display.input.reset()) }), jg(n, `${u} ${i}`, a, l))
          return !0
      } return jg(n, i, a, l)
    } function jg(n, i, a, l) { const u = v_(n, i, l); return u == 'multi' && (n.state.keySeq = i), u == 'handled' && Bt(n, 'keyHandled', n, i, a), (u == 'handled' || u == 'multi') && (tn(a), uf(n)), !!u } function Gg(n, i) {
      const a = Wg(i, !0); return a
        ? i.shiftKey && !n.state.keySeq
          ? al(n, `Shift-${a}`, i, (l) => { return ja(n, l, !0) }) || al(n, a, i, (l) => {
            if (typeof l == 'string' ? /^go[A-Z]/.test(l) : l.motion)
              return ja(n, l)
          })
          : al(n, a, i, (l) => { return ja(n, l) })
        : !1
    } function y_(n, i, a) { return al(n, `'${a}'`, i, (l) => { return ja(n, l, !0) }) } let Af = null; function Kg(n) { const i = this; if (!(n.target && n.target != i.display.input.getField()) && (i.curOp.focus = ye(rt(i)), !Lt(i, n))) { h && g < 11 && n.keyCode == 27 && (n.returnValue = !1); const a = n.keyCode; i.display.shift = a == 16 || n.shiftKey; const l = Gg(i, n); T && (Af = l ? a : null, !l && a == 88 && !wa && (H ? n.metaKey : n.ctrlKey) && i.replaceSelection('', null, 'cut')), s && !H && !l && a == 46 && n.shiftKey && !n.ctrlKey && document.execCommand && document.execCommand('cut'), a == 18 && !/\bCodeMirror-crosshair\b/.test(i.display.lineDiv.className) && b_(i) } } function b_(n) { const i = n.display.lineDiv; Ne(i, 'CodeMirror-crosshair'); function a(l) { (l.keyCode == 18 || !l.altKey) && (K(i, 'CodeMirror-crosshair'), en(document, 'keyup', a), en(document, 'mouseover', a)) }Fe(document, 'keyup', a), Fe(document, 'mouseover', a) } function Xg(n) { n.keyCode == 16 && (this.doc.sel.shift = !1), Lt(this, n) } function Yg(n) { const i = this; if (!(n.target && n.target != i.display.input.getField()) && !(jr(i.display, n) || Lt(i, n) || n.ctrlKey && !n.altKey || H && n.metaKey)) { const a = n.keyCode; const l = n.charCode; if (T && a == Af) { Af = null, tn(n); return } if (!(T && (!n.which || n.which < 10) && Gg(i, n))) { const u = String.fromCharCode(l ?? a); u != '\b' && (y_(i, n, u) || i.display.input.onKeyPress(n)) } } } const w_ = 400; const Mf = function (n, i, a) { this.time = n, this.pos = i, this.button = a }; Mf.prototype.compare = function (n, i, a) { return this.time + w_ > n && _e(i, this.pos) == 0 && a == this.button }; let cl, ul; function x_(n, i) { const a = +new Date(); return ul && ul.compare(a, n, i) ? (cl = ul = null, 'triple') : cl && cl.compare(a, n, i) ? (ul = new Mf(a, n, i), cl = null, 'double') : (cl = new Mf(a, n, i), ul = null, 'single') } function Zg(n) { const i = this; const a = i.display; if (!(Lt(i, n) || a.activeTouch && a.input.supportsTouch())) { if (a.input.ensurePolled(), a.shift = n.shiftKey, jr(a, n)) { v || (a.scroller.draggable = !1, setTimeout(() => { return a.scroller.draggable = !0 }, 100)); return } if (!Nf(i, n)) { const l = so(i, n); const u = ar(n); const p = l ? x_(l, u) : 'single'; Ee(i).focus(), u == 1 && i.state.selectingText && i.state.selectingText(n), !(l && __(i, u, l, p, n)) && (u == 1 ? l ? k_(i, l, p, n) : Rs(n) == a.scroller && tn(n) : u == 2 ? (l && Ha(i.doc, l), setTimeout(() => { return a.input.focus() }, 20)) : u == 3 && (j ? i.display.input.onContextMenu(n) : ff(i))) } } } function __(n, i, a, l, u) {
      let p = 'Click'; return l == 'double' ? p = `Double${p}` : l == 'triple' && (p = `Triple${p}`), p = (i == 1 ? 'Left' : i == 2 ? 'Middle' : 'Right') + p, al(n, Bg(p, u), u, (m) => {
        if (typeof m == 'string' && (m = ll[m]), !m)
          return !1; let w = !1; try { n.isReadOnly() && (n.state.suppressEdits = !0), w = m(n, a) != P }
        finally { n.state.suppressEdits = !1 } return w
      })
    } function S_(n, i, a) { const l = n.getOption('configureMouse'); const u = l ? l(n, i, a) : {}; if (u.unit == null) { const p = z ? a.shiftKey && a.metaKey : a.altKey; u.unit = p ? 'rectangle' : i == 'single' ? 'char' : i == 'double' ? 'word' : 'line' } return (u.extend == null || n.doc.extend) && (u.extend = n.doc.extend || a.shiftKey), u.addNew == null && (u.addNew = H ? a.metaKey : a.ctrlKey), u.moveOnDrag == null && (u.moveOnDrag = !(H ? a.altKey : a.ctrlKey)), u } function k_(n, i, a, l) { h ? setTimeout(X(Jp, n), 0) : n.curOp.focus = ye(rt(n)); const u = S_(n, a, l); const p = n.doc.sel; let m; n.options.dragDrop && Bu && !n.isReadOnly() && a == 'single' && (m = p.contains(i)) > -1 && (_e((m = p.ranges[m]).from(), i) < 0 || i.xRel > 0) && (_e(m.to(), i) > 0 || i.xRel < 0) ? C_(n, l, i, u) : T_(n, l, i, u) } function C_(n, i, a, l) { const u = n.display; let p = !1; var m = Wt(n, (S) => { v && (u.scroller.draggable = !1), n.state.draggingText = !1, n.state.delayingBlurEvent && (n.hasFocus() ? n.state.delayingBlurEvent = !1 : ff(n)), en(u.wrapper.ownerDocument, 'mouseup', m), en(u.wrapper.ownerDocument, 'mousemove', w), en(u.scroller, 'dragstart', _), en(u.scroller, 'drop', m), p || (tn(S), l.addNew || Ha(n.doc, a, null, null, l.extend), v && !E || h && g == 9 ? setTimeout(() => { u.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), u.input.focus() }, 20) : u.input.focus()) }); var w = function (S) { p = p || Math.abs(i.clientX - S.clientX) + Math.abs(i.clientY - S.clientY) >= 10 }; var _ = function () { return p = !0 }; v && (u.scroller.draggable = !0), n.state.draggingText = m, m.copy = !l.moveOnDrag, Fe(u.wrapper.ownerDocument, 'mouseup', m), Fe(u.wrapper.ownerDocument, 'mousemove', w), Fe(u.scroller, 'dragstart', _), Fe(u.scroller, 'drop', m), n.state.delayingBlurEvent = !0, setTimeout(() => { return u.input.focus() }, 20), u.scroller.dragDrop && u.scroller.dragDrop() } function Jg(n, i, a) {
      if (a == 'char')
        return new ht(i, i); if (a == 'word')
        return n.findWordAt(i); if (a == 'line')
        return new ht(Q(i.line, 0), Ke(n.doc, Q(i.line + 1, 0))); const l = a(n, i); return new ht(l.from, l.to)
    } function T_(n, i, a, l) {
      h && ff(n); const u = n.display; const p = n.doc; tn(i); let m; let w; let _ = p.sel; const S = _.ranges; if (l.addNew && !l.extend ? (w = p.sel.contains(a), w > -1 ? m = S[w] : m = new ht(a, a)) : (m = p.sel.primary(), w = p.sel.primIndex), l.unit == 'rectangle') {
        l.addNew || (m = new ht(a, a)), a = so(n, i, !0, !0), w = -1
      }
      else { const $ = Jg(n, a, l.unit); l.extend ? m = kf(m, $.anchor, $.head, l.extend) : m = $ }l.addNew ? w == -1 ? (w = S.length, nn(p, pr(n, S.concat([m]), w), { scroll: !1, origin: '*mouse' })) : S.length > 1 && S[w].empty() && l.unit == 'char' && !l.extend ? (nn(p, pr(n, S.slice(0, w).concat(S.slice(w + 1)), 0), { scroll: !1, origin: '*mouse' }), _ = p.sel) : Cf(p, w, m, Z) : (w = 0, nn(p, new qn([m], 0), Z), _ = p.sel); let D = a; function G(we) {
        if (_e(D, we) != 0) {
          if (D = we, l.unit == 'rectangle') { for (var Le = [], He = n.options.tabSize, De = de(Pe(p, a.line).text, a.ch, He), Je = de(Pe(p, we.line).text, we.ch, He), wt = Math.min(De, Je), Vt = Math.max(De, Je), Tt = Math.min(a.line, we.line), Mn = Math.min(n.lastLine(), Math.max(a.line, we.line)); Tt <= Mn; Tt++) { const mn = Pe(p, Tt).text; const Pt = le(mn, wt, He); wt == Vt ? Le.push(new ht(Q(Tt, Pt), Q(Tt, Pt))) : mn.length > Pt && Le.push(new ht(Q(Tt, Pt), Q(Tt, le(mn, Vt, He)))) }Le.length || Le.push(new ht(a, a)), nn(p, pr(n, _.ranges.slice(0, w).concat(Le), w), { origin: '*mouse', scroll: !1 }), n.scrollIntoView(we) }
          else { const yn = m; const Kt = Jg(n, we, l.unit); let Ft = yn.anchor; let Rt; _e(Kt.anchor, Ft) > 0 ? (Rt = Kt.head, Ft = qo(yn.from(), Kt.anchor)) : (Rt = Kt.anchor, Ft = pn(yn.to(), Kt.head)); const Mt = _.ranges.slice(0); Mt[w] = E_(n, new ht(Ke(p, Ft), Rt)), nn(p, pr(n, Mt, w), Z) }
        }
      } const U = u.wrapper.getBoundingClientRect(); let ee = 0; function ce(we) {
        const Le = ++ee; const He = so(n, we, !0, l.unit == 'rectangle'); if (He) {
          if (_e(He, D) != 0) { n.curOp.focus = ye(rt(n)), G(He); const De = Pa(u, p); (He.line >= De.to || He.line < De.from) && setTimeout(Wt(n, () => { ee == Le && ce(we) }), 150) }
          else { const Je = we.clientY < U.top ? -20 : we.clientY > U.bottom ? 20 : 0; Je && setTimeout(Wt(n, () => { ee == Le && (u.scroller.scrollTop += Je, ce(we)) }), 50) }
        }
      } function ve(we) { n.state.selectingText = !1, ee = 1 / 0, we && (tn(we), u.input.focus()), en(u.wrapper.ownerDocument, 'mousemove', be), en(u.wrapper.ownerDocument, 'mouseup', ke), p.history.lastSelOrigin = null } var be = Wt(n, (we) => { we.buttons === 0 || !ar(we) ? ve(we) : ce(we) }); var ke = Wt(n, ve); n.state.selectingText = ke, Fe(u.wrapper.ownerDocument, 'mousemove', be), Fe(u.wrapper.ownerDocument, 'mouseup', ke)
    } function E_(n, i) {
      const a = i.anchor; const l = i.head; const u = Pe(n.doc, a.line); if (_e(a, l) == 0 && a.sticky == l.sticky)
        return i; const p = Ve(u); if (!p)
        return i; const m = sr(p, a.ch, a.sticky); const w = p[m]; if (w.from != a.ch && w.to != a.ch)
        return i; const _ = m + (w.from == a.ch == (w.level != 1) ? 0 : 1); if (_ == 0 || _ == p.length)
        return i; let S; if (l.line != a.line) {
        S = (l.line - a.line) * (n.doc.direction == 'ltr' ? 1 : -1) > 0
      }
      else { const $ = sr(p, l.ch, l.sticky); const D = $ - m || (l.ch - a.ch) * (w.level == 1 ? -1 : 1); $ == _ - 1 || $ == _ ? S = D < 0 : S = D > 0 } const G = p[_ + (S ? -1 : 0)]; const U = S == (G.level == 1); const ee = U ? G.from : G.to; const ce = U ? 'after' : 'before'; return a.ch == ee && a.sticky == ce ? i : new ht(new Q(a.line, ee, ce), l)
    } function Qg(n, i, a, l) {
      let u, p; if (i.touches) {
        u = i.touches[0].clientX, p = i.touches[0].clientY
      }
      else {
        try { u = i.clientX, p = i.clientY }
        catch { return !1 }
      } if (u >= Math.floor(n.display.gutters.getBoundingClientRect().right))
        return !1; l && tn(i); const m = n.display; const w = m.lineDiv.getBoundingClientRect(); if (p > w.bottom || !Ln(n, a))
        return hn(i); p -= w.top - m.viewOffset; for (let _ = 0; _ < n.display.gutterSpecs.length; ++_) { const S = m.gutters.childNodes[_]; if (S && S.getBoundingClientRect().right >= u) { const $ = R(n.doc, p); const D = n.display.gutterSpecs[_]; return Et(n, a, n, $, D.className, i), hn(i) } }
    } function Nf(n, i) { return Qg(n, i, 'gutterClick', !0) } function ev(n, i) { jr(n.display, i) || L_(n, i) || Lt(n, i, 'contextmenu') || j || n.display.input.onContextMenu(i) } function L_(n, i) { return Ln(n, 'gutterContextMenu') ? Qg(n, i, 'gutterContextMenu', !1) : !1 } function tv(n) { n.display.wrapper.className = n.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + n.options.theme.replace(/(^|\s)\s*/g, ' cm-s-'), Us(n) } const rs = { toString() { return 'CodeMirror.Init' } }; const nv = {}; const Ga = {}; function A_(n) {
      const i = n.optionHandlers; function a(l, u, p, m) { n.defaults[l] = u, p && (i[l] = m ? function (w, _, S) { S != rs && p(w, _, S) } : p) }n.defineOption = a, n.Init = rs, a('value', '', (l, u) => { return l.setValue(u) }, !0), a('mode', null, (l, u) => { l.doc.modeOption = u, xf(l) }, !0), a('indentUnit', 2, xf, !0), a('indentWithTabs', !1), a('smartIndent', !0), a('tabSize', 4, (l) => { Js(l), Us(l), gn(l) }, !0), a('lineSeparator', null, (l, u) => {
        if (l.doc.lineSep = u, !!u) {
          const p = []; let m = l.doc.first; l.doc.iter((_) => {
            for (let S = 0; ;) {
              const $ = _.text.indexOf(u, S); if ($ == -1)
                break; S = $ + u.length, p.push(Q(m, $))
            }m++
          }); for (let w = p.length - 1; w >= 0; w--)Qo(l.doc, u, p[w], Q(p[w].line, p[w].ch + u.length))
        }
      }), a('specialChars', /[\u0000-\u001F\u007F-\u009F\u00AD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]/g, (l, u, p) => { l.state.specialChars = new RegExp(u.source + (u.test('	') ? '' : '|	'), 'g'), p != rs && l.refresh() }), a('specialCharPlaceholder', ix, (l) => { return l.refresh() }, !0), a('electricChars', !0), a('inputStyle', A ? 'contenteditable' : 'textarea', () => { throw new Error('inputStyle can not (yet) be changed in a running editor') }, !0), a('spellcheck', !1, (l, u) => { return l.getInputField().spellcheck = u }, !0), a('autocorrect', !1, (l, u) => { return l.getInputField().autocorrect = u }, !0), a('autocapitalize', !1, (l, u) => { return l.getInputField().autocapitalize = u }, !0), a('rtlMoveVisually', !J), a('wholeLineUpdateBefore', !0), a('theme', 'default', (l) => { tv(l), Zs(l) }, !0), a('keyMap', 'default', (l, u, p) => { const m = Va(u); const w = p != rs && Va(p); w && w.detach && w.detach(l, m), m.attach && m.attach(l, w || null) }), a('extraKeys', null), a('configureMouse', null), a('lineWrapping', !1, N_, !0), a('gutters', [], (l, u) => { l.display.gutterSpecs = bf(u, l.options.lineNumbers), Zs(l) }, !0), a('fixedGutter', !0, (l, u) => { l.display.gutters.style.left = u ? `${lf(l.display)}px` : '0', l.refresh() }, !0), a('coverGutterNextToScrollbar', !1, (l) => { return Xo(l) }, !0), a('scrollbarStyle', 'native', (l) => { ig(l), Xo(l), l.display.scrollbars.setScrollTop(l.doc.scrollTop), l.display.scrollbars.setScrollLeft(l.doc.scrollLeft) }, !0), a('lineNumbers', !1, (l, u) => { l.display.gutterSpecs = bf(l.options.gutters, u), Zs(l) }, !0), a('firstLineNumber', 1, Zs, !0), a('lineNumberFormatter', (l) => { return l }, Zs, !0), a('showCursorWhenSelecting', !1, Vs, !0), a('resetSelectionOnContextMenu', !0), a('lineWiseCopyCut', !0), a('pasteLinesPerSelection', !0), a('selectionsMayTouch', !1), a('readOnly', !1, (l, u) => { u == 'nocursor' && (Go(l), l.display.input.blur()), l.display.input.readOnlyChanged(u) }), a('screenReaderLabel', null, (l, u) => { u = u === '' ? null : u, l.display.input.screenReaderLabelChanged(u) }), a('disableInput', !1, (l, u) => { u || l.display.input.reset() }, !0), a('dragDrop', !0, M_), a('allowDropFileTypes', null), a('cursorBlinkRate', 530), a('cursorScrollMargin', 0), a('cursorHeight', 1, Vs, !0), a('singleCursorHeightPerLine', !0, Vs, !0), a('workTime', 100), a('workDelay', 100), a('flattenSpans', !0, Js, !0), a('addModeClass', !1, Js, !0), a('pollInterval', 100), a('undoDepth', 200, (l, u) => { return l.doc.history.undoDepth = u }), a('historyEventDelay', 1250), a('viewportMargin', 10, (l) => { return l.refresh() }, !0), a('maxHighlightLength', 1e4, Js, !0), a('moveInputWithCursor', !0, (l, u) => { u || l.display.input.resetPosition() }), a('tabindex', null, (l, u) => { return l.display.input.getField().tabIndex = u || '' }), a('autofocus', null), a('direction', 'ltr', (l, u) => { return l.doc.setDirection(u) }, !0), a('phrases', null)
    } function M_(n, i, a) { const l = a && a != rs; if (!i != !l) { const u = n.display.dragFunctions; const p = i ? Fe : en; p(n.display.scroller, 'dragstart', u.start), p(n.display.scroller, 'dragenter', u.enter), p(n.display.scroller, 'dragover', u.over), p(n.display.scroller, 'dragleave', u.leave), p(n.display.scroller, 'drop', u.drop) } } function N_(n) { n.options.lineWrapping ? (Ne(n.display.wrapper, 'CodeMirror-wrap'), n.display.sizer.style.minWidth = '', n.display.sizerWidth = null) : (K(n.display.wrapper, 'CodeMirror-wrap'), Yu(n)), af(n), gn(n), Us(n), setTimeout(() => { return Xo(n) }, 100) } function kt(n, i) {
      const a = this; if (!(this instanceof kt))
        return new kt(n, i); this.options = i = i ? ae(i) : {}, ae(nv, i, !1); let l = i.value; typeof l == 'string' ? l = new vn(l, i.mode, null, i.lineSeparator, i.direction) : i.mode && (l.modeOption = i.mode), this.doc = l; const u = new kt.inputStyles[i.inputStyle](this); const p = this.display = new Ux(n, l, u, i); p.wrapper.CodeMirror = this, tv(this), i.lineWrapping && (this.display.wrapper.className += ' CodeMirror-wrap'), ig(this), this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: -1, cutIncoming: -1, selectingText: !1, draggingText: !1, highlight: new $e(), keySeq: null, specialChars: null }, i.autofocus && !A && p.input.focus(), h && g < 11 && setTimeout(() => { return a.display.input.reset(!0) }, 20), $_(this), c_(), uo(this), this.curOp.forceUpdate = !0, pg(this, l), i.autofocus && !A || this.hasFocus() ? setTimeout(() => { a.hasFocus() && !a.state.focused && df(a) }, 20) : Go(this); for (const m in Ga)Ga.hasOwnProperty(m) && Ga[m](this, i[m], rs); lg(this), i.finishInit && i.finishInit(this); for (let w = 0; w < $f.length; ++w)$f[w](this); fo(this), v && i.lineWrapping && getComputedStyle(p.lineDiv).textRendering == 'optimizelegibility' && (p.lineDiv.style.textRendering = 'auto')
    }kt.defaults = nv, kt.optionHandlers = Ga; function $_(n) {
      const i = n.display; Fe(i.scroller, 'mousedown', Wt(n, Zg)), h && g < 11 ? Fe(i.scroller, 'dblclick', Wt(n, (_) => { if (!Lt(n, _)) { const S = so(n, _); if (!(!S || Nf(n, _) || jr(n.display, _))) { tn(_); const $ = n.findWordAt(S); Ha(n.doc, $.anchor, $.head) } } })) : Fe(i.scroller, 'dblclick', (_) => { return Lt(n, _) || tn(_) }), Fe(i.scroller, 'contextmenu', (_) => { return ev(n, _) }), Fe(i.input.getField(), 'contextmenu', (_) => { i.scroller.contains(_.target) || ev(n, _) }); let a; let l = { end: 0 }; function u() { i.activeTouch && (a = setTimeout(() => { return i.activeTouch = null }, 1e3), l = i.activeTouch, l.end = +new Date()) } function p(_) {
        if (_.touches.length != 1)
          return !1; const S = _.touches[0]; return S.radiusX <= 1 && S.radiusY <= 1
      } function m(_, S) {
        if (S.left == null)
          return !0; const $ = S.left - _.left; const D = S.top - _.top; return $ * $ + D * D > 20 * 20
      }Fe(i.scroller, 'touchstart', (_) => { if (!Lt(n, _) && !p(_) && !Nf(n, _)) { i.input.ensurePolled(), clearTimeout(a); const S = +new Date(); i.activeTouch = { start: S, moved: !1, prev: S - l.end <= 300 ? l : null }, _.touches.length == 1 && (i.activeTouch.left = _.touches[0].pageX, i.activeTouch.top = _.touches[0].pageY) } }), Fe(i.scroller, 'touchmove', () => { i.activeTouch && (i.activeTouch.moved = !0) }), Fe(i.scroller, 'touchend', (_) => { const S = i.activeTouch; if (S && !jr(i, _) && S.left != null && !S.moved && new Date() - S.start < 300) { const $ = n.coordsChar(i.activeTouch, 'page'); let D; !S.prev || m(S, S.prev) ? D = new ht($, $) : !S.prev.prev || m(S, S.prev.prev) ? D = n.findWordAt($) : D = new ht(Q($.line, 0), Ke(n.doc, Q($.line + 1, 0))), n.setSelection(D.anchor, D.head), n.focus(), tn(_) }u() }), Fe(i.scroller, 'touchcancel', u), Fe(i.scroller, 'scroll', () => { i.scroller.clientHeight && (Gs(n, i.scroller.scrollTop), ao(n, i.scroller.scrollLeft, !0), Et(n, 'scroll', n)) }), Fe(i.scroller, 'mousewheel', (_) => { return ug(n, _) }), Fe(i.scroller, 'DOMMouseScroll', (_) => { return ug(n, _) }), Fe(i.wrapper, 'scroll', () => { return i.wrapper.scrollTop = i.wrapper.scrollLeft = 0 }), i.dragFunctions = { enter(_) { Lt(n, _) || pi(_) }, over(_) { Lt(n, _) || (a_(n, _), pi(_)) }, start(_) { return l_(n, _) }, drop: Wt(n, s_), leave(_) { Lt(n, _) || Ig(n) } }; const w = i.input.getField(); Fe(w, 'keyup', (_) => { return Xg.call(n, _) }), Fe(w, 'keydown', Wt(n, Kg)), Fe(w, 'keypress', Wt(n, Yg)), Fe(w, 'focus', (_) => { return df(n, _) }), Fe(w, 'blur', (_) => { return Go(n, _) })
    } var $f = []; kt.defineInitHook = function (n) { return $f.push(n) }; function fl(n, i, a, l) {
      const u = n.doc; let p; a == null && (a = 'add'), a == 'smart' && (u.mode.indent ? p = Fs(n, i).state : a = 'prev'); const m = n.options.tabSize; const w = Pe(u, i); const _ = de(w.text, null, m); w.stateAfter && (w.stateAfter = null); const S = w.text.match(/^\s*/)[0]; let $; if (!l && !/\S/.test(w.text)) {
        $ = 0, a = 'not'
      }
      else if (a == 'smart' && ($ = u.mode.indent(p, w.text.slice(S.length), w.text), $ == P || $ > 150)) {
        if (!l)
          return; a = 'prev'
      }a == 'prev' ? i > u.first ? $ = de(Pe(u, i - 1).text, null, m) : $ = 0 : a == 'add' ? $ = _ + n.options.indentUnit : a == 'subtract' ? $ = _ - n.options.indentUnit : typeof a == 'number' && ($ = _ + a), $ = Math.max(0, $); let D = ''; let G = 0; if (n.options.indentWithTabs) {
        for (let U = Math.floor($ / m); U; --U)G += m, D += '	'
      } if (G < $ && (D += Se($ - G)), D != S)
        return Qo(u, D, Q(i, 0), Q(i, S.length), '+input'), w.stateAfter = null, !0; for (let ee = 0; ee < u.sel.ranges.length; ee++) { const ce = u.sel.ranges[ee]; if (ce.head.line == i && ce.head.ch < S.length) { const ve = Q(i, S.length); Cf(u, ee, new ht(ve, ve)); break } }
    } let gr = null; function Ka(n) { gr = n } function Of(n, i, a, l, u) {
      const p = n.doc; n.display.shift = !1, l || (l = p.sel); const m = +new Date() - 200; const w = u == 'paste' || n.state.pasteIncoming > m; const _ = Xn(i); let S = null; if (w && l.ranges.length > 1) {
        if (gr && gr.text.join(`
`) == i) { if (l.ranges.length % gr.text.length == 0) { S = []; for (let $ = 0; $ < gr.text.length; $++)S.push(p.splitLines(gr.text[$])) } }
        else {
          _.length == l.ranges.length && n.options.pasteLinesPerSelection && (S = xe(_, (be) => { return [be] }))
        }
      } for (var D = n.curOp.updateInput, G = l.ranges.length - 1; G >= 0; G--) {
        const U = l.ranges[G]; let ee = U.from(); let ce = U.to(); U.empty() && (a && a > 0
          ? ee = Q(ee.line, ee.ch - a)
          : n.state.overwrite && !w
            ? ce = Q(ce.line, Math.min(Pe(p, ce.line).text.length, ce.ch + fe(_).length))
            : w && gr && gr.lineWise && gr.text.join(`
`) == _.join(`
`) && (ee = ce = Q(ee.line, 0))); const ve = { from: ee, to: ce, text: S ? S[G % S.length] : _, origin: u || (w ? 'paste' : n.state.cutIncoming > m ? 'cut' : '+input') }; Jo(n.doc, ve), Bt(n, 'inputRead', n, ve)
      }i && !w && iv(n, i), Ko(n), n.curOp.updateInput < 2 && (n.curOp.updateInput = D), n.curOp.typing = !0, n.state.pasteIncoming = n.state.cutIncoming = -1
    } function rv(n, i) {
      const a = n.clipboardData && n.clipboardData.getData('Text'); if (a)
        return n.preventDefault(), !i.isReadOnly() && !i.options.disableInput && i.hasFocus() && An(i, () => { return Of(i, a, 0, null, 'paste') }), !0
    } function iv(n, i) {
      if (!(!n.options.electricChars || !n.options.smartIndent)) {
        for (let a = n.doc.sel, l = a.ranges.length - 1; l >= 0; l--) {
          const u = a.ranges[l]; if (!(u.head.ch > 100 || l && a.ranges[l - 1].head.line == u.head.line)) {
            const p = n.getModeAt(u.head); let m = !1; if (p.electricChars) {
              for (let w = 0; w < p.electricChars.length; w++) {
                if (i.includes(p.electricChars.charAt(w))) { m = fl(n, u.head.line, 'smart'); break }
              }
            }
            else {
              p.electricInput && p.electricInput.test(Pe(n.doc, u.head.line).text.slice(0, u.head.ch)) && (m = fl(n, u.head.line, 'smart'))
            }m && Bt(n, 'electricInput', n, u.head.line)
          }
        }
      }
    } function ov(n) { for (var i = [], a = [], l = 0; l < n.doc.sel.ranges.length; l++) { const u = n.doc.sel.ranges[l].head.line; const p = { anchor: Q(u, 0), head: Q(u + 1, 0) }; a.push(p), i.push(n.getRange(p.anchor, p.head)) } return { text: i, ranges: a } } function Pf(n, i, a, l) { n.setAttribute('autocorrect', a ? 'on' : 'off'), n.setAttribute('autocapitalize', l ? 'on' : 'off'), n.setAttribute('spellcheck', !!i) } function sv() { const n = k('textarea', null, null, 'position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none'); const i = k('div', [n], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;'); return v ? n.style.width = '1000px' : n.setAttribute('wrap', 'off'), L && (n.style.border = '1px solid black'), i } function O_(n) {
      const i = n.optionHandlers; const a = n.helpers = {}; n.prototype = { constructor: n, focus() { Ee(this).focus(), this.display.input.focus() }, setOption(l, u) { const p = this.options; const m = p[l]; p[l] == u && l != 'mode' || (p[l] = u, i.hasOwnProperty(l) && Wt(this, i[l])(this, u, m), Et(this, 'optionChange', this, l)) }, getOption(l) { return this.options[l] }, getDoc() { return this.doc }, addKeyMap(l, u) { this.state.keyMaps[u ? 'push' : 'unshift'](Va(l)) }, removeKeyMap(l) {
        for (let u = this.state.keyMaps, p = 0; p < u.length; ++p) {
          if (u[p] == l || u[p].name == l)
            return u.splice(p, 1), !0
        }
      }, addOverlay: an(function (l, u) {
        const p = l.token ? l : n.getMode(this.options, l); if (p.startState)
          throw new Error('Overlays may not be stateful.'); pe(this.state.overlays, { mode: p, modeSpec: l, opaque: u && u.opaque, priority: u && u.priority || 0 }, (m) => { return m.priority }), this.state.modeGen++, gn(this)
      }), removeOverlay: an(function (l) { for (let u = this.state.overlays, p = 0; p < u.length; ++p) { const m = u[p].modeSpec; if (m == l || typeof l == 'string' && m.name == l) { u.splice(p, 1), this.state.modeGen++, gn(this); return } } }), indentLine: an(function (l, u, p) { typeof u != 'string' && typeof u != 'number' && (u == null ? u = this.options.smartIndent ? 'smart' : 'prev' : u = u ? 'add' : 'subtract'), se(this.doc, l) && fl(this, l, u, p) }), indentSelection: an(function (l) {
        for (let u = this.doc.sel.ranges, p = -1, m = 0; m < u.length; m++) {
          const w = u[m]; if (w.empty()) {
            w.head.line > p && (fl(this, w.head.line, l, !0), p = w.head.line, m == this.doc.sel.primIndex && Ko(this))
          }
          else { const _ = w.from(); const S = w.to(); const $ = Math.max(p, _.line); p = Math.min(this.lastLine(), S.line - (S.ch ? 0 : 1)) + 1; for (let D = $; D < p; ++D)fl(this, D, l); const G = this.doc.sel.ranges; _.ch == 0 && u.length == G.length && G[m].from().ch > 0 && Cf(this.doc, m, new ht(_, G[m].to()), F) }
        }
      }), getTokenAt(l, u) { return vp(this, l, u) }, getLineTokens(l, u) { return vp(this, Q(l), u, !0) }, getTokenTypeAt(l) {
        l = Ke(this.doc, l); const u = hp(this, Pe(this.doc, l.line)); let p = 0; let m = (u.length - 1) / 2; const w = l.ch; let _; if (w == 0) {
          _ = u[2]
        }
        else {
          for (;;) {
            const S = p + m >> 1; if ((S ? u[S * 2 - 1] : 0) >= w) {
              m = S
            }
            else if (u[S * 2 + 1] < w) {
              p = S + 1
            }
            else { _ = u[S * 2 + 2]; break }
          }
        } const $ = _ ? _.indexOf('overlay ') : -1; return $ < 0 ? _ : $ == 0 ? null : _.slice(0, $ - 1)
      }, getModeAt(l) { const u = this.doc.mode; return u.innerMode ? n.innerMode(u, this.getTokenAt(l).state).mode : u }, getHelper(l, u) { return this.getHelpers(l, u)[0] }, getHelpers(l, u) {
        const p = []; if (!a.hasOwnProperty(u))
          return p; const m = a[u]; const w = this.getModeAt(l); if (typeof w[u] == 'string') {
          m[w[u]] && p.push(m[w[u]])
        }
        else if (w[u]) {
          for (let _ = 0; _ < w[u].length; _++) { const S = m[w[u][_]]; S && p.push(S) }
        }
        else {
          w.helperType && m[w.helperType] ? p.push(m[w.helperType]) : m[w.name] && p.push(m[w.name])
        } for (let $ = 0; $ < m._global.length; $++) { const D = m._global[$]; D.pred(w, this) && Te(p, D.val) == -1 && p.push(D.val) } return p
      }, getStateAfter(l, u) { const p = this.doc; return l = up(p, l ?? p.first + p.size - 1), Fs(this, l + 1, u).state }, cursorCoords(l, u) { let p; const m = this.doc.sel.primary(); return l == null ? p = m.head : typeof l == 'object' ? p = Ke(this.doc, l) : p = l ? m.from() : m.to(), hr(this, p, u || 'page') }, charCoords(l, u) { return Ma(this, Ke(this.doc, l), u || 'page') }, coordsChar(l, u) { return l = Vp(this, l, u || 'page'), rf(this, l.left, l.top) }, lineAtHeight(l, u) { return l = Vp(this, { top: l, left: 0 }, u || 'page').top, R(this.doc, l + this.display.viewOffset) }, heightAtLine(l, u, p) {
        let m = !1; let w; if (typeof l == 'number') { const _ = this.doc.first + this.doc.size - 1; l < this.doc.first ? l = this.doc.first : l > _ && (l = _, m = !0), w = Pe(this.doc, l) }
        else {
          w = l
        } return Aa(this, w, { top: 0, left: 0 }, u || 'page', p || m).top + (m ? this.doc.height - Vr(w) : 0)
      }, defaultTextHeight() { return Vo(this.display) }, defaultCharWidth() { return jo(this.display) }, getViewport() { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget(l, u, p, m, w) {
        const _ = this.display; l = hr(this, Ke(this.doc, l)); let S = l.bottom; let $ = l.left; if (u.style.position = 'absolute', u.setAttribute('cm-ignore-events', 'true'), this.display.input.setUneditable(u), _.sizer.appendChild(u), m == 'over') {
          S = l.top
        }
        else if (m == 'above' || m == 'near') { const D = Math.max(_.wrapper.clientHeight, this.doc.height); const G = Math.max(_.sizer.clientWidth, _.lineSpace.clientWidth); (m == 'above' || l.bottom + u.offsetHeight > D) && l.top > u.offsetHeight ? S = l.top - u.offsetHeight : l.bottom + u.offsetHeight <= D && (S = l.bottom), $ + u.offsetWidth > G && ($ = G - u.offsetWidth) }u.style.top = `${S}px`, u.style.left = u.style.right = '', w == 'right' ? ($ = _.sizer.clientWidth - u.offsetWidth, u.style.right = '0px') : (w == 'left' ? $ = 0 : w == 'middle' && ($ = (_.sizer.clientWidth - u.offsetWidth) / 2), u.style.left = `${$}px`), p && Mx(this, { left: $, top: S, right: $ + u.offsetWidth, bottom: S + u.offsetHeight })
      }, triggerOnKeyDown: an(Kg), triggerOnKeyPress: an(Yg), triggerOnKeyUp: Xg, triggerOnMouseDown: an(Zg), execCommand(l) {
        if (ll.hasOwnProperty(l))
          return ll[l].call(null, this)
      }, triggerElectric: an(function (l) { iv(this, l) }), findPosH(l, u, p, m) { let w = 1; u < 0 && (w = -1, u = -u); for (var _ = Ke(this.doc, l), S = 0; S < u && (_ = Rf(this.doc, _, w, p, m), !_.hitSide); ++S);return _ }, moveH: an(function (l, u) { const p = this; this.extendSelectionsBy((m) => { return p.display.shift || p.doc.extend || m.empty() ? Rf(p.doc, m.head, l, u, p.options.rtlMoveVisually) : l < 0 ? m.from() : m.to() }, ue) }), deleteH: an(function (l, u) { const p = this.doc.sel; const m = this.doc; p.somethingSelected() ? m.replaceSelection('', null, '+delete') : ns(this, (w) => { const _ = Rf(m, w.head, l, u, !1); return l < 0 ? { from: _, to: w.head } : { from: w.head, to: _ } }) }), findPosV(l, u, p, m) {
        let w = 1; let _ = m; u < 0 && (w = -1, u = -u); for (var S = Ke(this.doc, l), $ = 0; $ < u; ++$) {
          const D = hr(this, S, 'div'); if (_ == null ? _ = D.left : D.left = _, S = lv(this, D, w, p), S.hitSide)
            break
        } return S
      }, moveV: an(function (l, u) {
        const p = this; const m = this.doc; const w = []; const _ = !this.display.shift && !m.extend && m.sel.somethingSelected(); if (m.extendSelectionsBy(($) => {
          if (_)
            return l < 0 ? $.from() : $.to(); const D = hr(p, $.head, 'div'); $.goalColumn != null && (D.left = $.goalColumn), w.push(D.left); const G = lv(p, D, l, u); return u == 'page' && $ == m.sel.primary() && pf(p, Ma(p, G, 'div').top - D.top), G
        }, ue), w.length) {
          for (let S = 0; S < m.sel.ranges.length; S++)m.sel.ranges[S].goalColumn = w[S]
        }
      }), findWordAt(l) { const u = this.doc; const p = Pe(u, l.line).text; let m = l.ch; let w = l.ch; if (p) { const _ = this.getHelper(l, 'wordChars'); (l.sticky == 'before' || w == p.length) && m ? --m : ++w; for (var S = p.charAt(m), $ = Ge(S, _) ? function (D) { return Ge(D, _) } : /\s/.test(S) ? function (D) { return /\s/.test(D) } : function (D) { return !/\s/.test(D) && !Ge(D) }; m > 0 && $(p.charAt(m - 1));)--m; for (;w < p.length && $(p.charAt(w));)++w } return new ht(Q(l.line, m), Q(l.line, w)) }, toggleOverwrite(l) { l != null && l == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? Ne(this.display.cursorDiv, 'CodeMirror-overwrite') : K(this.display.cursorDiv, 'CodeMirror-overwrite'), Et(this, 'overwriteToggle', this, this.state.overwrite)) }, hasFocus() { return this.display.input.getField() == ye(rt(this)) }, isReadOnly() { return !!(this.options.readOnly || this.doc.cantEdit) }, scrollTo: an(function (l, u) { js(this, l, u) }), getScrollInfo() { const l = this.display.scroller; return { left: l.scrollLeft, top: l.scrollTop, height: l.scrollHeight - Tr(this) - this.display.barHeight, width: l.scrollWidth - Tr(this) - this.display.barWidth, clientHeight: Qu(this), clientWidth: io(this) } }, scrollIntoView: an(function (l, u) { l == null ? (l = { from: this.doc.sel.primary().head, to: null }, u == null && (u = this.options.cursorScrollMargin)) : typeof l == 'number' ? l = { from: Q(l, 0), to: null } : l.from == null && (l = { from: l, to: null }), l.to || (l.to = l.from), l.margin = u || 0, l.from.line != null ? Nx(this, l) : eg(this, l.from, l.to, l.margin) }), setSize: an(function (l, u) {
        const p = this; const m = function (_) { return typeof _ == 'number' || /^\d+$/.test(String(_)) ? `${_}px` : _ }; l != null && (this.display.wrapper.style.width = m(l)), u != null && (this.display.wrapper.style.height = m(u)), this.options.lineWrapping && Bp(this); let w = this.display.viewFrom; this.doc.iter(w, this.display.viewTo, (_) => {
          if (_.widgets) {
            for (let S = 0; S < _.widgets.length; S++) {
              if (_.widgets[S].noHScroll) { bi(p, w, 'widget'); break }
            }
          }++w
        }), this.curOp.forceUpdate = !0, Et(this, 'refresh', this)
      }), operation(l) { return An(this, l) }, startOperation() { return uo(this) }, endOperation() { return fo(this) }, refresh: an(function () { const l = this.display.cachedTextHeight; gn(this), this.curOp.forceUpdate = !0, Us(this), js(this, this.doc.scrollLeft, this.doc.scrollTop), mf(this.display), (l == null || Math.abs(l - Vo(this.display)) > 0.5 || this.options.lineWrapping) && af(this), Et(this, 'refresh', this) }), swapDoc: an(function (l) { const u = this.doc; return u.cm = null, this.state.selectingText && this.state.selectingText(), pg(this, l), Us(this), this.display.input.reset(), js(this, l.scrollLeft, l.scrollTop), this.curOp.forceScroll = !0, Bt(this, 'swapDoc', this, u), u }), phrase(l) { const u = this.options.phrases; return u && Object.prototype.hasOwnProperty.call(u, l) ? u[l] : l }, getInputField() { return this.display.input.getField() }, getWrapperElement() { return this.display.wrapper }, getScrollerElement() { return this.display.scroller }, getGutterElement() { return this.display.gutters } }, lr(n), n.registerHelper = function (l, u, p) { a.hasOwnProperty(l) || (a[l] = n[l] = { _global: [] }), a[l][u] = p }, n.registerGlobalHelper = function (l, u, p, m) { n.registerHelper(l, u, m), a[l]._global.push({ pred: p, val: m }) }
    } function Rf(n, i, a, l, u) {
      const p = i; const m = a; let w = Pe(n, i.line); const _ = u && n.direction == 'rtl' ? -a : a; function S() { const ke = i.line + _; return ke < n.first || ke >= n.first + n.size ? !1 : (i = new Q(ke, i.ch, i.sticky), w = Pe(n, ke)) } function $(ke) {
        let we; if (l == 'codepoint') {
          const Le = w.text.charCodeAt(i.ch + (a > 0 ? 0 : -1)); if (isNaN(Le)) {
            we = null
          }
          else { const He = a > 0 ? Le >= 55296 && Le < 56320 : Le >= 56320 && Le < 57343; we = new Q(i.line, Math.max(0, Math.min(w.text.length, i.ch + a * (He ? 2 : 1))), -a) }
        }
        else {
          u ? we = p_(n.cm, w, i, a) : we = Ef(w, i, a)
        } if (we == null) {
          if (!ke && S())
            i = Lf(u, n.cm, w, i.line, _); else return !1
        }
        else {
          i = we
        } return !0
      } if (l == 'char' || l == 'codepoint') {
        $()
      }
      else if (l == 'column') {
        $(!0)
      }
      else if (l == 'word' || l == 'group') {
        for (let D = null, G = l == 'group', U = n.cm && n.cm.getHelper(i, 'wordChars'), ee = !0; !(a < 0 && !$(!ee)); ee = !1) {
          const ce = w.text.charAt(i.ch) || `
`; let ve = Ge(ce, U)
            ? 'w'
            : G && ce == `
`
              ? 'n'
              : !G || /\s/.test(ce) ? null : 'p'; if (G && !ee && !ve && (ve = 's'), D && D != ve) { a < 0 && (a = 1, $(), i.sticky = 'after'); break } if (ve && (D = ve), a > 0 && !$(!ee))
            break
        }
      } const be = Ba(n, i, p, m, !0); return dt(p, be) && (be.hitSide = !0), be
    } function lv(n, i, a, l) {
      const u = n.doc; const p = i.left; let m; if (l == 'page') { const w = Math.min(n.display.wrapper.clientHeight, Ee(n).innerHeight || u(n).documentElement.clientHeight); const _ = Math.max(w - 0.5 * Vo(n.display), 3); m = (a > 0 ? i.bottom : i.top) + a * _ }
      else {
        l == 'line' && (m = a > 0 ? i.bottom + 3 : i.top - 3)
      } for (var S; S = rf(n, p, m), !!S.outside;) { if (a < 0 ? m <= 0 : m >= u.height) { S.hitSide = !0; break }m += a * 5 } return S
    } const mt = function (n) { this.cm = n, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new $e(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null }; mt.prototype.init = function (n) {
      const i = this; const a = this; const l = a.cm; const u = a.div = n.lineDiv; u.contentEditable = !0, Pf(u, l.options.spellcheck, l.options.autocorrect, l.options.autocapitalize); function p(w) {
        for (let _ = w.target; _; _ = _.parentNode) {
          if (_ == u)
            return !0; if (/\bCodeMirror-(?:line)?widget\b/.test(_.className))
            break
        } return !1
      }Fe(u, 'paste', (w) => { !p(w) || Lt(l, w) || rv(w, l) || g <= 11 && setTimeout(Wt(l, () => { return i.updateFromDOM() }), 20) }), Fe(u, 'compositionstart', (w) => { i.composing = { data: w.data, done: !1 } }), Fe(u, 'compositionupdate', (w) => { i.composing || (i.composing = { data: w.data, done: !1 }) }), Fe(u, 'compositionend', (w) => { i.composing && (w.data != i.composing.data && i.readFromDOMSoon(), i.composing.done = !0) }), Fe(u, 'touchstart', () => { return a.forceCompositionEnd() }), Fe(u, 'input', () => { i.composing || i.readFromDOMSoon() }); function m(w) {
        if (!(!p(w) || Lt(l, w))) {
          if (l.somethingSelected()) {
            Ka({ lineWise: !1, text: l.getSelections() }), w.type == 'cut' && l.replaceSelection('', null, 'cut')
          }
          else if (l.options.lineWiseCopyCut) { const _ = ov(l); Ka({ lineWise: !0, text: _.text }), w.type == 'cut' && l.operation(() => { l.setSelections(_.ranges, 0, F), l.replaceSelection('', null, 'cut') }) }
          else {
            return
          } if (w.clipboardData) {
            w.clipboardData.clearData(); const S = gr.text.join(`
`); if (w.clipboardData.setData('Text', S), w.clipboardData.getData('Text') == S) { w.preventDefault(); return }
          } const $ = sv(); const D = $.firstChild; Pf(D), l.display.lineSpace.insertBefore($, l.display.lineSpace.firstChild), D.value = gr.text.join(`
`); const G = ye(Ze(u)); je(D), setTimeout(() => { l.display.lineSpace.removeChild($), G.focus(), G == u && a.showPrimarySelection() }, 50)
        }
      }Fe(u, 'copy', m), Fe(u, 'cut', m)
    }, mt.prototype.screenReaderLabelChanged = function (n) { n ? this.div.setAttribute('aria-label', n) : this.div.removeAttribute('aria-label') }, mt.prototype.prepareSelection = function () { const n = Zp(this.cm, !1); return n.focus = ye(Ze(this.div)) == this.div, n }, mt.prototype.showSelection = function (n, i) { !n || !this.cm.display.view.length || ((n.focus || i) && this.showPrimarySelection(), this.showMultipleSelections(n)) }, mt.prototype.getSelection = function () { return this.cm.display.wrapper.ownerDocument.getSelection() }, mt.prototype.showPrimarySelection = function () {
      const n = this.getSelection(); const i = this.cm; const a = i.doc.sel.primary(); const l = a.from(); const u = a.to(); if (i.display.viewTo == i.display.viewFrom || l.line >= i.display.viewTo || u.line < i.display.viewFrom) { n.removeAllRanges(); return } const p = Xa(i, n.anchorNode, n.anchorOffset); const m = Xa(i, n.focusNode, n.focusOffset); if (!(p && !p.bad && m && !m.bad && _e(qo(p, m), l) == 0 && _e(pn(p, m), u) == 0)) {
        const w = i.display.view; const _ = l.line >= i.display.viewFrom && av(i, l) || { node: w[0].measure.map[2], offset: 0 }; let S = u.line < i.display.viewTo && av(i, u); if (!S) { const $ = w[w.length - 1].measure; const D = $.maps ? $.maps[$.maps.length - 1] : $.map; S = { node: D[D.length - 1], offset: D[D.length - 2] - D[D.length - 3] } } if (!_ || !S) { n.removeAllRanges(); return } const G = n.rangeCount && n.getRangeAt(0); let U; try { U = W(_.node, _.offset, S.offset, S.node) }
        catch {}U && (!s && i.state.focused ? (n.collapse(_.node, _.offset), U.collapsed || (n.removeAllRanges(), n.addRange(U))) : (n.removeAllRanges(), n.addRange(U)), G && n.anchorNode == null ? n.addRange(G) : s && this.startGracePeriod()), this.rememberSelection()
      }
    }, mt.prototype.startGracePeriod = function () { const n = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(() => { n.gracePeriod = !1, n.selectionChanged() && n.cm.operation(() => { return n.cm.curOp.selectionChanged = !0 }) }, 20) }, mt.prototype.showMultipleSelections = function (n) { I(this.cm.display.cursorDiv, n.cursors), I(this.cm.display.selectionDiv, n.selection) }, mt.prototype.rememberSelection = function () { const n = this.getSelection(); this.lastAnchorNode = n.anchorNode, this.lastAnchorOffset = n.anchorOffset, this.lastFocusNode = n.focusNode, this.lastFocusOffset = n.focusOffset }, mt.prototype.selectionInEditor = function () {
      const n = this.getSelection(); if (!n.rangeCount)
        return !1; const i = n.getRangeAt(0).commonAncestorContainer; return ie(this.div, i)
    }, mt.prototype.focus = function () { this.cm.options.readOnly != 'nocursor' && ((!this.selectionInEditor() || ye(Ze(this.div)) != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus()) }, mt.prototype.blur = function () { this.div.blur() }, mt.prototype.getField = function () { return this.div }, mt.prototype.supportsTouch = function () { return !0 }, mt.prototype.receivedFocus = function () { const n = this; const i = this; this.selectionInEditor() ? setTimeout(() => { return n.pollSelection() }, 20) : An(this.cm, () => { return i.cm.curOp.selectionChanged = !0 }); function a() { i.cm.state.focused && (i.pollSelection(), i.polling.set(i.cm.options.pollInterval, a)) } this.polling.set(this.cm.options.pollInterval, a) }, mt.prototype.selectionChanged = function () { const n = this.getSelection(); return n.anchorNode != this.lastAnchorNode || n.anchorOffset != this.lastAnchorOffset || n.focusNode != this.lastFocusNode || n.focusOffset != this.lastFocusOffset }, mt.prototype.pollSelection = function () { if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) { const n = this.getSelection(); const i = this.cm; if (O && b && this.cm.display.gutterSpecs.length && P_(n.anchorNode)) { this.cm.triggerOnKeyDown({ type: 'keydown', keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus(); return } if (!this.composing) { this.rememberSelection(); const a = Xa(i, n.anchorNode, n.anchorOffset); const l = Xa(i, n.focusNode, n.focusOffset); a && l && An(i, () => { nn(i.doc, xi(a, l), F), (a.bad || l.bad) && (i.curOp.selectionChanged = !0) }) } } }, mt.prototype.pollContent = function () {
      this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null); const n = this.cm; const i = n.display; const a = n.doc.sel.primary(); let l = a.from(); let u = a.to(); if (l.ch == 0 && l.line > n.firstLine() && (l = Q(l.line - 1, Pe(n.doc, l.line - 1).length)), u.ch == Pe(n.doc, u.line).text.length && u.line < n.lastLine() && (u = Q(u.line + 1, 0)), l.line < i.viewFrom || u.line > i.viewTo - 1)
        return !1; let p, m, w; l.line == i.viewFrom || (p = lo(n, l.line)) == 0 ? (m = C(i.view[0].line), w = i.view[0].node) : (m = C(i.view[p].line), w = i.view[p - 1].node.nextSibling); const _ = lo(n, u.line); let S; let $; if (_ == i.view.length - 1 ? (S = i.viewTo - 1, $ = i.lineDiv.lastChild) : (S = C(i.view[_ + 1].line) - 1, $ = i.view[_ + 1].node.previousSibling), !w)
        return !1; for (var D = n.doc.splitLines(R_(n, w, $, m, S)), G = Wr(n.doc, Q(m, 0), Q(S, Pe(n.doc, S).text.length)); D.length > 1 && G.length > 1;) {
        if (fe(D) == fe(G))
          D.pop(), G.pop(), S--; else if (D[0] == G[0])
          D.shift(), G.shift(), m++; else break
      } for (var U = 0, ee = 0, ce = D[0], ve = G[0], be = Math.min(ce.length, ve.length); U < be && ce.charCodeAt(U) == ve.charCodeAt(U);)++U; for (var ke = fe(D), we = fe(G), Le = Math.min(ke.length - (D.length == 1 ? U : 0), we.length - (G.length == 1 ? U : 0)); ee < Le && ke.charCodeAt(ke.length - ee - 1) == we.charCodeAt(we.length - ee - 1);)++ee; if (D.length == 1 && G.length == 1 && m == l.line) {
        for (;U && U > l.ch && ke.charCodeAt(ke.length - ee - 1) == we.charCodeAt(we.length - ee - 1);)U--, ee++
      } D[D.length - 1] = ke.slice(0, ke.length - ee).replace(/^\u200B+/, ''), D[0] = D[0].slice(U).replace(/\u200B+$/, ''); const He = Q(m, U); const De = Q(S, G.length ? fe(G).length - ee : 0); if (D.length > 1 || D[0] || _e(He, De))
        return Qo(n.doc, D, He, De, '+input'), !0
    }, mt.prototype.ensurePolled = function () { this.forceCompositionEnd() }, mt.prototype.reset = function () { this.forceCompositionEnd() }, mt.prototype.forceCompositionEnd = function () { this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus()) }, mt.prototype.readFromDOMSoon = function () {
      const n = this; this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(() => {
        if (n.readDOMTimeout = null, n.composing) {
          if (n.composing.done)
            n.composing = null; else return
        } n.updateFromDOM()
      }, 80))
    }, mt.prototype.updateFromDOM = function () { const n = this; (this.cm.isReadOnly() || !this.pollContent()) && An(this.cm, () => { return gn(n.cm) }) }, mt.prototype.setUneditable = function (n) { n.contentEditable = 'false' }, mt.prototype.onKeyPress = function (n) { n.charCode == 0 || this.composing || (n.preventDefault(), this.cm.isReadOnly() || Wt(this.cm, Of)(this.cm, String.fromCharCode(n.charCode == null ? n.keyCode : n.charCode), 0)) }, mt.prototype.readOnlyChanged = function (n) { this.div.contentEditable = String(n != 'nocursor') }, mt.prototype.onContextMenu = function () {}, mt.prototype.resetPosition = function () {}, mt.prototype.needsContentAttribute = !0; function av(n, i) {
      const a = ef(n, i.line); if (!a || a.hidden)
        return null; const l = Pe(n.doc, i.line); const u = zp(a, l, i.line); const p = Ve(l, n.doc.direction); let m = 'left'; if (p) { const w = sr(p, i.ch); m = w % 2 ? 'right' : 'left' } const _ = Hp(u.map, i.ch, m); return _.offset = _.collapse == 'right' ? _.end : _.start, _
    } function P_(n) {
      for (let i = n; i; i = i.parentNode) {
        if (/CodeMirror-gutter-wrapper/.test(i.className))
          return !0
      } return !1
    } function is(n, i) { return i && (n.bad = !0), n } function R_(n, i, a, l, u) {
      let p = ''; let m = !1; const w = n.doc.lineSeparator(); let _ = !1; function S(U) { return function (ee) { return ee.id == U } } function $() { m && (p += w, _ && (p += w), m = _ = !1) } function D(U) { U && ($(), p += U) } function G(U) {
        if (U.nodeType == 1) {
          const ee = U.getAttribute('cm-text'); if (ee) { D(ee); return } const ce = U.getAttribute('cm-marker'); let ve; if (ce) { const be = n.findMarks(Q(l, 0), Q(u + 1, 0), S(+ce)); be.length && (ve = be[0].find(0)) && D(Wr(n.doc, ve.from, ve.to).join(w)); return } if (U.getAttribute('contenteditable') == 'false')
            return; const ke = /^(pre|div|p|li|table|br)$/i.test(U.nodeName); if (!/^br$/i.test(U.nodeName) && U.textContent.length == 0)
            return; ke && $(); for (let we = 0; we < U.childNodes.length; we++)G(U.childNodes[we]); /^(pre|p)$/i.test(U.nodeName) && (_ = !0), ke && (m = !0)
        }
        else {
          U.nodeType == 3 && D(U.nodeValue.replace(/\u200B/g, '').replace(/\u00A0/g, ' '))
        }
      } for (;G(i), i != a;)i = i.nextSibling, _ = !1; return p
    } function Xa(n, i, a) {
      let l; if (i == n.display.lineDiv) {
        if (l = n.display.lineDiv.childNodes[a], !l)
          return is(n.clipPos(Q(n.display.viewTo - 1)), !0); i = null, a = 0
      }
      else {
        for (l = i; ;l = l.parentNode) {
          if (!l || l == n.display.lineDiv)
            return null; if (l.parentNode && l.parentNode == n.display.lineDiv)
            break
        }
      } for (let u = 0; u < n.display.view.length; u++) {
        const p = n.display.view[u]; if (p.node == l)
          return D_(p, i, a)
      }
    } function D_(n, i, a) {
      const l = n.text.firstChild; let u = !1; if (!i || !ie(l, i))
        return is(Q(C(n.line), 0), !0); if (i == l && (u = !0, i = l.childNodes[a], a = 0, !i)) { const p = n.rest ? fe(n.rest) : n.line; return is(Q(C(p), p.text.length), u) } let m = i.nodeType == 3 ? i : null; let w = i; for (!m && i.childNodes.length == 1 && i.firstChild.nodeType == 3 && (m = i.firstChild, a && (a = m.nodeValue.length)); w.parentNode != l;)w = w.parentNode; const _ = n.measure; const S = _.maps; function $(ve, be, ke) {
        for (let we = -1; we < (S ? S.length : 0); we++) {
          for (let Le = we < 0 ? _.map : S[we], He = 0; He < Le.length; He += 3) { const De = Le[He + 2]; if (De == ve || De == be) { const Je = C(we < 0 ? n.line : n.rest[we]); let wt = Le[He] + ke; return (ke < 0 || De != ve) && (wt = Le[He + (ke ? 1 : 0)]), Q(Je, wt) } }
        }
      } let D = $(m, w, a); if (D)
        return is(D, u); for (let G = w.nextSibling, U = m ? m.nodeValue.length - a : 0; G; G = G.nextSibling) {
        if (D = $(G, G.firstChild, 0), D)
          return is(Q(D.line, D.ch - U), u); U += G.textContent.length
      } for (let ee = w.previousSibling, ce = a; ee; ee = ee.previousSibling) {
        if (D = $(ee, ee.firstChild, -1), D)
          return is(Q(D.line, D.ch + ce), u); ce += ee.textContent.length
      }
    } const Nt = function (n) { this.cm = n, this.prevInput = '', this.pollingFast = !1, this.polling = new $e(), this.hasSelection = !1, this.composing = null, this.resetting = !1 }; Nt.prototype.init = function (n) {
      const i = this; const a = this; const l = this.cm; this.createField(n); const u = this.textarea; n.wrapper.insertBefore(this.wrapper, n.wrapper.firstChild), L && (u.style.width = '0px'), Fe(u, 'input', () => { h && g >= 9 && i.hasSelection && (i.hasSelection = null), a.poll() }), Fe(u, 'paste', (m) => { Lt(l, m) || rv(m, l) || (l.state.pasteIncoming = +new Date(), a.fastPoll()) }); function p(m) {
        if (!Lt(l, m)) {
          if (l.somethingSelected()) {
            Ka({ lineWise: !1, text: l.getSelections() })
          }
          else if (l.options.lineWiseCopyCut) {
            const w = ov(l); Ka({ lineWise: !0, text: w.text }), m.type == 'cut'
              ? l.setSelections(w.ranges, null, F)
              : (a.prevInput = '', u.value = w.text.join(`
`), je(u))
          }
          else {
            return
          }m.type == 'cut' && (l.state.cutIncoming = +new Date())
        }
      }Fe(u, 'cut', p), Fe(u, 'copy', p), Fe(n.scroller, 'paste', (m) => { if (!(jr(n, m) || Lt(l, m))) { if (!u.dispatchEvent) { l.state.pasteIncoming = +new Date(), a.focus(); return } const w = new Event('paste'); w.clipboardData = m.clipboardData, u.dispatchEvent(w) } }), Fe(n.lineSpace, 'selectstart', (m) => { jr(n, m) || tn(m) }), Fe(u, 'compositionstart', () => { const m = l.getCursor('from'); a.composing && a.composing.range.clear(), a.composing = { start: m, range: l.markText(m, l.getCursor('to'), { className: 'CodeMirror-composing' }) } }), Fe(u, 'compositionend', () => { a.composing && (a.poll(), a.composing.range.clear(), a.composing = null) })
    }, Nt.prototype.createField = function (n) { this.wrapper = sv(), this.textarea = this.wrapper.firstChild; const i = this.cm.options; Pf(this.textarea, i.spellcheck, i.autocorrect, i.autocapitalize) }, Nt.prototype.screenReaderLabelChanged = function (n) { n ? this.textarea.setAttribute('aria-label', n) : this.textarea.removeAttribute('aria-label') }, Nt.prototype.prepareSelection = function () { const n = this.cm; const i = n.display; const a = n.doc; const l = Zp(n); if (n.options.moveInputWithCursor) { const u = hr(n, a.sel.primary().head, 'div'); const p = i.wrapper.getBoundingClientRect(); const m = i.lineDiv.getBoundingClientRect(); l.teTop = Math.max(0, Math.min(i.wrapper.clientHeight - 10, u.top + m.top - p.top)), l.teLeft = Math.max(0, Math.min(i.wrapper.clientWidth - 10, u.left + m.left - p.left)) } return l }, Nt.prototype.showSelection = function (n) { const i = this.cm; const a = i.display; I(a.cursorDiv, n.cursors), I(a.selectionDiv, n.selection), n.teTop != null && (this.wrapper.style.top = `${n.teTop}px`, this.wrapper.style.left = `${n.teLeft}px`) }, Nt.prototype.reset = function (n) {
      if (!(this.contextMenuPending || this.composing && n)) {
        const i = this.cm; if (this.resetting = !0, i.somethingSelected()) { this.prevInput = ''; const a = i.getSelection(); this.textarea.value = a, i.state.focused && je(this.textarea), h && g >= 9 && (this.hasSelection = a) }
        else {
          n || (this.prevInput = this.textarea.value = '', h && g >= 9 && (this.hasSelection = null))
        } this.resetting = !1
      }
    }, Nt.prototype.getField = function () { return this.textarea }, Nt.prototype.supportsTouch = function () { return !1 }, Nt.prototype.focus = function () {
      if (this.cm.options.readOnly != 'nocursor' && (!A || ye(Ze(this.textarea)) != this.textarea)) {
        try { this.textarea.focus() }
        catch {}
      }
    }, Nt.prototype.blur = function () { this.textarea.blur() }, Nt.prototype.resetPosition = function () { this.wrapper.style.top = this.wrapper.style.left = 0 }, Nt.prototype.receivedFocus = function () { this.slowPoll() }, Nt.prototype.slowPoll = function () { const n = this; this.pollingFast || this.polling.set(this.cm.options.pollInterval, () => { n.poll(), n.cm.state.focused && n.slowPoll() }) }, Nt.prototype.fastPoll = function () { let n = !1; const i = this; i.pollingFast = !0; function a() { const l = i.poll(); !l && !n ? (n = !0, i.polling.set(60, a)) : (i.pollingFast = !1, i.slowPoll()) }i.polling.set(20, a) }, Nt.prototype.poll = function () {
      const n = this; const i = this.cm; const a = this.textarea; let l = this.prevInput; if (this.contextMenuPending || this.resetting || !i.state.focused || vi(a) && !l && !this.composing || i.isReadOnly() || i.options.disableInput || i.state.keySeq)
        return !1; const u = a.value; if (u == l && !i.somethingSelected())
        return !1; if (h && g >= 9 && this.hasSelection === u || H && /[\uF700-\uF7FF]/.test(u))
        return i.display.input.reset(), !1; if (i.doc.sel == i.display.selForContextMenu) {
        const p = u.charCodeAt(0); if (p == 8203 && !l && (l = ''), p == 8666)
          return this.reset(), this.cm.execCommand('undo')
      } for (var m = 0, w = Math.min(l.length, u.length); m < w && l.charCodeAt(m) == u.charCodeAt(m);)++m; return An(i, () => {
        Of(i, u.slice(m), l.length - m, null, n.composing ? '*compose' : null), u.length > 1e3 || u.includes(`
`)
          ? a.value = n.prevInput = ''
          : n.prevInput = u, n.composing && (n.composing.range.clear(), n.composing.range = i.markText(n.composing.start, i.getCursor('to'), { className: 'CodeMirror-composing' }))
      }), !0
    }, Nt.prototype.ensurePolled = function () { this.pollingFast && this.poll() && (this.pollingFast = !1) }, Nt.prototype.onKeyPress = function () { h && g >= 9 && (this.hasSelection = null), this.fastPoll() }, Nt.prototype.onContextMenu = function (n) {
      const i = this; const a = i.cm; const l = a.display; const u = i.textarea; i.contextMenuPending && i.contextMenuPending(); const p = so(a, n); const m = l.scroller.scrollTop; if (!p || T)
        return; const w = a.options.resetSelectionOnContextMenu; w && a.doc.sel.contains(p) == -1 && Wt(a, nn)(a.doc, xi(p), F); const _ = u.style.cssText; const S = i.wrapper.style.cssText; const $ = i.wrapper.offsetParent.getBoundingClientRect(); i.wrapper.style.cssText = 'position: static', u.style.cssText = `position: absolute; width: 30px; height: 30px;
  top: ${n.clientY - $.top - 5}px; left: ${n.clientX - $.left - 5}px;
      z-index: 1000; background: ${h ? 'rgba(255, 255, 255, .05)' : 'transparent'};
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;let D; v && (D = u.ownerDocument.defaultView.scrollY), l.input.focus(), v && u.ownerDocument.defaultView.scrollTo(null, D), l.input.reset(), a.somethingSelected() || (u.value = i.prevInput = ' '), i.contextMenuPending = U, l.selForContextMenu = a.doc.sel, clearTimeout(l.detectingSelectAll); function G() { if (u.selectionStart != null) { const ce = a.somethingSelected(); const ve = `${ce ? u.value : ''}`; u.value = '', u.value = ve, i.prevInput = ce ? '' : '', u.selectionStart = 1, u.selectionEnd = ve.length, l.selForContextMenu = a.doc.sel } } function U() { if (i.contextMenuPending == U && (i.contextMenuPending = !1, i.wrapper.style.cssText = S, u.style.cssText = _, h && g < 9 && l.scrollbars.setScrollTop(l.scroller.scrollTop = m), u.selectionStart != null)) { (!h || h && g < 9) && G(); let ce = 0; const ve = function () { l.selForContextMenu == a.doc.sel && u.selectionStart == 0 && u.selectionEnd > 0 && i.prevInput == '' ? Wt(a, Eg)(a) : ce++ < 10 ? l.detectingSelectAll = setTimeout(ve, 500) : (l.selForContextMenu = null, l.input.reset()) }; l.detectingSelectAll = setTimeout(ve, 200) } } if (h && g >= 9 && G(), j) { pi(n); const ee = function () { en(window, 'mouseup', ee), setTimeout(U, 20) }; Fe(window, 'mouseup', ee) }
      else {
        setTimeout(U, 50)
      }
    }, Nt.prototype.readOnlyChanged = function (n) { n || this.reset(), this.textarea.disabled = n == 'nocursor', this.textarea.readOnly = !!n }, Nt.prototype.setUneditable = function () {}, Nt.prototype.needsContentAttribute = !1; function z_(n, i) {
      if (i = i ? ae(i) : {}, i.value = n.value, !i.tabindex && n.tabIndex && (i.tabindex = n.tabIndex), !i.placeholder && n.placeholder && (i.placeholder = n.placeholder), i.autofocus == null) { const a = ye(Ze(n)); i.autofocus = a == n || n.getAttribute('autofocus') != null && a == document.body } function l() { n.value = w.getValue() } let u; if (n.form && (Fe(n.form, 'submit', l), !i.leaveSubmitMethodAlone)) {
        const p = n.form; u = p.submit; try { var m = p.submit = function () { l(), p.submit = u, p.submit(), p.submit = m } }
        catch {}
      }i.finishInit = function (_) { _.save = l, _.getTextArea = function () { return n }, _.toTextArea = function () { _.toTextArea = isNaN, l(), n.parentNode.removeChild(_.getWrapperElement()), n.style.display = '', n.form && (en(n.form, 'submit', l), !i.leaveSubmitMethodAlone && typeof n.form.submit == 'function' && (n.form.submit = u)) } }, n.style.display = 'none'; var w = kt((_) => { return n.parentNode.insertBefore(_, n.nextSibling) }, i); return w
    } function I_(n) { n.off = en, n.on = Fe, n.wheelEventPixels = Vx, n.Doc = vn, n.splitLines = Xn, n.countColumn = de, n.findColumn = le, n.isWordChar = Ue, n.Pass = P, n.signal = Et, n.Line = Bo, n.changeEnd = _i, n.scrollbarModel = rg, n.Pos = Q, n.cmpPos = _e, n.modes = Do, n.mimeModes = ur, n.resolveMode = zo, n.getMode = Io, n.modeExtensions = mi, n.extendMode = Fo, n.copyState = kr, n.startState = Ho, n.innerMode = zs, n.commands = ll, n.keyMap = Kr, n.keyName = Wg, n.isModifierKey = qg, n.lookupKey = ts, n.normalizeKeyMap = h_, n.StringStream = At, n.SharedTextMarker = il, n.TextMarker = ki, n.LineWidget = rl, n.e_preventDefault = tn, n.e_stopPropagation = Po, n.e_stop = pi, n.addClass = Ne, n.contains = ie, n.rmClass = K, n.keyNames = Ci }A_(kt), O_(kt); const F_ = 'iter insert remove copy getEditor constructor'.split(' '); for (const Ya in vn.prototype)vn.prototype.hasOwnProperty(Ya) && Te(F_, Ya) < 0 && (kt.prototype[Ya] = (function (n) { return function () { return n.apply(this.doc, arguments) } }(vn.prototype[Ya]))); return lr(vn), kt.inputStyles = { textarea: Nt, contenteditable: mt }, kt.defineMode = function (n) { !kt.defaults.mode && n != 'null' && (kt.defaults.mode = n), fr.apply(this, arguments) }, kt.defineMIME = ro, kt.defineMode('null', () => { return { token(n) { return n.skipToEnd() } } }), kt.defineMIME('text/plain', 'null'), kt.defineExtension = function (n, i) { kt.prototype[n] = i }, kt.defineDocExtension = function (n, i) { vn.prototype[n] = i }, kt.fromTextArea = z_, I_(kt), kt.version = '5.65.17', kt
  })
})(Yw); const Ps = Yw.exports; const dfe = Vb(Ps); const hfe = { exports: {} }; (function (e, t) {
  (function (r) { r(Ps) })((r) => {
    r.defineMode('javascript', (o, s) => {
      const c = o.indentUnit; const f = s.statementIndent; const d = s.jsonld; const h = s.json || d; const g = s.trackScope !== !1; const v = s.typescript; const y = s.wordCharacters || /[\w$\xA1-\uFFFF]/; const b = (function () { function C(qt) { return { type: qt, style: 'keyword' } } const R = C('keyword a'); const se = C('keyword b'); const ge = C('keyword c'); const Q = C('keyword d'); const _e = C('operator'); const dt = { type: 'atom', style: 'atom' }; return { if: C('if'), while: R, with: R, else: se, do: se, try: se, finally: se, return: Q, break: Q, continue: Q, new: C('new'), delete: ge, void: ge, throw: ge, debugger: C('debugger'), var: C('var'), const: C('var'), let: C('var'), function: C('function'), catch: C('catch'), for: C('for'), switch: C('switch'), case: C('case'), default: C('default'), in: _e, typeof: _e, instanceof: _e, true: dt, false: dt, null: dt, undefined: dt, NaN: dt, Infinity: dt, this: C('this'), class: C('class'), super: C('atom'), yield: ge, export: C('export'), import: C('import'), extends: ge, await: ge } }()); const x = /[+\-*&%=<>!?|~^@]/; const T = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function E(C) {
        for (var R = !1, se, ge = !1; (se = C.next()) != null;) {
          if (!R) {
            if (se == '/' && !ge)
              return; se == '[' ? ge = !0 : ge && se == ']' && (ge = !1)
          }R = !R && se == '\\'
        }
      } let M, N; function L(C, R, se) { return M = C, N = se, R } function O(C, R) {
        const se = C.next(); if (se == '"' || se == '\'')
          return R.tokenize = A(se), R.tokenize(C, R); if (se == '.' && C.match(/^\d[\d_]*(?:e[+\-]?[\d_]+)?/i))
          return L('number', 'number'); if (se == '.' && C.match('..'))
          return L('spread', 'meta'); if (/[[\]{}(),;:.]/.test(se))
          return L(se); if (se == '=' && C.eat('>'))
          return L('=>', 'operator'); if (se == '0' && C.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
          return L('number', 'number'); if (/\d/.test(se))
          return C.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), L('number', 'number'); if (se == '/')
          return C.eat('*') ? (R.tokenize = H, H(C, R)) : C.eat('/') ? (C.skipToEnd(), L('comment', 'comment')) : Hn(C, R, 1) ? (E(C), C.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), L('regexp', 'string-2')) : (C.eat('='), L('operator', 'operator', C.current())); if (se == '`')
          return R.tokenize = z, z(C, R); if (se == '#' && C.peek() == '!')
          return C.skipToEnd(), L('meta', 'meta'); if (se == '#' && C.eatWhile(y))
          return L('variable', 'property'); if (se == '<' && C.match('!--') || se == '-' && C.match('->') && !/\S/.test(C.string.slice(0, C.start)))
          return C.skipToEnd(), L('comment', 'comment'); if (x.test(se))
          return (se != '>' || !R.lexical || R.lexical.type != '>') && (C.eat('=') ? (se == '!' || se == '=') && C.eat('=') : /[<>*+\-|&?]/.test(se) && (C.eat(se), se == '>' && C.eat(se))), se == '?' && C.eat('.') ? L('.') : L('operator', 'operator', C.current()); if (y.test(se)) {
          C.eatWhile(y); const ge = C.current(); if (R.lastType != '.') {
            if (b.propertyIsEnumerable(ge)) { const Q = b[ge]; return L(Q.type, Q.style, ge) } if (ge == 'async' && C.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[[(\w]/, !1))
              return L('async', 'keyword', ge)
          } return L('variable', 'variable', ge)
        }
      } function A(C) {
        return function (R, se) {
          let ge = !1; let Q; if (d && R.peek() == '@' && R.match(T))
            return se.tokenize = O, L('jsonld-keyword', 'meta'); for (;(Q = R.next()) != null && !(Q == C && !ge);)ge = !ge && Q == '\\'; return ge || (se.tokenize = O), L('string', 'string')
        }
      } function H(C, R) { for (var se = !1, ge; ge = C.next();) { if (ge == '/' && se) { R.tokenize = O; break }se = ge == '*' } return L('comment', 'comment') } function z(C, R) { for (var se = !1, ge; (ge = C.next()) != null;) { if (!se && (ge == '`' || ge == '$' && C.eat('{'))) { R.tokenize = O; break }se = !se && ge == '\\' } return L('quasi', 'string-2', C.current()) } const J = '([{}])'; function re(C, R) {
        R.fatArrowAt && (R.fatArrowAt = null); let se = C.string.indexOf('=>', C.start); if (!(se < 0)) {
          if (v) { const ge = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(C.string.slice(C.start, se)); ge && (se = ge.index) } for (var Q = 0, _e = !1, dt = se - 1; dt >= 0; --dt) {
            const qt = C.string.charAt(dt); const pn = J.indexOf(qt); if (pn >= 0 && pn < 3) { if (!Q) { ++dt; break } if (--Q == 0) { qt == '(' && (_e = !0); break } }
            else if (pn >= 3 && pn < 6) {
              ++Q
            }
            else if (y.test(qt)) {
              _e = !0
            }
            else if (/["'/`]/.test(qt)) {
              for (;;--dt) {
                if (dt == 0)
                  return; const qo = C.string.charAt(dt - 1); if (qo == qt && C.string.charAt(dt - 2) != '\\') { dt--; break }
              }
            }
            else if (_e && !Q) { ++dt; break }
          }_e && !Q && (R.fatArrowAt = dt)
        }
      } const te = { 'atom': !0, 'number': !0, 'variable': !0, 'string': !0, 'regexp': !0, 'this': !0, 'import': !0, 'jsonld-keyword': !0 }; function j(C, R, se, ge, Q, _e) { this.indented = C, this.column = R, this.type = se, this.prev = Q, this.info = _e, ge != null && (this.align = ge) } function ne(C, R) {
        if (!g)
          return !1; for (var se = C.localVars; se; se = se.next) {
          if (se.name == R)
            return !0
        } for (let ge = C.context; ge; ge = ge.prev) {
          for (var se = ge.vars; se; se = se.next) {
            if (se.name == R)
              return !0
          }
        }
      } function K(C, R, se, ge, Q) { const _e = C.cc; for (V.state = C, V.stream = Q, V.marked = null, V.cc = _e, V.style = R, C.lexical.hasOwnProperty('align') || (C.lexical.align = !0); ;) { const dt = _e.length ? _e.pop() : h ? Te : de; if (dt(se, ge)) { for (;_e.length && _e[_e.length - 1].lex;)_e.pop()(); return V.marked ? V.marked : se == 'variable' && ne(C, ge) ? 'variable-2' : R } } } var V = { state: null, column: null, marked: null, cc: null }; function I() { for (let C = arguments.length - 1; C >= 0; C--)V.cc.push(arguments[C]) } function k() { return I.apply(null, arguments), !0 } function B(C, R) {
        for (let se = R; se; se = se.next) {
          if (se.name == C)
            return !0
        } return !1
      } function W(C) {
        const R = V.state; if (V.marked = 'def', !!g) {
          if (R.context) {
            if (R.lexical.info == 'var' && R.context && R.context.block) { const se = ie(C, R.context); if (se != null) { R.context = se; return } }
            else if (!B(C, R.localVars)) { R.localVars = new We(C, R.localVars); return }
          }s.globalVars && !B(C, R.globalVars) && (R.globalVars = new We(C, R.globalVars))
        }
      } function ie(C, R) {
        if (R) {
          if (R.block) { const se = ie(C, R.prev); return se ? se == R.prev ? R : new Ne(se, R.vars, !0) : null }
          else {
            return B(C, R.vars) ? R : new Ne(R.prev, new We(C, R.vars), !1)
          }
        }
        else {
          return null
        }
      } function ye(C) { return C == 'public' || C == 'private' || C == 'protected' || C == 'abstract' || C == 'readonly' } function Ne(C, R, se) { this.prev = C, this.vars = R, this.block = se } function We(C, R) { this.name = C, this.next = R } const je = new We('this', new We('arguments', null)); function it() { V.state.context = new Ne(V.state.context, V.state.localVars, !1), V.state.localVars = je } function rt() { V.state.context = new Ne(V.state.context, V.state.localVars, !0), V.state.localVars = null }it.lex = rt.lex = !0; function Ze() { V.state.localVars = V.state.context.vars, V.state.context = V.state.context.prev }Ze.lex = !0; function Ee(C, R) {
        const se = function () {
          const ge = V.state; let Q = ge.indented; if (ge.lexical.type == 'stat') {
            Q = ge.lexical.indented
          }
          else {
            for (let _e = ge.lexical; _e && _e.type == ')' && _e.align; _e = _e.prev)Q = _e.indented
          }ge.lexical = new j(Q, V.stream.column(), C, null, ge.lexical, R)
        }; return se.lex = !0, se
      } function X() { const C = V.state; C.lexical.prev && (C.lexical.type == ')' && (C.indented = C.lexical.indented), C.lexical = C.lexical.prev) }X.lex = !0; function ae(C) { function R(se) { return se == C ? k() : C == ';' || se == '}' || se == ')' || se == ']' ? I() : k(R) } return R } function de(C, R) { return C == 'var' ? k(Ee('vardef', R), Po, ae(';'), X) : C == 'keyword a' ? k(Ee('form'), P, de, X) : C == 'keyword b' ? k(Ee('form'), de, X) : C == 'keyword d' ? V.stream.match(/^\s*$/, !1) ? k() : k(Ee('stat'), Z, ae(';'), X) : C == 'debugger' ? k(ae(';')) : C == '{' ? k(Ee('}'), rt, Jt, X, Ze) : C == ';' ? k() : C == 'if' ? (V.state.lexical.info == 'else' && V.state.cc[V.state.cc.length - 1] == X && V.state.cc.pop()(), k(Ee('form'), P, de, X, Ro)) : C == 'function' ? k(Xn) : C == 'for' ? k(Ee('form'), rt, ba, de, Ze, X) : C == 'class' || v && R == 'interface' ? (V.marked = 'keyword', k(Ee('form', C == 'class' ? C : R), Do, X)) : C == 'variable' ? v && R == 'declare' ? (V.marked = 'keyword', k(de)) : v && (R == 'module' || R == 'enum' || R == 'type') && V.stream.match(/^\s*\w/, !1) ? (V.marked = 'keyword', R == 'enum' ? k(Pe) : R == 'type' ? k(wa, ae('operator'), Ve, ae(';')) : k(Ee('form'), hn, ae('{'), Ee('}'), Jt, X, X)) : v && R == 'namespace' ? (V.marked = 'keyword', k(Ee('form'), Te, de, X)) : v && R == 'abstract' ? (V.marked = 'keyword', k(de)) : k(Ee('stat'), Re) : C == 'switch' ? k(Ee('form'), P, ae('{'), Ee('}', 'switch'), rt, Jt, X, X, Ze) : C == 'case' ? k(Te, ae(':')) : C == 'default' ? k(ae(':')) : C == 'catch' ? k(Ee('form'), it, $e, de, X, Ze) : C == 'export' ? k(Ee('stat'), zo, X) : C == 'import' ? k(Ee('stat'), mi, X) : C == 'async' ? k(de) : R == '@' ? k(Te, de) : I(Ee('stat'), Te, ae(';'), X) } function $e(C) {
        if (C == '(')
          return k(cr, ae(')'))
      } function Te(C, R) { return F(C, R, !1) } function Ye(C, R) { return F(C, R, !0) } function P(C) { return C != '(' ? I() : k(Ee(')'), Z, ae(')'), X) } function F(C, R, se) {
        if (V.state.fatArrowAt == V.stream.start) {
          const ge = se ? xe : fe; if (C == '(')
            return k(it, Ee(')'), nt(cr, ')'), X, ae('=>'), ge, Ze); if (C == 'variable')
            return I(it, hn, ae('=>'), ge, Ze)
        } const Q = se ? le : ue; return te.hasOwnProperty(C) ? k(Q) : C == 'function' ? k(Xn, Q) : C == 'class' || v && R == 'interface' ? (V.marked = 'keyword', k(Ee('form'), Wu, X)) : C == 'keyword c' || C == 'async' ? k(se ? Ye : Te) : C == '(' ? k(Ee(')'), Z, ae(')'), X, Q) : C == 'operator' || C == 'spread' ? k(se ? Ye : Te) : C == '[' ? k(Ee(']'), At, X, Q) : C == '{' ? It(Ge, '}', null, Q) : C == 'quasi' ? I(he, Q) : C == 'new' ? k(pe(se)) : k()
      } function Z(C) { return C.match(/[;})\],]/) ? I() : I(Te) } function ue(C, R) { return C == ',' ? k(Z) : le(C, R, !1) } function le(C, R, se) {
        const ge = se == !1 ? ue : le; const Q = se == !1 ? Te : Ye; if (C == '=>')
          return k(it, se ? xe : fe, Ze); if (C == 'operator')
          return /\+\+|--/.test(R) || v && R == '!' ? k(ge) : v && R == '<' && V.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? k(Ee('>'), nt(Ve, '>'), X, ge) : R == '?' ? k(Te, ae(':'), Q) : k(Q); if (C == 'quasi')
          return I(he, ge); if (C != ';') {
          if (C == '(')
            return It(Ye, ')', 'call', ge); if (C == '.')
            return k(Ue, ge); if (C == '[')
            return k(Ee(']'), Z, ae(']'), X, ge); if (v && R == 'as')
            return V.marked = 'keyword', k(Ve, ge); if (C == 'regexp')
            return V.state.lastType = V.marked = 'operator', V.stream.backUp(V.stream.pos - V.stream.start - 1), k(Q)
        }
      } function he(C, R) { return C != 'quasi' ? I() : R.slice(R.length - 2) != '${' ? k(he) : k(Z, Se) } function Se(C) {
        if (C == '}')
          return V.marked = 'string-2', V.state.tokenize = z, k(he)
      } function fe(C) { return re(V.stream, V.state), I(C == '{' ? de : Te) } function xe(C) { return re(V.stream, V.state), I(C == '{' ? de : Ye) } function pe(C) { return function (R) { return R == '.' ? k(C ? ze : Ae) : R == 'variable' && v ? k(Ln, C ? le : ue) : I(C ? Ye : Te) } } function Ae(C, R) {
        if (R == 'target')
          return V.marked = 'keyword', k(ue)
      } function ze(C, R) {
        if (R == 'target')
          return V.marked = 'keyword', k(le)
      } function Re(C) { return C == ':' ? k(X, de) : I(ue, ae(';'), X) } function Ue(C) {
        if (C == 'variable')
          return V.marked = 'property', k()
      } function Ge(C, R) {
        if (C == 'async')
          return V.marked = 'property', k(Ge); if (C == 'variable' || V.style == 'keyword') {
          if (V.marked = 'property', R == 'get' || R == 'set')
            return k(vt); let se; return v && V.state.fatArrowAt == V.stream.start && (se = V.stream.match(/^\s*:\s*/, !1)) && (V.state.fatArrowAt = V.stream.pos + se[0].length), k(tt)
        }
        else {
          if (C == 'number' || C == 'string')
            return V.marked = d ? 'property' : `${V.style} property`, k(tt); if (C == 'jsonld-keyword')
            return k(tt); if (v && ye(R))
            return V.marked = 'keyword', k(Ge); if (C == '[')
            return k(Te, or, ae(']'), tt); if (C == 'spread')
            return k(Ye, tt); if (R == '*')
            return V.marked = 'keyword', k(Ge); if (C == ':')
            return I(tt)
        }
      } function vt(C) { return C != 'variable' ? I(tt) : (V.marked = 'property', k(Xn)) } function tt(C) {
        if (C == ':')
          return k(Ye); if (C == '(')
          return I(Xn)
      } function nt(C, R, se) { function ge(Q, _e) { if (se ? se.includes(Q) : Q == ',') { const dt = V.state.lexical; return dt.info == 'call' && (dt.pos = (dt.pos || 0) + 1), k((qt, pn) => { return qt == R || pn == R ? I() : I(C) }, ge) } return Q == R || _e == R ? k() : se && se.includes(';') ? I(C) : k(ae(R)) } return function (Q, _e) { return Q == R || _e == R ? k() : I(C, ge) } } function It(C, R, se) { for (let ge = 3; ge < arguments.length; ge++)V.cc.push(arguments[ge]); return k(Ee(R, se), nt(C, R), X) } function Jt(C) { return C == '}' ? k() : I(de, Jt) } function or(C, R) {
        if (v) {
          if (C == ':')
            return k(Ve); if (R == '?')
            return k(or)
        }
      } function Fn(C, R) {
        if (v && (C == ':' || R == 'in'))
          return k(Ve)
      } function sr(C) {
        if (v && C == ':')
          return V.stream.match(/^\s*\w+\s+is\b/, !1) ? k(Te, Qt, Ve) : k(Ve)
      } function Qt(C, R) {
        if (R == 'is')
          return V.marked = 'keyword', k()
      } function Ve(C, R) {
        if (R == 'keyof' || R == 'typeof' || R == 'infer' || R == 'readonly')
          return V.marked = 'keyword', k(R == 'typeof' ? Ye : Ve); if (C == 'variable' || R == 'void')
          return V.marked = 'type', k(Kn); if (R == '|' || R == '&')
          return k(Ve); if (C == 'string' || C == 'number' || C == 'atom')
          return k(Kn); if (C == '[')
          return k(Ee(']'), nt(Ve, ']', ','), X, Kn); if (C == '{')
          return k(Ee('}'), Fe, X, Kn); if (C == '(')
          return k(nt(Lt, ')'), no, Kn); if (C == '<')
          return k(nt(Ve, '>'), Ve); if (C == 'quasi')
          return I(en, Kn)
      } function no(C) {
        if (C == '=>')
          return k(Ve)
      } function Fe(C) { return C.match(/[})\]]/) ? k() : C == ',' || C == ';' ? k(Fe) : I(Br, Fe) } function Br(C, R) {
        if (C == 'variable' || V.style == 'keyword')
          return V.marked = 'property', k(Br); if (R == '?' || C == 'number' || C == 'string')
          return k(Br); if (C == ':')
          return k(Ve); if (C == '[')
          return k(ae('variable'), Fn, ae(']'), Br); if (C == '(')
          return I(vi, Br); if (!C.match(/[;})\],]/))
          return k()
      } function en(C, R) { return C != 'quasi' ? I() : R.slice(R.length - 2) != '${' ? k(en) : k(Ve, Et) } function Et(C) {
        if (C == '}')
          return V.marked = 'string-2', V.state.tokenize = z, k(en)
      } function Lt(C, R) { return C == 'variable' && V.stream.match(/^\s*[?:]/, !1) || R == '?' ? k(Lt) : C == ':' ? k(Ve) : C == 'spread' ? k(Lt) : I(Ve) } function Kn(C, R) {
        if (R == '<')
          return k(Ee('>'), nt(Ve, '>'), X, Kn); if (R == '|' || C == '.' || R == '&')
          return k(Ve); if (C == '[')
          return k(Ve, ae(']'), Kn); if (R == 'extends' || R == 'implements')
          return V.marked = 'keyword', k(Ve); if (R == '?')
          return k(Ve, ae(':'), Ve)
      } function Ln(C, R) {
        if (R == '<')
          return k(Ee('>'), nt(Ve, '>'), X, Kn)
      } function lr() { return I(Ve, tn) } function tn(C, R) {
        if (R == '=')
          return k(Ve)
      } function Po(C, R) { return R == 'enum' ? (V.marked = 'keyword', k(Pe)) : I(hn, or, ar, Bu) } function hn(C, R) {
        if (v && ye(R))
          return V.marked = 'keyword', k(hn); if (C == 'variable')
          return W(R), k(); if (C == 'spread')
          return k(hn); if (C == '[')
          return It(Rs, ']'); if (C == '{')
          return It(pi, '}')
      } function pi(C, R) { return C == 'variable' && !V.stream.match(/^\s*:/, !1) ? (W(R), k(ar)) : (C == 'variable' && (V.marked = 'property'), C == 'spread' ? k(hn) : C == '}' ? I() : C == '[' ? k(Te, ae(']'), ae(':'), pi) : k(ae(':'), hn, ar)) } function Rs() { return I(hn, ar) } function ar(C, R) {
        if (R == '=')
          return k(Ye)
      } function Bu(C) {
        if (C == ',')
          return k(Po)
      } function Ro(C, R) {
        if (C == 'keyword b' && R == 'else')
          return k(Ee('form', 'else'), de, X)
      } function ba(C, R) {
        if (R == 'await')
          return k(ba); if (C == '(')
          return k(Ee(')'), Ds, X)
      } function Ds(C) { return C == 'var' ? k(Po, gi) : C == 'variable' ? k(gi) : I(gi) } function gi(C, R) { return C == ')' ? k() : C == ';' ? k(gi) : R == 'in' || R == 'of' ? (V.marked = 'keyword', k(Te, gi)) : I(Te, gi) } function Xn(C, R) {
        if (R == '*')
          return V.marked = 'keyword', k(Xn); if (C == 'variable')
          return W(R), k(Xn); if (C == '(')
          return k(it, Ee(')'), nt(cr, ')'), X, sr, de, Ze); if (v && R == '<')
          return k(Ee('>'), nt(lr, '>'), X, Xn)
      } function vi(C, R) {
        if (R == '*')
          return V.marked = 'keyword', k(vi); if (C == 'variable')
          return W(R), k(vi); if (C == '(')
          return k(it, Ee(')'), nt(cr, ')'), X, sr, Ze); if (v && R == '<')
          return k(Ee('>'), nt(lr, '>'), X, vi)
      } function wa(C, R) {
        if (C == 'keyword' || C == 'variable')
          return V.marked = 'type', k(wa); if (R == '<')
          return k(Ee('>'), nt(lr, '>'), X)
      } function cr(C, R) { return R == '@' && k(Te, cr), C == 'spread' ? k(cr) : v && ye(R) ? (V.marked = 'keyword', k(cr)) : v && C == 'this' ? k(or, ar) : I(hn, or, ar) } function Wu(C, R) { return C == 'variable' ? Do(C, R) : ur(C, R) } function Do(C, R) {
        if (C == 'variable')
          return W(R), k(ur)
      } function ur(C, R) {
        if (R == '<')
          return k(Ee('>'), nt(lr, '>'), X, ur); if (R == 'extends' || R == 'implements' || v && C == ',')
          return R == 'implements' && (V.marked = 'keyword'), k(v ? Ve : Te, ur); if (C == '{')
          return k(Ee('}'), fr, X)
      } function fr(C, R) {
        if (C == 'async' || C == 'variable' && (R == 'static' || R == 'get' || R == 'set' || v && ye(R)) && V.stream.match(/^\s+#?[\w$\xA1-\uFFFF]/, !1))
          return V.marked = 'keyword', k(fr); if (C == 'variable' || V.style == 'keyword')
          return V.marked = 'property', k(ro, fr); if (C == 'number' || C == 'string')
          return k(ro, fr); if (C == '[')
          return k(Te, or, ae(']'), ro, fr); if (R == '*')
          return V.marked = 'keyword', k(fr); if (v && C == '(')
          return I(vi, fr); if (C == ';' || C == ',')
          return k(fr); if (C == '}')
          return k(); if (R == '@')
          return k(Te, fr)
      } function ro(C, R) {
        if (R == '!' || R == '?')
          return k(ro); if (C == ':')
          return k(Ve, ar); if (R == '=')
          return k(Ye); const se = V.state.lexical.prev; const ge = se && se.info == 'interface'; return I(ge ? vi : Xn)
      } function zo(C, R) { return R == '*' ? (V.marked = 'keyword', k(Ho, ae(';'))) : R == 'default' ? (V.marked = 'keyword', k(Te, ae(';'))) : C == '{' ? k(nt(Io, '}'), Ho, ae(';')) : I(de) } function Io(C, R) {
        if (R == 'as')
          return V.marked = 'keyword', k(ae('variable')); if (C == 'variable')
          return I(Ye, Io)
      } function mi(C) { return C == 'string' ? k() : C == '(' ? I(Te) : C == '.' ? I(ue) : I(Fo, kr, Ho) } function Fo(C, R) { return C == '{' ? It(Fo, '}') : (C == 'variable' && W(R), R == '*' && (V.marked = 'keyword'), k(zs)) } function kr(C) {
        if (C == ',')
          return k(Fo, kr)
      } function zs(C, R) {
        if (R == 'as')
          return V.marked = 'keyword', k(Fo)
      } function Ho(C, R) {
        if (R == 'from')
          return V.marked = 'keyword', k(Te)
      } function At(C) { return C == ']' ? k() : I(nt(Ye, ']')) } function Pe() { return I(Ee('form'), hn, ae('{'), Ee('}'), nt(Wr, '}'), X, X) } function Wr() { return I(hn, ar) } function Is(C, R) { return C.lastType == 'operator' || C.lastType == ',' || x.test(R.charAt(0)) || /[,.]/.test(R.charAt(0)) } function Hn(C, R, se) { return R.tokenize == O && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[[{}(,;:]|=>)$/.test(R.lastType) || R.lastType == 'quasi' && /\{\s*$/.test(C.string.slice(0, C.pos - (se || 0))) } return { startState(C) { const R = { tokenize: O, lastType: 'sof', cc: [], lexical: new j((C || 0) - c, 0, 'block', !1), localVars: s.localVars, context: s.localVars && new Ne(null, null, !1), indented: C || 0 }; return s.globalVars && typeof s.globalVars == 'object' && (R.globalVars = s.globalVars), R }, token(C, R) {
        if (C.sol() && (R.lexical.hasOwnProperty('align') || (R.lexical.align = !1), R.indented = C.indentation(), re(C, R)), R.tokenize != H && C.eatSpace())
          return null; const se = R.tokenize(C, R); return M == 'comment' ? se : (R.lastType = M == 'operator' && (N == '++' || N == '--') ? 'incdec' : M, K(R, se, M, N, C))
      }, indent(C, R) {
        if (C.tokenize == H || C.tokenize == z)
          return r.Pass; if (C.tokenize != O)
          return 0; const se = R && R.charAt(0); let ge = C.lexical; let Q; if (!/^\s*else\b/.test(R)) {
          for (let _e = C.cc.length - 1; _e >= 0; --_e) {
            const dt = C.cc[_e]; if (dt == X)
              ge = ge.prev; else if (dt != Ro && dt != Ze)
              break
          }
        } for (;(ge.type == 'stat' || ge.type == 'form') && (se == '}' || (Q = C.cc[C.cc.length - 1]) && (Q == ue || Q == le) && !/^[,.=+\-*:?[(]/.test(R));)ge = ge.prev; f && ge.type == ')' && ge.prev.type == 'stat' && (ge = ge.prev); const qt = ge.type; const pn = se == qt; return qt == 'vardef' ? ge.indented + (C.lastType == 'operator' || C.lastType == ',' ? ge.info.length + 1 : 0) : qt == 'form' && se == '{' ? ge.indented : qt == 'form' ? ge.indented + c : qt == 'stat' ? ge.indented + (Is(C, R) ? f || c : 0) : ge.info == 'switch' && !pn && s.doubleIndentSwitch != !1 ? ge.indented + (/^(?:case|default)\b/.test(R) ? c : 2 * c) : ge.align ? ge.column + (pn ? 0 : 1) : ge.indented + (pn ? 0 : c)
      }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: h ? null : '/*', blockCommentEnd: h ? null : '*/', blockCommentContinue: h ? null : ' * ', lineComment: h ? null : '//', fold: 'brace', closeBrackets: '()[]{}\'\'""``', helperType: h ? 'json' : 'javascript', jsonldMode: d, jsonMode: h, expressionAllowed: Hn, skipExpression(C) { K(C, 'atom', 'atom', 'true', new r.StringStream('', 2, null)) } }
    }), r.registerHelper('wordChars', 'javascript', /[\w$]/), r.defineMIME('text/javascript', 'javascript'), r.defineMIME('text/ecmascript', 'javascript'), r.defineMIME('application/javascript', 'javascript'), r.defineMIME('application/x-javascript', 'javascript'), r.defineMIME('application/ecmascript', 'javascript'), r.defineMIME('application/json', { name: 'javascript', json: !0 }), r.defineMIME('application/x-json', { name: 'javascript', json: !0 }), r.defineMIME('application/manifest+json', { name: 'javascript', json: !0 }), r.defineMIME('application/ld+json', { name: 'javascript', jsonld: !0 }), r.defineMIME('text/typescript', { name: 'javascript', typescript: !0 }), r.defineMIME('application/typescript', { name: 'javascript', typescript: !0 })
  })
})(); const pfe = hfe.exports; const gfe = { exports: {} }; (function (e, t) {
  (function (r) { r(Ps) })((r) => {
    const o = { autoSelfClosers: { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0 }, implicitlyClosed: { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, contextGrabbers: { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0 } }, doNotIndent: { pre: !0 }, allowUnquoted: !0, allowMissing: !0, caseFold: !0 }; const s = { autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: !1, allowMissing: !1, allowMissingTagName: !1, caseFold: !1 }; r.defineMode('xml', (c, f) => {
      const d = c.indentUnit; const h = {}; const g = f.htmlMode ? o : s; for (var v in g)h[v] = g[v]; for (var v in f)h[v] = f[v]; let y, b; function x(k, B) {
        function W(Ne) { return B.tokenize = Ne, Ne(k, B) } const ie = k.next(); if (ie == '<')
          return k.eat('!') ? k.eat('[') ? k.match('CDATA[') ? W(M('atom', ']]>')) : null : k.match('--') ? W(M('comment', '-->')) : k.match('DOCTYPE', !0, !0) ? (k.eatWhile(/[\w.\-]/), W(N(1))) : null : k.eat('?') ? (k.eatWhile(/[\w.\-]/), B.tokenize = M('meta', '?>'), 'meta') : (y = k.eat('/') ? 'closeTag' : 'openTag', B.tokenize = T, 'tag bracket'); if (ie == '&') { let ye; return k.eat('#') ? k.eat('x') ? ye = k.eatWhile(/[a-f\d]/i) && k.eat(';') : ye = k.eatWhile(/\d/) && k.eat(';') : ye = k.eatWhile(/[\w.\-:]/) && k.eat(';'), ye ? 'atom' : 'error' }
        else {
          return k.eatWhile(/[^&<]/), null
        }
      }x.isInText = !0; function T(k, B) {
        const W = k.next(); if (W == '>' || W == '/' && k.eat('>'))
          return B.tokenize = x, y = W == '>' ? 'endTag' : 'selfcloseTag', 'tag bracket'; if (W == '=')
          return y = 'equals', null; if (W == '<') { B.tokenize = x, B.state = z, B.tagName = B.tagStart = null; const ie = B.tokenize(k, B); return ie ? `${ie} tag error` : 'tag error' }
        else {
          return /['"]/.test(W) ? (B.tokenize = E(W), B.stringStartCol = k.column(), B.tokenize(k, B)) : (k.match(/^[^\s=<>"']*[^\s=<>"'/]/), 'word')
        }
      } function E(k) {
        const B = function (W, ie) {
          for (;!W.eol();) {
            if (W.next() == k) { ie.tokenize = T; break }
          } return 'string'
        }; return B.isInAttribute = !0, B
      } function M(k, B) { return function (W, ie) { for (;!W.eol();) { if (W.match(B)) { ie.tokenize = x; break }W.next() } return k } } function N(k) {
        return function (B, W) {
          for (var ie; (ie = B.next()) != null;) {
            if (ie == '<')
              return W.tokenize = N(k + 1), W.tokenize(B, W); if (ie == '>') {
              if (k == 1) { W.tokenize = x; break }
              else {
                return W.tokenize = N(k - 1), W.tokenize(B, W)
              }
            }
          } return 'meta'
        }
      } function L(k) { return k && k.toLowerCase() } function O(k, B, W) { this.prev = k.context, this.tagName = B || '', this.indent = k.indented, this.startOfLine = W, (h.doNotIndent.hasOwnProperty(B) || k.context && k.context.noIndent) && (this.noIndent = !0) } function A(k) { k.context && (k.context = k.context.prev) } function H(k, B) {
        for (var W; ;) {
          if (!k.context || (W = k.context.tagName, !h.contextGrabbers.hasOwnProperty(L(W)) || !h.contextGrabbers[L(W)].hasOwnProperty(L(B))))
            return; A(k)
        }
      } function z(k, B, W) { return k == 'openTag' ? (W.tagStart = B.column(), J) : k == 'closeTag' ? re : z } function J(k, B, W) { return k == 'word' ? (W.tagName = B.current(), b = 'tag', ne) : h.allowMissingTagName && k == 'endTag' ? (b = 'tag bracket', ne(k, B, W)) : (b = 'error', J) } function re(k, B, W) {
        if (k == 'word') { const ie = B.current(); return W.context && W.context.tagName != ie && h.implicitlyClosed.hasOwnProperty(L(W.context.tagName)) && A(W), W.context && W.context.tagName == ie || h.matchClosing === !1 ? (b = 'tag', te) : (b = 'tag error', j) }
        else {
          return h.allowMissingTagName && k == 'endTag' ? (b = 'tag bracket', te(k, B, W)) : (b = 'error', j)
        }
      } function te(k, B, W) { return k != 'endTag' ? (b = 'error', te) : (A(W), z) } function j(k, B, W) { return b = 'error', te(k, B, W) } function ne(k, B, W) {
        if (k == 'word')
          return b = 'attribute', K; if (k == 'endTag' || k == 'selfcloseTag') { const ie = W.tagName; const ye = W.tagStart; return W.tagName = W.tagStart = null, k == 'selfcloseTag' || h.autoSelfClosers.hasOwnProperty(L(ie)) ? H(W, ie) : (H(W, ie), W.context = new O(W, ie, ye == W.indented)), z } return b = 'error', ne
      } function K(k, B, W) { return k == 'equals' ? V : (h.allowMissing || (b = 'error'), ne(k, B, W)) } function V(k, B, W) { return k == 'string' ? I : k == 'word' && h.allowUnquoted ? (b = 'string', ne) : (b = 'error', ne(k, B, W)) } function I(k, B, W) { return k == 'string' ? I : ne(k, B, W) } return { startState(k) { const B = { tokenize: x, state: z, indented: k || 0, tagName: null, tagStart: null, context: null }; return k != null && (B.baseIndent = k), B }, token(k, B) {
        if (!B.tagName && k.sol() && (B.indented = k.indentation()), k.eatSpace())
          return null; y = null; let W = B.tokenize(k, B); return (W || y) && W != 'comment' && (b = null, B.state = B.state(y || W, k, B), b && (W = b == 'error' ? `${W} error` : b)), W
      }, indent(k, B, W) {
        let ie = k.context; if (k.tokenize.isInAttribute)
          return k.tagStart == k.indented ? k.stringStartCol + 1 : k.indented + d; if (ie && ie.noIndent)
          return r.Pass; if (k.tokenize != T && k.tokenize != x)
          return W ? W.match(/^(\s*)/)[0].length : 0; if (k.tagName)
          return h.multilineTagIndentPastTag !== !1 ? k.tagStart + k.tagName.length + 2 : k.tagStart + d * (h.multilineTagIndentFactor || 1); if (h.alignCDATA && /<!\[CDATA\[/.test(B))
          return 0; const ye = B && /^<(\/)?([\w:.-]*)/.exec(B); if (ye && ye[1]) {
          for (;ie;) {
            if (ie.tagName == ye[2]) { ie = ie.prev; break }
            else if (h.implicitlyClosed.hasOwnProperty(L(ie.tagName))) {
              ie = ie.prev
            }
            else {
              break
            }
          }
        }
        else if (ye) {
          for (;ie;) {
            const Ne = h.contextGrabbers[L(ie.tagName)]; if (Ne && Ne.hasOwnProperty(L(ye[2])))
              ie = ie.prev; else break
          }
        } for (;ie && ie.prev && !ie.startOfLine;)ie = ie.prev; return ie ? ie.indent + d : k.baseIndent || 0
      }, electricInput: /<\/[\s\w:]+>$/, blockCommentStart: '<!--', blockCommentEnd: '-->', configuration: h.htmlMode ? 'html' : 'xml', helperType: h.htmlMode ? 'html' : 'xml', skipAttribute(k) { k.state == V && (k.state = ne) }, xmlCurrentTag(k) { return k.tagName ? { name: k.tagName, close: k.type == 'closeTag' } : null }, xmlCurrentContext(k) { for (var B = [], W = k.context; W; W = W.prev)B.push(W.tagName); return B.reverse() } }
    }), r.defineMIME('text/xml', 'xml'), r.defineMIME('application/xml', 'xml'), r.mimeModes.hasOwnProperty('text/html') || r.defineMIME('text/html', { name: 'xml', htmlMode: !0 })
  })
})(); const vfe = gfe.exports; (function (e, t) {
  (function (r) { r(Ps, vfe, pfe) })((r) => {
    function o(c, f, d, h) { this.state = c, this.mode = f, this.depth = d, this.prev = h } function s(c) { return new o(r.copyState(c.mode, c.state), c.mode, c.depth, c.prev && s(c.prev)) }r.defineMode('jsx', (c, f) => {
      const d = r.getMode(c, { name: 'xml', allowMissing: !0, multilineTagIndentPastTag: !1, allowMissingTagName: !0 }); const h = r.getMode(c, f && f.base || 'javascript'); function g(x) { const T = x.tagName; x.tagName = null; const E = d.indent(x, '', ''); return x.tagName = T, E } function v(x, T) { return T.context.mode == d ? y(x, T, T.context) : b(x, T, T.context) } function y(x, T, E) {
        if (E.depth == 2)
          return x.match(/^.*?\*\//) ? E.depth = 1 : x.skipToEnd(), 'comment'; if (x.peek() == '{') {
          d.skipAttribute(E.state); let M = g(E.state); let N = E.state.context; if (N && x.match(/^[^>]*>\s*$/, !1)) { for (;N.prev && !N.startOfLine;)N = N.prev; N.startOfLine ? M -= c.indentUnit : E.prev.state.lexical && (M = E.prev.state.lexical.indented) }
          else {
            E.depth == 1 && (M += c.indentUnit)
          } return T.context = new o(r.startState(h, M), h, 0, T.context), null
        } if (E.depth == 1) {
          if (x.peek() == '<')
            return d.skipAttribute(E.state), T.context = new o(r.startState(d, g(E.state)), d, 0, T.context), null; if (x.match('//'))
            return x.skipToEnd(), 'comment'; if (x.match('/*'))
            return E.depth = 2, v(x, T)
        } const L = d.token(x, E.state); const O = x.current(); let A; return /\btag\b/.test(L) ? O.endsWith('>') ? E.state.context ? E.depth = 0 : T.context = T.context.prev : O.startsWith('<') && (E.depth = 1) : !L && (A = O.indexOf('{')) > -1 && x.backUp(O.length - A), L
      } function b(x, T, E) {
        if (x.peek() == '<' && !x.match(/^<([^<>]|<[^>]*>)+,\s*>/, !1) && h.expressionAllowed(x, E.state))
          return T.context = new o(r.startState(d, h.indent(E.state, '', '')), d, 0, T.context), h.skipExpression(E.state), null; const M = h.token(x, E.state); if (!M && E.depth != null) { const N = x.current(); N == '{' ? E.depth++ : N == '}' && --E.depth == 0 && (T.context = T.context.prev) } return M
      } return { startState() { return { context: new o(r.startState(h), h) } }, copyState(x) { return { context: s(x.context) } }, token: v, indent(x, T, E) { return x.context.mode.indent(x.context.state, T, E) }, innerMode(x) { return x.context } }
    }, 'xml', 'javascript'), r.defineMIME('text/jsx', 'jsx'), r.defineMIME('text/typescript-jsx', { name: 'jsx', base: { name: 'javascript', typescript: !0 } })
  })
})(); (function (e, t) {
  (function (r) { r(Ps) })((r) => {
    r.defineOption('placeholder', '', (g, v, y) => {
      const b = y && y != r.Init; if (v && !b) {
        g.on('blur', f), g.on('change', d), g.on('swapDoc', d), r.on(g.getInputField(), 'compositionupdate', g.state.placeholderCompose = function () { c(g) }), d(g)
      }
      else if (!v && b) { g.off('blur', f), g.off('change', d), g.off('swapDoc', d), r.off(g.getInputField(), 'compositionupdate', g.state.placeholderCompose), o(g); const x = g.getWrapperElement(); x.className = x.className.replace(' CodeMirror-empty', '') }v && !g.hasFocus() && f(g)
    }); function o(g) { g.state.placeholder && (g.state.placeholder.parentNode.removeChild(g.state.placeholder), g.state.placeholder = null) } function s(g) { o(g); const v = g.state.placeholder = document.createElement('pre'); v.style.cssText = 'height: 0; overflow: visible', v.style.direction = g.getOption('direction'), v.className = 'CodeMirror-placeholder CodeMirror-line-like'; let y = g.getOption('placeholder'); typeof y == 'string' && (y = document.createTextNode(y)), v.appendChild(y), g.display.lineSpace.insertBefore(v, g.display.lineSpace.firstChild) } function c(g) { setTimeout(() => { let v = !1; if (g.lineCount() == 1) { const y = g.getInputField(); v = y.nodeName == 'TEXTAREA' ? !g.getLine(0).length : !/[^\u200B]/.test(y.querySelector('.CodeMirror-line').textContent) }v ? s(g) : o(g) }, 20) } function f(g) { h(g) && s(g) } function d(g) { const v = g.getWrapperElement(); const y = h(g); v.className = v.className.replace(' CodeMirror-empty', '') + (y ? ' CodeMirror-empty' : ''), y ? s(g) : o(g) } function h(g) { return g.lineCount() === 1 && g.getLine(0) === '' }
  })
})(); (function (e, t) {
  (function (r) { r(Ps) })((r) => {
    function o(f, d, h) {
      this.orientation = d, this.scroll = h, this.screen = this.total = this.size = 1, this.pos = 0, this.node = document.createElement('div'), this.node.className = `${f}-${d}`, this.inner = this.node.appendChild(document.createElement('div')); const g = this; r.on(this.inner, 'mousedown', (y) => {
        if (y.which != 1)
          return; r.e_preventDefault(y); const b = g.orientation == 'horizontal' ? 'pageX' : 'pageY'; const x = y[b]; const T = g.pos; function E() { r.off(document, 'mousemove', M), r.off(document, 'mouseup', E) } function M(N) {
          if (N.which != 1)
            return E(); g.moveTo(T + (N[b] - x) * (g.total / g.size))
        }r.on(document, 'mousemove', M), r.on(document, 'mouseup', E)
      }), r.on(this.node, 'click', (y) => { r.e_preventDefault(y); const b = g.inner.getBoundingClientRect(); let x; g.orientation == 'horizontal' ? x = y.clientX < b.left ? -1 : y.clientX > b.right ? 1 : 0 : x = y.clientY < b.top ? -1 : y.clientY > b.bottom ? 1 : 0, g.moveTo(g.pos + x * g.screen) }); function v(y) { const b = r.wheelEventPixels(y)[g.orientation == 'horizontal' ? 'x' : 'y']; const x = g.pos; g.moveTo(g.pos + b), g.pos != x && r.e_preventDefault(y) }r.on(this.node, 'mousewheel', v), r.on(this.node, 'DOMMouseScroll', v)
    }o.prototype.setPos = function (f, d) { return f < 0 && (f = 0), f > this.total - this.screen && (f = this.total - this.screen), !d && f == this.pos ? !1 : (this.pos = f, this.inner.style[this.orientation == 'horizontal' ? 'left' : 'top'] = `${f * (this.size / this.total)}px`, !0) }, o.prototype.moveTo = function (f) { this.setPos(f) && this.scroll(f, this.orientation) }; const s = 10; o.prototype.update = function (f, d, h) { const g = this.screen != d || this.total != f || this.size != h; g && (this.screen = d, this.total = f, this.size = h); let v = this.screen * (this.size / this.total); v < s && (this.size -= s - v, v = s), this.inner.style[this.orientation == 'horizontal' ? 'width' : 'height'] = `${v}px`, this.setPos(this.pos, g) }; function c(f, d, h) { this.addClass = f, this.horiz = new o(f, 'horizontal', h), d(this.horiz.node), this.vert = new o(f, 'vertical', h), d(this.vert.node), this.width = null }c.prototype.update = function (f) { if (this.width == null) { const d = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle; d && (this.width = Number.parseInt(d.height)) } const h = this.width || 0; const g = f.scrollWidth > f.clientWidth + 1; const v = f.scrollHeight > f.clientHeight + 1; return this.vert.node.style.display = v ? 'block' : 'none', this.horiz.node.style.display = g ? 'block' : 'none', v && (this.vert.update(f.scrollHeight, f.clientHeight, f.viewHeight - (g ? h : 0)), this.vert.node.style.bottom = g ? `${h}px` : '0'), g && (this.horiz.update(f.scrollWidth, f.clientWidth, f.viewWidth - (v ? h : 0) - f.barLeft), this.horiz.node.style.right = v ? `${h}px` : '0', this.horiz.node.style.left = `${f.barLeft}px`), { right: v ? h : 0, bottom: g ? h : 0 } }, c.prototype.setScrollTop = function (f) { this.vert.setPos(f) }, c.prototype.setScrollLeft = function (f) { this.horiz.setPos(f) }, c.prototype.clear = function () { const f = this.horiz.node.parentNode; f.removeChild(this.horiz.node), f.removeChild(this.vert.node) }, r.scrollbarModel.simple = function (f, d) { return new c('CodeMirror-simplescroll', f, d) }, r.scrollbarModel.overlay = function (f, d) { return new c('CodeMirror-overlayscroll', f, d) }
  })
})(); const Zn = Fr(); function mfe(e, t, r = {}) { const o = dfe.fromTextArea(e.value, { theme: 'vars', ...r, scrollbarStyle: 'simple' }); let s = !1; return o.on('change', () => { if (s) { s = !1; return }t.value = o.getValue() }), Ht(t, (c) => { if (c !== o.getValue()) { s = !0; const f = o.listSelections(); o.replaceRange(c, o.posFromIndex(0), o.posFromIndex(Number.POSITIVE_INFINITY)), o.setSelections(f) } }, { immediate: !0 }), bu(() => { Zn.value = void 0 }), vh(o) } async function yfe(e) { let t; Gw(e, ((t = e.location) == null ? void 0 : t.line) ?? 0) } const bfe = { 'relative': '', 'font-mono': '', 'text-sm': '', 'class': 'codemirror-scrolls' }; const Zw = ft({ __name: 'CodeMirrorContainer', props: Ic({ mode: {}, readOnly: { type: Boolean } }, { modelValue: {}, modelModifiers: {} }), emits: Ic(['save'], ['update:modelValue']), setup(e, { emit: t }) { const r = t; const o = Th(e, 'modelValue'); const s = JS(); const c = { js: 'javascript', mjs: 'javascript', cjs: 'javascript', ts: { name: 'javascript', typescript: !0 }, mts: { name: 'javascript', typescript: !0 }, cts: { name: 'javascript', typescript: !0 }, jsx: { name: 'javascript', jsx: !0 }, tsx: { name: 'javascript', typescript: !0, jsx: !0 } }; const f = Be(); return Os(async () => { const d = mfe(f, o, { ...s, mode: c[e.mode || ''] || e.mode, readOnly: e.readOnly ? !0 : void 0, extraKeys: { 'Cmd-S': function (h) { r('save', h.getValue()) }, 'Ctrl-S': function (h) { r('save', h.getValue()) } } }); d.setSize('100%', '100%'), d.clearHistory(), Zn.value = d, setTimeout(() => Zn.value.refresh(), 100) }), (d, h) => (oe(), me('div', bfe, [Y('textarea', { ref_key: 'el', ref: f }, null, 512)])) } }); const wfe = ft({ __name: 'ViewEditor', props: { file: {} }, emits: ['draft'], setup(e, { emit: t }) {
  const r = e; const o = t; const s = Be(''); const c = Fr(void 0); const f = Be(!1); const d = Be(!0); Ht(() => r.file, async () => {
    let A; d.value = !0; try { if (!r.file || !((A = r.file) != null && A.filepath)) { s.value = '', c.value = s.value, f.value = !1; return }s.value = await yt.rpc.readTestFile(r.file.filepath) || '', c.value = s.value, f.value = !1 }
    finally { ln(() => d.value = !1) }
  }, { immediate: !0 }), Ht(() => [d.value, r.file, Rd.value], ([A, H, z]) => { A || (z != null ? ln(() => { let re; const J = { line: z ?? 0, ch: 0 }; (re = Zn.value) == null || re.scrollIntoView(J, 100), ln(() => { let te, j; (te = Zn.value) == null || te.focus(), (j = Zn.value) == null || j.setCursor(J) }) }) : ln(() => { let J; (J = Zn.value) == null || J.focus() })) }, { flush: 'post' }); const h = Me(() => { let A, H; return ((H = (A = r.file) == null ? void 0 : A.filepath) == null ? void 0 : H.split(/\./g).pop()) || 'js' }); const g = Be(); const v = Me(() => { let A; return (A = g.value) == null ? void 0 : A.cm }); const y = Me(() => { let A; return ((A = r.file) == null ? void 0 : A.tasks.filter((H) => { let z; return ((z = H.result) == null ? void 0 : z.state) === 'fail' })) || [] }); const b = []; const x = []; const T = []; const E = Be(!1); function M() { T.forEach(([A, H, z]) => { A.removeEventListener('click', H), z() }), T.length = 0 }Lw(g, () => { let A; (A = Zn.value) == null || A.refresh() }); function N() { f.value = c.value !== Zn.value.getValue() }Ht(f, (A) => { o('draft', A) }, { immediate: !0 }); function L(A) {
    const H = ((A == null ? void 0 : A.stacks) || []).filter((ne) => { let K; return ne.file && ne.file === ((K = r.file) == null ? void 0 : K.filepath) }); const z = H == null ? void 0 : H[0]; if (!z)
      return; const J = document.createElement('div'); J.className = 'op80 flex gap-x-2 items-center'; const re = document.createElement('pre'); re.className = 'c-red-600 dark:c-red-400', re.textContent = `${' '.repeat(z.column)}^ ${(A == null ? void 0 : A.nameStr) || A.name}: ${(A == null ? void 0 : A.message) || ''}`, J.appendChild(re); const te = document.createElement('span'); te.className = 'i-carbon-launch c-red-600 dark:c-red-400 hover:cursor-pointer min-w-1em min-h-1em', te.tabIndex = 0, te.ariaLabel = 'Open in Editor', Mb(te, { content: 'Open in Editor', placement: 'bottom' }, !1); const j = async () => { await pw(z.file, z.line, z.column) }; J.appendChild(te), T.push([te, j, () => Dh(te)]), x.push(Zn.value.addLineClass(z.line - 1, 'wrap', 'bg-red-500/10')), b.push(Zn.value.addLineWidget(z.line - 1, J))
  }Ht([v, y], ([A]) => { if (!A) { M(); return }setTimeout(() => { M(), b.forEach(H => H.clear()), x.forEach((H) => { let z; return (z = Zn.value) == null ? void 0 : z.removeLineClass(H, 'wrap') }), b.length = 0, x.length = 0, A.on('changes', N), y.value.forEach((H) => { let z, J; (J = (z = H.result) == null ? void 0 : z.errors) == null || J.forEach(L) }), E.value || A.clearHistory() }, 100) }, { flush: 'post' }); async function O(A) { E.value = !0, await yt.rpc.saveTestFile(r.file.filepath, A), c.value = A, f.value = !1 } return (A, H) => { const z = Zw; return oe(), ot(z, ii({ 'ref_key': 'editor', 'ref': g, 'modelValue': q(s), 'onUpdate:modelValue': H[0] || (H[0] = J => Ot(s) ? s.value = J : null), 'h-full': '' }, { lineNumbers: !0, readOnly: q(Pr) }, { 'mode': q(h), 'data-testid': 'code-mirror', 'onSave': O }), null, 16, ['modelValue', 'mode']) }
} }); const xfe = { 'w-350': '', 'max-w-screen': '', 'h-full': '', 'flex': '', 'flex-col': '' }; const _fe = { 'p-4': '', 'relative': '' }; const Sfe = Y('p', null, 'Module Info', -1); const kfe = { 'op50': '', 'font-mono': '', 'text-sm': '' }; const Cfe = { 'key': 0, 'p-5': '' }; const Tfe = { 'grid': '~ cols-2 rows-[min-content_auto]', 'overflow-hidden': '', 'flex-auto': '' }; const Efe = Y('div', { 'p': 'x3 y-1', 'bg-overlay': '', 'border': 'base b t r' }, ' Source ', -1); const Lfe = Y('div', { 'p': 'x3 y-1', 'bg-overlay': '', 'border': 'base b t' }, ' Transformed ', -1); const Afe = { key: 0 }; const Mfe = { 'p': 'x3 y-1', 'bg-overlay': '', 'border': 'base b t' }; const Nfe = ft({ __name: 'ModuleTransformResultView', props: { id: {}, projectName: {} }, emits: ['close'], setup(e, { emit: t }) { const r = e; const o = t; const s = ace(() => yt.rpc.getTransformResult(r.projectName, r.id, !!No)); const c = Me(() => { let g; return ((g = r.id) == null ? void 0 : g.split(/\./g).pop()) || 'js' }); const f = Me(() => { let g, v; return ((v = (g = s.value) == null ? void 0 : g.source) == null ? void 0 : v.trim()) || '' }); const d = Me(() => { let g, v; return ((v = (g = s.value) == null ? void 0 : g.code) == null ? void 0 : v.replace(/\/\/# sourceMappingURL=.*\n/, '').trim()) || '' }); const h = Me(() => { let g, v, y, b; return { mappings: ((v = (g = s.value) == null ? void 0 : g.map) == null ? void 0 : v.mappings) ?? '', version: (b = (y = s.value) == null ? void 0 : y.map) == null ? void 0 : b.version } }); return _w('Escape', () => { o('close') }), (g, v) => { const y = hi; const b = Zw; return oe(), me('div', xfe, [Y('div', _fe, [Sfe, Y('p', kfe, qe(g.id), 1), Oe(y, { 'icon': 'i-carbon-close', 'absolute': '', 'top-5px': '', 'right-5px': '', 'text-2xl': '', 'onClick': v[0] || (v[0] = x => o('close')) })]), q(s) ? (oe(), me(ut, { key: 1 }, [Y('div', Tfe, [Efe, Lfe, Oe(b, ii({ 'h-full': '', 'model-value': q(f), 'read-only': '' }, { lineNumbers: !0 }, { mode: q(c) }), null, 16, ['model-value', 'mode']), Oe(b, ii({ 'h-full': '', 'model-value': q(d), 'read-only': '' }, { lineNumbers: !0 }, { mode: q(c) }), null, 16, ['model-value', 'mode'])]), q(h).mappings !== '' ? (oe(), me('div', Afe, [Y('div', Mfe, ` Source map (v${qe(q(h).version)}) `, 1), Oe(b, ii({ 'model-value': q(h).mappings, 'read-only': '' }, { lineNumbers: !0 }, { mode: q(c) }), null, 16, ['model-value', 'mode'])])) : et('', !0)], 64)) : (oe(), me('div', Cfe, ' No transform result found for this module. '))]) } } }); function $fe(e, t) { let r; return (...o) => { r !== void 0 && clearTimeout(r), r = setTimeout(() => e(...o), t) } } const Ud = 'http://www.w3.org/1999/xhtml'; const l0 = { svg: 'http://www.w3.org/2000/svg', xhtml: Ud, xlink: 'http://www.w3.org/1999/xlink', xml: 'http://www.w3.org/XML/1998/namespace', xmlns: 'http://www.w3.org/2000/xmlns/' }; function Iu(e) { let t = e += ''; const r = t.indexOf(':'); return r >= 0 && (t = e.slice(0, r)) !== 'xmlns' && (e = e.slice(r + 1)), l0.hasOwnProperty(t) ? { space: l0[t], local: e } : e } function Ofe(e) { return function () { const t = this.ownerDocument; const r = this.namespaceURI; return r === Ud && t.documentElement.namespaceURI === Ud ? t.createElement(e) : t.createElementNS(r, e) } } function Pfe(e) { return function () { return this.ownerDocument.createElementNS(e.space, e.local) } } function Jw(e) { const t = Iu(e); return (t.local ? Pfe : Ofe)(t) } function Rfe() {} function Yh(e) { return e == null ? Rfe : function () { return this.querySelector(e) } } function Dfe(e) {
  typeof e != 'function' && (e = Yh(e)); for (var t = this._groups, r = t.length, o = new Array(r), s = 0; s < r; ++s) {
    for (var c = t[s], f = c.length, d = o[s] = new Array(f), h, g, v = 0; v < f; ++v)(h = c[v]) && (g = e.call(h, h.__data__, v, c)) && ('__data__' in h && (g.__data__ = h.__data__), d[v] = g)
  } return new Gn(o, this._parents)
} function zfe(e) { return e == null ? [] : Array.isArray(e) ? e : Array.from(e) } function Ife() { return [] } function Qw(e) { return e == null ? Ife : function () { return this.querySelectorAll(e) } } function Ffe(e) { return function () { return zfe(e.apply(this, arguments)) } } function Hfe(e) {
  typeof e == 'function' ? e = Ffe(e) : e = Qw(e); for (var t = this._groups, r = t.length, o = [], s = [], c = 0; c < r; ++c) {
    for (var f = t[c], d = f.length, h, g = 0; g < d; ++g)(h = f[g]) && (o.push(e.call(h, h.__data__, g, f)), s.push(h))
  } return new Gn(o, s)
} function e1(e) { return function () { return this.matches(e) } } function t1(e) { return function (t) { return t.matches(e) } } const qfe = Array.prototype.find; function Bfe(e) { return function () { return qfe.call(this.children, e) } } function Wfe() { return this.firstElementChild } function Ufe(e) { return this.select(e == null ? Wfe : Bfe(typeof e == 'function' ? e : t1(e))) } const Vfe = Array.prototype.filter; function jfe() { return Array.from(this.children) } function Gfe(e) { return function () { return Vfe.call(this.children, e) } } function Kfe(e) { return this.selectAll(e == null ? jfe : Gfe(typeof e == 'function' ? e : t1(e))) } function Xfe(e) {
  typeof e != 'function' && (e = e1(e)); for (var t = this._groups, r = t.length, o = new Array(r), s = 0; s < r; ++s) {
    for (var c = t[s], f = c.length, d = o[s] = [], h, g = 0; g < f; ++g)(h = c[g]) && e.call(h, h.__data__, g, c) && d.push(h)
  } return new Gn(o, this._parents)
} function n1(e) { return Array.from({ length: e.length }) } function Yfe() { return new Gn(this._enter || this._groups.map(n1), this._parents) } function ru(e, t) { this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t }ru.prototype = { constructor: ru, appendChild(e) { return this._parent.insertBefore(e, this._next) }, insertBefore(e, t) { return this._parent.insertBefore(e, t) }, querySelector(e) { return this._parent.querySelector(e) }, querySelectorAll(e) { return this._parent.querySelectorAll(e) } }; function Zfe(e) { return function () { return e } } function Jfe(e, t, r, o, s, c) { for (var f = 0, d, h = t.length, g = c.length; f < g; ++f)(d = t[f]) ? (d.__data__ = c[f], o[f] = d) : r[f] = new ru(e, c[f]); for (;f < h; ++f)(d = t[f]) && (s[f] = d) } function Qfe(e, t, r, o, s, c, f) { let d; let h; const g = new Map(); const v = t.length; const y = c.length; const b = new Array(v); let x; for (d = 0; d < v; ++d)(h = t[d]) && (b[d] = x = `${f.call(h, h.__data__, d, t)}`, g.has(x) ? s[d] = h : g.set(x, h)); for (d = 0; d < y; ++d)x = `${f.call(e, c[d], d, c)}`, (h = g.get(x)) ? (o[d] = h, h.__data__ = c[d], g.delete(x)) : r[d] = new ru(e, c[d]); for (d = 0; d < v; ++d)(h = t[d]) && g.get(b[d]) === h && (s[d] = h) } function ede(e) { return e.__data__ } function tde(e, t) {
  if (!arguments.length)
    return Array.from(this, ede); const r = t ? Qfe : Jfe; const o = this._parents; const s = this._groups; typeof e != 'function' && (e = Zfe(e)); for (var c = s.length, f = new Array(c), d = new Array(c), h = new Array(c), g = 0; g < c; ++g) {
    const v = o[g]; const y = s[g]; const b = y.length; const x = nde(e.call(v, v && v.__data__, g, o)); const T = x.length; const E = d[g] = new Array(T); const M = f[g] = new Array(T); const N = h[g] = new Array(b); r(v, y, E, M, N, x, t); for (var L = 0, O = 0, A, H; L < T; ++L) {
      if (A = E[L]) { for (L >= O && (O = L + 1); !(H = M[O]) && ++O < T;);A._next = H || null }
    }
  } return f = new Gn(f, o), f._enter = d, f._exit = h, f
} function nde(e) { return typeof e == 'object' && 'length' in e ? e : Array.from(e) } function rde() { return new Gn(this._exit || this._groups.map(n1), this._parents) } function ide(e, t, r) { let o = this.enter(); let s = this; const c = this.exit(); return typeof e == 'function' ? (o = e(o), o && (o = o.selection())) : o = o.append(`${e}`), t != null && (s = t(s), s && (s = s.selection())), r == null ? c.remove() : r(c), o && s ? o.merge(s).order() : s } function ode(e) {
  for (var t = e.selection ? e.selection() : e, r = this._groups, o = t._groups, s = r.length, c = o.length, f = Math.min(s, c), d = new Array(s), h = 0; h < f; ++h) {
    for (var g = r[h], v = o[h], y = g.length, b = d[h] = new Array(y), x, T = 0; T < y; ++T)(x = g[T] || v[T]) && (b[T] = x)
  } for (;h < s; ++h)d[h] = r[h]; return new Gn(d, this._parents)
} function sde() {
  for (let e = this._groups, t = -1, r = e.length; ++t < r;) {
    for (var o = e[t], s = o.length - 1, c = o[s], f; --s >= 0;)(f = o[s]) && (c && f.compareDocumentPosition(c) ^ 4 && c.parentNode.insertBefore(f, c), c = f)
  } return this
} function lde(e) { e || (e = ade); function t(y, b) { return y && b ? e(y.__data__, b.__data__) : !y - !b } for (var r = this._groups, o = r.length, s = new Array(o), c = 0; c < o; ++c) { for (var f = r[c], d = f.length, h = s[c] = new Array(d), g, v = 0; v < d; ++v)(g = f[v]) && (h[v] = g); h.sort(t) } return new Gn(s, this._parents).order() } function ade(e, t) { return e < t ? -1 : e > t ? 1 : e >= t ? 0 : Number.NaN } function cde() { const e = arguments[0]; return arguments[0] = this, e.apply(null, arguments), this } function ude() { return Array.from(this) } function fde() {
  for (let e = this._groups, t = 0, r = e.length; t < r; ++t) {
    for (let o = e[t], s = 0, c = o.length; s < c; ++s) {
      const f = o[s]; if (f)
        return f
    }
  } return null
} function dde() { let e = 0; for (const t of this)++e; return e } function hde() { return !this.node() } function pde(e) {
  for (let t = this._groups, r = 0, o = t.length; r < o; ++r) {
    for (var s = t[r], c = 0, f = s.length, d; c < f; ++c)(d = s[c]) && e.call(d, d.__data__, c, s)
  } return this
} function gde(e) { return function () { this.removeAttribute(e) } } function vde(e) { return function () { this.removeAttributeNS(e.space, e.local) } } function mde(e, t) { return function () { this.setAttribute(e, t) } } function yde(e, t) { return function () { this.setAttributeNS(e.space, e.local, t) } } function bde(e, t) { return function () { const r = t.apply(this, arguments); r == null ? this.removeAttribute(e) : this.setAttribute(e, r) } } function wde(e, t) { return function () { const r = t.apply(this, arguments); r == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, r) } } function xde(e, t) { const r = Iu(e); if (arguments.length < 2) { const o = this.node(); return r.local ? o.getAttributeNS(r.space, r.local) : o.getAttribute(r) } return this.each((t == null ? r.local ? vde : gde : typeof t == 'function' ? r.local ? wde : bde : r.local ? yde : mde)(r, t)) } function r1(e) { return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView } function _de(e) { return function () { this.style.removeProperty(e) } } function Sde(e, t, r) { return function () { this.style.setProperty(e, t, r) } } function kde(e, t, r) { return function () { const o = t.apply(this, arguments); o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, r) } } function Cde(e, t, r) { return arguments.length > 1 ? this.each((t == null ? _de : typeof t == 'function' ? kde : Sde)(e, t, r ?? '')) : Ns(this.node(), e) } function Ns(e, t) { return e.style.getPropertyValue(t) || r1(e).getComputedStyle(e, null).getPropertyValue(t) } function Tde(e) { return function () { delete this[e] } } function Ede(e, t) { return function () { this[e] = t } } function Lde(e, t) { return function () { const r = t.apply(this, arguments); r == null ? delete this[e] : this[e] = r } } function Ade(e, t) { return arguments.length > 1 ? this.each((t == null ? Tde : typeof t == 'function' ? Lde : Ede)(e, t)) : this.node()[e] } function i1(e) { return e.trim().split(/^|\s+/) } function Zh(e) { return e.classList || new o1(e) } function o1(e) { this._node = e, this._names = i1(e.getAttribute('class') || '') }o1.prototype = { add(e) { const t = this._names.indexOf(e); t < 0 && (this._names.push(e), this._node.setAttribute('class', this._names.join(' '))) }, remove(e) { const t = this._names.indexOf(e); t >= 0 && (this._names.splice(t, 1), this._node.setAttribute('class', this._names.join(' '))) }, contains(e) { return this._names.includes(e) } }; function s1(e, t) { for (let r = Zh(e), o = -1, s = t.length; ++o < s;)r.add(t[o]) } function l1(e, t) { for (let r = Zh(e), o = -1, s = t.length; ++o < s;)r.remove(t[o]) } function Mde(e) { return function () { s1(this, e) } } function Nde(e) { return function () { l1(this, e) } } function $de(e, t) { return function () { (t.apply(this, arguments) ? s1 : l1)(this, e) } } function Ode(e, t) {
  const r = i1(`${e}`); if (arguments.length < 2) {
    for (let o = Zh(this.node()), s = -1, c = r.length; ++s < c;) {
      if (!o.contains(r[s]))
        return !1
    } return !0
  } return this.each((typeof t == 'function' ? $de : t ? Mde : Nde)(r, t))
} function Pde() { this.textContent = '' } function Rde(e) { return function () { this.textContent = e } } function Dde(e) { return function () { const t = e.apply(this, arguments); this.textContent = t ?? '' } } function zde(e) { return arguments.length ? this.each(e == null ? Pde : (typeof e == 'function' ? Dde : Rde)(e)) : this.node().textContent } function Ide() { this.innerHTML = '' } function Fde(e) { return function () { this.innerHTML = e } } function Hde(e) { return function () { const t = e.apply(this, arguments); this.innerHTML = t ?? '' } } function qde(e) { return arguments.length ? this.each(e == null ? Ide : (typeof e == 'function' ? Hde : Fde)(e)) : this.node().innerHTML } function Bde() { this.nextSibling && this.parentNode.appendChild(this) } function Wde() { return this.each(Bde) } function Ude() { this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild) } function Vde() { return this.each(Ude) } function jde(e) { const t = typeof e == 'function' ? e : Jw(e); return this.select(function () { return this.appendChild(t.apply(this, arguments)) }) } function Gde() { return null } function Kde(e, t) { const r = typeof e == 'function' ? e : Jw(e); const o = t == null ? Gde : typeof t == 'function' ? t : Yh(t); return this.select(function () { return this.insertBefore(r.apply(this, arguments), o.apply(this, arguments) || null) }) } function Xde() { const e = this.parentNode; e && e.removeChild(this) } function Yde() { return this.each(Xde) } function Zde() { const e = this.cloneNode(!1); const t = this.parentNode; return t ? t.insertBefore(e, this.nextSibling) : e } function Jde() { const e = this.cloneNode(!0); const t = this.parentNode; return t ? t.insertBefore(e, this.nextSibling) : e } function Qde(e) { return this.select(e ? Jde : Zde) } function ehe(e) { return arguments.length ? this.property('__data__', e) : this.node().__data__ } function the(e) { return function (t) { e.call(this, t, this.__data__) } } function nhe(e) { return e.trim().split(/^|\s+/).map((t) => { let r = ''; const o = t.indexOf('.'); return o >= 0 && (r = t.slice(o + 1), t = t.slice(0, o)), { type: t, name: r } }) } function rhe(e) { return function () { const t = this.__on; if (t) { for (var r = 0, o = -1, s = t.length, c; r < s; ++r)c = t[r], (!e.type || c.type === e.type) && c.name === e.name ? this.removeEventListener(c.type, c.listener, c.options) : t[++o] = c; ++o ? t.length = o : delete this.__on } } } function ihe(e, t, r) {
  return function () {
    const o = this.__on; let s; const c = the(t); if (o) {
      for (let f = 0, d = o.length; f < d; ++f) {
        if ((s = o[f]).type === e.type && s.name === e.name) { this.removeEventListener(s.type, s.listener, s.options), this.addEventListener(s.type, s.listener = c, s.options = r), s.value = t; return }
      }
    } this.addEventListener(e.type, c, r), s = { type: e.type, name: e.name, value: t, listener: c, options: r }, o ? o.push(s) : this.__on = [s]
  }
} function ohe(e, t, r) {
  const o = nhe(`${e}`); let s; const c = o.length; let f; if (arguments.length < 2) {
    var d = this.node().__on; if (d) {
      for (var h = 0, g = d.length, v; h < g; ++h) {
        for (s = 0, v = d[h]; s < c; ++s) {
          if ((f = o[s]).type === v.type && f.name === v.name)
            return v.value
        }
      }
    } return
  } for (d = t ? ihe : rhe, s = 0; s < c; ++s) this.each(d(o[s], t, r)); return this
} function a1(e, t, r) { const o = r1(e); let s = o.CustomEvent; typeof s == 'function' ? s = new s(t, r) : (s = o.document.createEvent('Event'), r ? (s.initEvent(t, r.bubbles, r.cancelable), s.detail = r.detail) : s.initEvent(t, !1, !1)), e.dispatchEvent(s) } function she(e, t) { return function () { return a1(this, e, t) } } function lhe(e, t) { return function () { return a1(this, e, t.apply(this, arguments)) } } function ahe(e, t) { return this.each((typeof t == 'function' ? lhe : she)(e, t)) } function*che() {
  for (let e = this._groups, t = 0, r = e.length; t < r; ++t) {
    for (var o = e[t], s = 0, c = o.length, f; s < c; ++s)(f = o[s]) && (yield f)
  }
} const c1 = [null]; function Gn(e, t) { this._groups = e, this._parents = t } function va() { return new Gn([[document.documentElement]], c1) } function uhe() { return this }Gn.prototype = va.prototype = { constructor: Gn, select: Dfe, selectAll: Hfe, selectChild: Ufe, selectChildren: Kfe, filter: Xfe, data: tde, enter: Yfe, exit: rde, join: ide, merge: ode, selection: uhe, order: sde, sort: lde, call: cde, nodes: ude, node: fde, size: dde, empty: hde, each: pde, attr: xde, style: Cde, property: Ade, classed: Ode, text: zde, html: qde, raise: Wde, lower: Vde, append: jde, insert: Kde, remove: Yde, clone: Qde, datum: ehe, on: ohe, dispatch: ahe, [Symbol.iterator]: che }; function Pn(e) { return typeof e == 'string' ? new Gn([[document.querySelector(e)]], [document.documentElement]) : new Gn([[e]], c1) } function fhe(e) { let t; for (;t = e.sourceEvent;)e = t; return e } function ei(e, t) { if (e = fhe(e), t === void 0 && (t = e.currentTarget), t) { const r = t.ownerSVGElement || t; if (r.createSVGPoint) { let o = r.createSVGPoint(); return o.x = e.clientX, o.y = e.clientY, o = o.matrixTransform(t.getScreenCTM().inverse()), [o.x, o.y] } if (t.getBoundingClientRect) { const s = t.getBoundingClientRect(); return [e.clientX - s.left - t.clientLeft, e.clientY - s.top - t.clientTop] } } return [e.pageX, e.pageY] } class _n {constructor(t, r) { this.x = t, this.y = r } static of([t, r]) { return new _n(t, r) }add(t) { return new _n(this.x + t.x, this.y + t.y) }subtract(t) { return new _n(this.x - t.x, this.y - t.y) }multiply(t) { return new _n(this.x * t, this.y * t) }divide(t) { return new _n(this.x / t, this.y / t) }dot(t) { return this.x * t.x + this.y * t.y }cross(t) { return this.x * t.y - t.x * this.y }hadamard(t) { return new _n(this.x * t.x, this.y * t.y) }length() { return Math.sqrt(this.x ** 2 + this.y ** 2) }normalize() { const t = this.length(); return new _n(this.x / t, this.y / t) }rotateByRadians(t) { const r = Math.cos(t); const o = Math.sin(t); return new _n(this.x * r - this.y * o, this.x * o + this.y * r) }rotateByDegrees(t) { return this.rotateByRadians(t * Math.PI / 180) }} const dhe = { value: () => {} }; function ma() {
  for (var e = 0, t = arguments.length, r = {}, o; e < t; ++e) {
    if (!(o = `${arguments[e]}`) || o in r || /[\s.]/.test(o))
      throw new Error(`illegal type: ${o}`); r[o] = []
  } return new Lc(r)
} function Lc(e) { this._ = e } function hhe(e, t) {
  return e.trim().split(/^|\s+/).map((r) => {
    let o = ''; const s = r.indexOf('.'); if (s >= 0 && (o = r.slice(s + 1), r = r.slice(0, s)), r && !t.hasOwnProperty(r))
      throw new Error(`unknown type: ${r}`); return { type: r, name: o }
  })
}Lc.prototype = ma.prototype = { constructor: Lc, on(e, t) {
  const r = this._; const o = hhe(`${e}`, r); let s; let c = -1; const f = o.length; if (arguments.length < 2) {
    for (;++c < f;) {
      if ((s = (e = o[c]).type) && (s = phe(r[s], e.name)))
        return s
    } return
  } if (t != null && typeof t != 'function')
    throw new Error(`invalid callback: ${t}`); for (;++c < f;) {
    if (s = (e = o[c]).type) {
      r[s] = a0(r[s], e.name, t)
    }
    else if (t == null) {
      for (s in r)r[s] = a0(r[s], e.name, null)
    }
  } return this
}, copy() { const e = {}; const t = this._; for (const r in t)e[r] = t[r].slice(); return new Lc(e) }, call(e, t) {
  if ((s = arguments.length - 2) > 0) {
    for (var r = new Array(s), o = 0, s, c; o < s; ++o)r[o] = arguments[o + 2]
  } if (!this._.hasOwnProperty(e))
    throw new Error(`unknown type: ${e}`); for (c = this._[e], o = 0, s = c.length; o < s; ++o)c[o].value.apply(t, r)
}, apply(e, t, r) {
  if (!this._.hasOwnProperty(e))
    throw new Error(`unknown type: ${e}`); for (let o = this._[e], s = 0, c = o.length; s < c; ++s)o[s].value.apply(t, r)
} }; function phe(e, t) {
  for (var r = 0, o = e.length, s; r < o; ++r) {
    if ((s = e[r]).name === t)
      return s.value
  }
} function a0(e, t, r) {
  for (let o = 0, s = e.length; o < s; ++o) {
    if (e[o].name === t) { e[o] = dhe, e = e.slice(0, o).concat(e.slice(o + 1)); break }
  } return r != null && e.push({ name: t, value: r }), e
} const ghe = { passive: !1 }; const Ql = { capture: !0, passive: !1 }; function id(e) { e.stopImmediatePropagation() } function bs(e) { e.preventDefault(), e.stopImmediatePropagation() } function u1(e) { const t = e.document.documentElement; const r = Pn(e).on('dragstart.drag', bs, Ql); 'onselectstart' in t ? r.on('selectstart.drag', bs, Ql) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = 'none') } function f1(e, t) { const r = e.document.documentElement; const o = Pn(e).on('dragstart.drag', null); t && (o.on('click.drag', bs, Ql), setTimeout(() => { o.on('click.drag', null) }, 0)), 'onselectstart' in r ? o.on('selectstart.drag', null) : (r.style.MozUserSelect = r.__noselect, delete r.__noselect) } const fc = e => () => e; function Vd(e, { sourceEvent: t, subject: r, target: o, identifier: s, active: c, x: f, y: d, dx: h, dy: g, dispatch: v }) { Object.defineProperties(this, { type: { value: e, enumerable: !0, configurable: !0 }, sourceEvent: { value: t, enumerable: !0, configurable: !0 }, subject: { value: r, enumerable: !0, configurable: !0 }, target: { value: o, enumerable: !0, configurable: !0 }, identifier: { value: s, enumerable: !0, configurable: !0 }, active: { value: c, enumerable: !0, configurable: !0 }, x: { value: f, enumerable: !0, configurable: !0 }, y: { value: d, enumerable: !0, configurable: !0 }, dx: { value: h, enumerable: !0, configurable: !0 }, dy: { value: g, enumerable: !0, configurable: !0 }, _: { value: v } }) }Vd.prototype.on = function () { const e = this._.on.apply(this._, arguments); return e === this._ ? this : e }; function vhe(e) { return !e.ctrlKey && !e.button } function mhe() { return this.parentNode } function yhe(e, t) { return t ?? { x: e.x, y: e.y } } function bhe() { return navigator.maxTouchPoints || 'ontouchstart' in this } function whe() {
  let e = vhe; let t = mhe; let r = yhe; let o = bhe; const s = {}; const c = ma('start', 'drag', 'end'); let f = 0; let d; let h; let g; let v; let y = 0; function b(A) { A.on('mousedown.drag', x).filter(o).on('touchstart.drag', M).on('touchmove.drag', N, ghe).on('touchend.drag touchcancel.drag', L).style('touch-action', 'none').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)') } function x(A, H) { if (!(v || !e.call(this, A, H))) { const z = O(this, t.call(this, A, H), A, H, 'mouse'); z && (Pn(A.view).on('mousemove.drag', T, Ql).on('mouseup.drag', E, Ql), u1(A.view), id(A), g = !1, d = A.clientX, h = A.clientY, z('start', A)) } } function T(A) { if (bs(A), !g) { const H = A.clientX - d; const z = A.clientY - h; g = H * H + z * z > y }s.mouse('drag', A) } function E(A) { Pn(A.view).on('mousemove.drag mouseup.drag', null), f1(A.view, g), bs(A), s.mouse('end', A) } function M(A, H) { if (e.call(this, A, H)) { const z = A.changedTouches; const J = t.call(this, A, H); const re = z.length; let te; let j; for (te = 0; te < re; ++te)(j = O(this, J, A, H, z[te].identifier, z[te])) && (id(A), j('start', A, z[te])) } } function N(A) { const H = A.changedTouches; const z = H.length; let J; let re; for (J = 0; J < z; ++J)(re = s[H[J].identifier]) && (bs(A), re('drag', A, H[J])) } function L(A) { const H = A.changedTouches; const z = H.length; let J; let re; for (v && clearTimeout(v), v = setTimeout(() => { v = null }, 500), J = 0; J < z; ++J)(re = s[H[J].identifier]) && (id(A), re('end', A, H[J])) } function O(A, H, z, J, re, te) {
    const j = c.copy(); let ne = ei(te || z, H); let K; let V; let I; if ((I = r.call(A, new Vd('beforestart', { sourceEvent: z, target: b, identifier: re, active: f, x: ne[0], y: ne[1], dx: 0, dy: 0, dispatch: j }), J)) != null)
      return K = I.x - ne[0] || 0, V = I.y - ne[1] || 0, function k(B, W, ie) { const ye = ne; let Ne; switch (B) { case 'start':s[re] = k, Ne = f++; break; case 'end':delete s[re], --f; case 'drag':ne = ei(ie || W, H), Ne = f; break }j.call(B, A, new Vd(B, { sourceEvent: W, subject: I, target: b, identifier: re, active: Ne, x: ne[0] + K, y: ne[1] + V, dx: ne[0] - ye[0], dy: ne[1] - ye[1], dispatch: j }), J) }
  } return b.filter = function (A) { return arguments.length ? (e = typeof A == 'function' ? A : fc(!!A), b) : e }, b.container = function (A) { return arguments.length ? (t = typeof A == 'function' ? A : fc(A), b) : t }, b.subject = function (A) { return arguments.length ? (r = typeof A == 'function' ? A : fc(A), b) : r }, b.touchable = function (A) { return arguments.length ? (o = typeof A == 'function' ? A : fc(!!A), b) : o }, b.on = function () { const A = c.on.apply(c, arguments); return A === c ? b : A }, b.clickDistance = function (A) { return arguments.length ? (y = (A = +A) * A, b) : Math.sqrt(y) }, b
} function Jh(e, t, r) { e.prototype = t.prototype = r, r.constructor = e } function d1(e, t) { const r = Object.create(e.prototype); for (const o in t)r[o] = t[o]; return r } function ya() {} const ea = 0.7; const iu = 1 / ea; const ws = '\\s*([+-]?\\d+)\\s*'; const ta = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*'; const Rr = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*'; const xhe = /^#([0-9a-f]{3,8})$/; const _he = new RegExp(`^rgb\\(${ws},${ws},${ws}\\)$`); const She = new RegExp(`^rgb\\(${Rr},${Rr},${Rr}\\)$`); const khe = new RegExp(`^rgba\\(${ws},${ws},${ws},${ta}\\)$`); const Che = new RegExp(`^rgba\\(${Rr},${Rr},${Rr},${ta}\\)$`); const The = new RegExp(`^hsl\\(${ta},${Rr},${Rr}\\)$`); const Ehe = new RegExp(`^hsla\\(${ta},${Rr},${Rr},${ta}\\)$`); const c0 = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; Jh(ya, na, { copy(e) { return Object.assign(new this.constructor(), this, e) }, displayable() { return this.rgb().displayable() }, hex: u0, formatHex: u0, formatHex8: Lhe, formatHsl: Ahe, formatRgb: f0, toString: f0 }); function u0() { return this.rgb().formatHex() } function Lhe() { return this.rgb().formatHex8() } function Ahe() { return h1(this).formatHsl() } function f0() { return this.rgb().formatRgb() } function na(e) { let t, r; return e = (`${e}`).trim().toLowerCase(), (t = xhe.exec(e)) ? (r = t[1].length, t = Number.parseInt(t[1], 16), r === 6 ? d0(t) : r === 3 ? new Dn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : r === 8 ? dc(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : r === 4 ? dc(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = _he.exec(e)) ? new Dn(t[1], t[2], t[3], 1) : (t = She.exec(e)) ? new Dn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = khe.exec(e)) ? dc(t[1], t[2], t[3], t[4]) : (t = Che.exec(e)) ? dc(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = The.exec(e)) ? g0(t[1], t[2] / 100, t[3] / 100, 1) : (t = Ehe.exec(e)) ? g0(t[1], t[2] / 100, t[3] / 100, t[4]) : c0.hasOwnProperty(e) ? d0(c0[e]) : e === 'transparent' ? new Dn(Number.NaN, Number.NaN, Number.NaN, 0) : null } function d0(e) { return new Dn(e >> 16 & 255, e >> 8 & 255, e & 255, 1) } function dc(e, t, r, o) { return o <= 0 && (e = t = r = Number.NaN), new Dn(e, t, r, o) } function Mhe(e) { return e instanceof ya || (e = na(e)), e ? (e = e.rgb(), new Dn(e.r, e.g, e.b, e.opacity)) : new Dn() } function jd(e, t, r, o) { return arguments.length === 1 ? Mhe(e) : new Dn(e, t, r, o ?? 1) } function Dn(e, t, r, o) { this.r = +e, this.g = +t, this.b = +r, this.opacity = +o }Jh(Dn, jd, d1(ya, { brighter(e) { return e = e == null ? iu : iu ** e, new Dn(this.r * e, this.g * e, this.b * e, this.opacity) }, darker(e) { return e = e == null ? ea : ea ** e, new Dn(this.r * e, this.g * e, this.b * e, this.opacity) }, rgb() { return this }, clamp() { return new Dn(Eo(this.r), Eo(this.g), Eo(this.b), ou(this.opacity)) }, displayable() { return this.r >= -0.5 && this.r < 255.5 && this.g >= -0.5 && this.g < 255.5 && this.b >= -0.5 && this.b < 255.5 && this.opacity >= 0 && this.opacity <= 1 }, hex: h0, formatHex: h0, formatHex8: Nhe, formatRgb: p0, toString: p0 })); function h0() { return `#${ko(this.r)}${ko(this.g)}${ko(this.b)}` } function Nhe() { return `#${ko(this.r)}${ko(this.g)}${ko(this.b)}${ko((isNaN(this.opacity) ? 1 : this.opacity) * 255)}` } function p0() { const e = ou(this.opacity); return `${e === 1 ? 'rgb(' : 'rgba('}${Eo(this.r)}, ${Eo(this.g)}, ${Eo(this.b)}${e === 1 ? ')' : `, ${e})`}` } function ou(e) { return isNaN(e) ? 1 : Math.max(0, Math.min(1, e)) } function Eo(e) { return Math.max(0, Math.min(255, Math.round(e) || 0)) } function ko(e) { return e = Eo(e), (e < 16 ? '0' : '') + e.toString(16) } function g0(e, t, r, o) { return o <= 0 ? e = t = r = Number.NaN : r <= 0 || r >= 1 ? e = t = Number.NaN : t <= 0 && (e = Number.NaN), new yr(e, t, r, o) } function h1(e) {
  if (e instanceof yr)
    return new yr(e.h, e.s, e.l, e.opacity); if (e instanceof ya || (e = na(e)), !e)
    return new yr(); if (e instanceof yr)
    return e; e = e.rgb(); const t = e.r / 255; const r = e.g / 255; const o = e.b / 255; const s = Math.min(t, r, o); const c = Math.max(t, r, o); let f = Number.NaN; let d = c - s; const h = (c + s) / 2; return d ? (t === c ? f = (r - o) / d + (r < o) * 6 : r === c ? f = (o - t) / d + 2 : f = (t - r) / d + 4, d /= h < 0.5 ? c + s : 2 - c - s, f *= 60) : d = h > 0 && h < 1 ? 0 : f, new yr(f, d, h, e.opacity)
} function $he(e, t, r, o) { return arguments.length === 1 ? h1(e) : new yr(e, t, r, o ?? 1) } function yr(e, t, r, o) { this.h = +e, this.s = +t, this.l = +r, this.opacity = +o }Jh(yr, $he, d1(ya, { brighter(e) { return e = e == null ? iu : iu ** e, new yr(this.h, this.s, this.l * e, this.opacity) }, darker(e) { return e = e == null ? ea : ea ** e, new yr(this.h, this.s, this.l * e, this.opacity) }, rgb() { const e = this.h % 360 + (this.h < 0) * 360; const t = isNaN(e) || isNaN(this.s) ? 0 : this.s; const r = this.l; const o = r + (r < 0.5 ? r : 1 - r) * t; const s = 2 * r - o; return new Dn(od(e >= 240 ? e - 240 : e + 120, s, o), od(e, s, o), od(e < 120 ? e + 240 : e - 120, s, o), this.opacity) }, clamp() { return new yr(v0(this.h), hc(this.s), hc(this.l), ou(this.opacity)) }, displayable() { return (this.s >= 0 && this.s <= 1 || isNaN(this.s)) && this.l >= 0 && this.l <= 1 && this.opacity >= 0 && this.opacity <= 1 }, formatHsl() { const e = ou(this.opacity); return `${e === 1 ? 'hsl(' : 'hsla('}${v0(this.h)}, ${hc(this.s) * 100}%, ${hc(this.l) * 100}%${e === 1 ? ')' : `, ${e})`}` } })); function v0(e) { return e = (e || 0) % 360, e < 0 ? e + 360 : e } function hc(e) { return Math.max(0, Math.min(1, e || 0)) } function od(e, t, r) { return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255 } const p1 = e => () => e; function Ohe(e, t) { return function (r) { return e + r * t } } function Phe(e, t, r) { return e = e ** r, t = t ** r - e, r = 1 / r, function (o) { return (e + o * t) ** r } } function Rhe(e) { return (e = +e) == 1 ? g1 : function (t, r) { return r - t ? Phe(t, r, e) : p1(isNaN(t) ? r : t) } } function g1(e, t) { const r = t - e; return r ? Ohe(e, r) : p1(isNaN(e) ? t : e) } const m0 = (function e(t) { const r = Rhe(t); function o(s, c) { const f = r((s = jd(s)).r, (c = jd(c)).r); const d = r(s.g, c.g); const h = r(s.b, c.b); const g = g1(s.opacity, c.opacity); return function (v) { return s.r = f(v), s.g = d(v), s.b = h(v), s.opacity = g(v), `${s}` } } return o.gamma = e, o }(1)); function Fi(e, t) { return e = +e, t = +t, function (r) { return e * (1 - r) + t * r } } const Gd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:e[-+]?\d+)?/gi; const sd = new RegExp(Gd.source, 'g'); function Dhe(e) { return function () { return e } } function zhe(e) { return function (t) { return `${e(t)}` } } function Ihe(e, t) { let r = Gd.lastIndex = sd.lastIndex = 0; let o; let s; let c; let f = -1; const d = []; const h = []; for (e = `${e}`, t = `${t}`; (o = Gd.exec(e)) && (s = sd.exec(t));)(c = s.index) > r && (c = t.slice(r, c), d[f] ? d[f] += c : d[++f] = c), (o = o[0]) === (s = s[0]) ? d[f] ? d[f] += s : d[++f] = s : (d[++f] = null, h.push({ i: f, x: Fi(o, s) })), r = sd.lastIndex; return r < t.length && (c = t.slice(r), d[f] ? d[f] += c : d[++f] = c), d.length < 2 ? h[0] ? zhe(h[0].x) : Dhe(t) : (t = h.length, function (g) { for (var v = 0, y; v < t; ++v)d[(y = h[v]).i] = y.x(g); return d.join('') }) } const y0 = 180 / Math.PI; const Kd = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }; function v1(e, t, r, o, s, c) { let f, d, h; return (f = Math.sqrt(e * e + t * t)) && (e /= f, t /= f), (h = e * r + t * o) && (r -= e * h, o -= t * h), (d = Math.sqrt(r * r + o * o)) && (r /= d, o /= d, h /= d), e * o < t * r && (e = -e, t = -t, h = -h, f = -f), { translateX: s, translateY: c, rotate: Math.atan2(t, e) * y0, skewX: Math.atan(h) * y0, scaleX: f, scaleY: d } } let pc; function Fhe(e) { const t = new (typeof DOMMatrix == 'function' ? DOMMatrix : WebKitCSSMatrix)(`${e}`); return t.isIdentity ? Kd : v1(t.a, t.b, t.c, t.d, t.e, t.f) } function Hhe(e) { return e == null || (pc || (pc = document.createElementNS('http://www.w3.org/2000/svg', 'g')), pc.setAttribute('transform', e), !(e = pc.transform.baseVal.consolidate())) ? Kd : (e = e.matrix, v1(e.a, e.b, e.c, e.d, e.e, e.f)) } function m1(e, t, r, o) {
  function s(g) { return g.length ? `${g.pop()} ` : '' } function c(g, v, y, b, x, T) {
    if (g !== y || v !== b) { const E = x.push('translate(', null, t, null, r); T.push({ i: E - 4, x: Fi(g, y) }, { i: E - 2, x: Fi(v, b) }) }
    else {
      (y || b) && x.push(`translate(${y}${t}${b}${r}`)
    }
  } function f(g, v, y, b) { g !== v ? (g - v > 180 ? v += 360 : v - g > 180 && (g += 360), b.push({ i: y.push(`${s(y)}rotate(`, null, o) - 2, x: Fi(g, v) })) : v && y.push(`${s(y)}rotate(${v}${o}`) } function d(g, v, y, b) { g !== v ? b.push({ i: y.push(`${s(y)}skewX(`, null, o) - 2, x: Fi(g, v) }) : v && y.push(`${s(y)}skewX(${v}${o}`) } function h(g, v, y, b, x, T) {
    if (g !== y || v !== b) { const E = x.push(`${s(x)}scale(`, null, ',', null, ')'); T.push({ i: E - 4, x: Fi(g, y) }, { i: E - 2, x: Fi(v, b) }) }
    else {
      (y !== 1 || b !== 1) && x.push(`${s(x)}scale(${y},${b})`)
    }
  } return function (g, v) { const y = []; const b = []; return g = e(g), v = e(v), c(g.translateX, g.translateY, v.translateX, v.translateY, y, b), f(g.rotate, v.rotate, y, b), d(g.skewX, v.skewX, y, b), h(g.scaleX, g.scaleY, v.scaleX, v.scaleY, y, b), g = v = null, function (x) { for (var T = -1, E = b.length, M; ++T < E;)y[(M = b[T]).i] = M.x(x); return y.join('') } }
} const qhe = m1(Fhe, 'px, ', 'px)', 'deg)'); const Bhe = m1(Hhe, ', ', ')', ')'); const Whe = 1e-12; function b0(e) { return ((e = Math.exp(e)) + 1 / e) / 2 } function Uhe(e) { return ((e = Math.exp(e)) - 1 / e) / 2 } function Vhe(e) { return ((e = Math.exp(2 * e)) - 1) / (e + 1) } const jhe = (function e(t, r, o) {
  function s(c, f) {
    const d = c[0]; const h = c[1]; const g = c[2]; const v = f[0]; const y = f[1]; const b = f[2]; const x = v - d; const T = y - h; const E = x * x + T * T; let M; let N; if (E < Whe) {
      N = Math.log(b / g) / t, M = function (J) { return [d + J * x, h + J * T, g * Math.exp(t * J * N)] }
    }
    else { const L = Math.sqrt(E); const O = (b * b - g * g + o * E) / (2 * g * r * L); const A = (b * b - g * g - o * E) / (2 * b * r * L); const H = Math.log(Math.sqrt(O * O + 1) - O); const z = Math.log(Math.sqrt(A * A + 1) - A); N = (z - H) / t, M = function (J) { const re = J * N; const te = b0(H); const j = g / (r * L) * (te * Vhe(t * re + H) - Uhe(H)); return [d + j * x, h + j * T, g * te / b0(t * re + H)] } } return M.duration = N * 1e3 * t / Math.SQRT2, M
  } return s.rho = function (c) { const f = Math.max(0.001, +c); const d = f * f; const h = d * d; return e(f, d, h) }, s
}(Math.SQRT2, 2, 4)); let $s = 0; let wl = 0; let vl = 0; const y1 = 1e3; let su; let xl; let lu = 0; let $o = 0; let Fu = 0; const ra = typeof performance == 'object' && performance.now ? performance : Date; const b1 = typeof window == 'object' && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (e) { setTimeout(e, 17) }; function Qh() { return $o || (b1(Ghe), $o = ra.now() + Fu) } function Ghe() { $o = 0 } function au() { this._call = this._time = this._next = null }au.prototype = ep.prototype = { constructor: au, restart(e, t, r) {
  if (typeof e != 'function')
    throw new TypeError('callback is not a function'); r = (r == null ? Qh() : +r) + (t == null ? 0 : +t), !this._next && xl !== this && (xl ? xl._next = this : su = this, xl = this), this._call = e, this._time = r, Xd()
}, stop() { this._call && (this._call = null, this._time = 1 / 0, Xd()) } }; function ep(e, t, r) { const o = new au(); return o.restart(e, t, r), o } function Khe() { Qh(), ++$s; for (var e = su, t; e;)(t = $o - e._time) >= 0 && e._call.call(void 0, t), e = e._next; --$s } function w0() {
  $o = (lu = ra.now()) + Fu, $s = wl = 0; try { Khe() }
  finally { $s = 0, Yhe(), $o = 0 }
} function Xhe() { const e = ra.now(); const t = e - lu; t > y1 && (Fu -= t, lu = e) } function Yhe() { for (var e, t = su, r, o = 1 / 0; t;)t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (r = t._next, t._next = null, t = e ? e._next = r : su = r); xl = e, Xd(o) } function Xd(e) { if (!$s) { wl && (wl = clearTimeout(wl)); const t = e - $o; t > 24 ? (e < 1 / 0 && (wl = setTimeout(w0, e - ra.now() - Fu)), vl && (vl = clearInterval(vl))) : (vl || (lu = ra.now(), vl = setInterval(Xhe, y1)), $s = 1, b1(w0)) } } function x0(e, t, r) { const o = new au(); return t = t == null ? 0 : +t, o.restart((s) => { o.stop(), e(s + t) }, t, r), o } const Zhe = ma('start', 'end', 'cancel', 'interrupt'); const Jhe = []; const w1 = 0; const _0 = 1; const Yd = 2; const Ac = 3; const S0 = 4; const Zd = 5; const Mc = 6; function Hu(e, t, r, o, s, c) {
  const f = e.__transition; if (!f)
    e.__transition = {}; else if (r in f)
    return; Qhe(e, r, { name: t, index: o, group: s, on: Zhe, tween: Jhe, time: c.time, delay: c.delay, duration: c.duration, ease: c.ease, timer: null, state: w1 })
} function tp(e, t) {
  const r = Sr(e, t); if (r.state > w1)
    throw new Error('too late; already scheduled'); return r
} function qr(e, t) {
  const r = Sr(e, t); if (r.state > Ac)
    throw new Error('too late; already running'); return r
} function Sr(e, t) {
  let r = e.__transition; if (!r || !(r = r[t]))
    throw new Error('transition not found'); return r
} function Qhe(e, t, r) {
  const o = e.__transition; let s; o[t] = r, r.timer = ep(c, 0, r.time); function c(g) { r.state = _0, r.timer.restart(f, r.delay, r.time), r.delay <= g && f(g - r.delay) } function f(g) {
    let v, y, b, x; if (r.state !== _0)
      return h(); for (v in o) {
      if (x = o[v], x.name === r.name) {
        if (x.state === Ac)
          return x0(f); x.state === S0 ? (x.state = Mc, x.timer.stop(), x.on.call('interrupt', e, e.__data__, x.index, x.group), delete o[v]) : +v < t && (x.state = Mc, x.timer.stop(), x.on.call('cancel', e, e.__data__, x.index, x.group), delete o[v])
      }
    } if (x0(() => { r.state === Ac && (r.state = S0, r.timer.restart(d, r.delay, r.time), d(g)) }), r.state = Yd, r.on.call('start', e, e.__data__, r.index, r.group), r.state === Yd) { for (r.state = Ac, s = Array.from({ length: b = r.tween.length }), v = 0, y = -1; v < b; ++v)(x = r.tween[v].value.call(e, e.__data__, r.index, r.group)) && (s[++y] = x); s.length = y + 1 }
  } function d(g) { for (let v = g < r.duration ? r.ease.call(null, g / r.duration) : (r.timer.restart(h), r.state = Zd, 1), y = -1, b = s.length; ++y < b;)s[y].call(e, v); r.state === Zd && (r.on.call('end', e, e.__data__, r.index, r.group), h()) } function h() { r.state = Mc, r.timer.stop(), delete o[t]; for (const g in o) return; delete e.__transition }
} function Nc(e, t) { const r = e.__transition; let o; let s; let c = !0; let f; if (r) { t = t == null ? null : `${t}`; for (f in r) { if ((o = r[f]).name !== t) { c = !1; continue }s = o.state > Yd && o.state < Zd, o.state = Mc, o.timer.stop(), o.on.call(s ? 'interrupt' : 'cancel', e, e.__data__, o.index, o.group), delete r[f] }c && delete e.__transition } } function epe(e) { return this.each(function () { Nc(this, e) }) } function tpe(e, t) {
  let r, o; return function () {
    const s = qr(this, e); const c = s.tween; if (c !== r) {
      o = r = c; for (let f = 0, d = o.length; f < d; ++f) {
        if (o[f].name === t) { o = o.slice(), o.splice(f, 1); break }
      }
    }s.tween = o
  }
} function npe(e, t, r) {
  let o, s; if (typeof r != 'function')
    throw new Error(); return function () {
    const c = qr(this, e); const f = c.tween; if (f !== o) {
      s = (o = f).slice(); for (var d = { name: t, value: r }, h = 0, g = s.length; h < g; ++h) {
        if (s[h].name === t) { s[h] = d; break }
      }h === g && s.push(d)
    }c.tween = s
  }
} function rpe(e, t) {
  const r = this._id; if (e += '', arguments.length < 2) {
    for (var o = Sr(this.node(), r).tween, s = 0, c = o.length, f; s < c; ++s) {
      if ((f = o[s]).name === e)
        return f.value
    } return null
  } return this.each((t == null ? tpe : npe)(r, e, t))
} function np(e, t, r) { const o = e._id; return e.each(function () { const s = qr(this, o); (s.value || (s.value = {}))[t] = r.apply(this, arguments) }), function (s) { return Sr(s, o).value[t] } } function x1(e, t) { let r; return (typeof t == 'number' ? Fi : t instanceof na ? m0 : (r = na(t)) ? (t = r, m0) : Ihe)(e, t) } function ipe(e) { return function () { this.removeAttribute(e) } } function ope(e) { return function () { this.removeAttributeNS(e.space, e.local) } } function spe(e, t, r) { let o; const s = `${r}`; let c; return function () { const f = this.getAttribute(e); return f === s ? null : f === o ? c : c = t(o = f, r) } } function lpe(e, t, r) { let o; const s = `${r}`; let c; return function () { const f = this.getAttributeNS(e.space, e.local); return f === s ? null : f === o ? c : c = t(o = f, r) } } function ape(e, t, r) { let o, s, c; return function () { let f; const d = r(this); let h; return d == null ? void this.removeAttribute(e) : (f = this.getAttribute(e), h = `${d}`, f === h ? null : f === o && h === s ? c : (s = h, c = t(o = f, d))) } } function cpe(e, t, r) { let o, s, c; return function () { let f; const d = r(this); let h; return d == null ? void this.removeAttributeNS(e.space, e.local) : (f = this.getAttributeNS(e.space, e.local), h = `${d}`, f === h ? null : f === o && h === s ? c : (s = h, c = t(o = f, d))) } } function upe(e, t) { const r = Iu(e); const o = r === 'transform' ? Bhe : x1; return this.attrTween(e, typeof t == 'function' ? (r.local ? cpe : ape)(r, o, np(this, `attr.${e}`, t)) : t == null ? (r.local ? ope : ipe)(r) : (r.local ? lpe : spe)(r, o, t)) } function fpe(e, t) { return function (r) { this.setAttribute(e, t.call(this, r)) } } function dpe(e, t) { return function (r) { this.setAttributeNS(e.space, e.local, t.call(this, r)) } } function hpe(e, t) { let r, o; function s() { const c = t.apply(this, arguments); return c !== o && (r = (o = c) && dpe(e, c)), r } return s._value = t, s } function ppe(e, t) { let r, o; function s() { const c = t.apply(this, arguments); return c !== o && (r = (o = c) && fpe(e, c)), r } return s._value = t, s } function gpe(e, t) {
  let r = `attr.${e}`; if (arguments.length < 2)
    return (r = this.tween(r)) && r._value; if (t == null)
    return this.tween(r, null); if (typeof t != 'function')
    throw new Error(); const o = Iu(e); return this.tween(r, (o.local ? hpe : ppe)(o, t))
} function vpe(e, t) { return function () { tp(this, e).delay = +t.apply(this, arguments) } } function mpe(e, t) { return t = +t, function () { tp(this, e).delay = t } } function ype(e) { const t = this._id; return arguments.length ? this.each((typeof e == 'function' ? vpe : mpe)(t, e)) : Sr(this.node(), t).delay } function bpe(e, t) { return function () { qr(this, e).duration = +t.apply(this, arguments) } } function wpe(e, t) { return t = +t, function () { qr(this, e).duration = t } } function xpe(e) { const t = this._id; return arguments.length ? this.each((typeof e == 'function' ? bpe : wpe)(t, e)) : Sr(this.node(), t).duration } function _pe(e, t) {
  if (typeof t != 'function')
    throw new Error(); return function () { qr(this, e).ease = t }
} function Spe(e) { const t = this._id; return arguments.length ? this.each(_pe(t, e)) : Sr(this.node(), t).ease } function kpe(e, t) {
  return function () {
    const r = t.apply(this, arguments); if (typeof r != 'function')
      throw new Error(); qr(this, e).ease = r
  }
} function Cpe(e) {
  if (typeof e != 'function')
    throw new Error(); return this.each(kpe(this._id, e))
} function Tpe(e) {
  typeof e != 'function' && (e = e1(e)); for (var t = this._groups, r = t.length, o = new Array(r), s = 0; s < r; ++s) {
    for (var c = t[s], f = c.length, d = o[s] = [], h, g = 0; g < f; ++g)(h = c[g]) && e.call(h, h.__data__, g, c) && d.push(h)
  } return new ci(o, this._parents, this._name, this._id)
} function Epe(e) {
  if (e._id !== this._id)
    throw new Error(); for (var t = this._groups, r = e._groups, o = t.length, s = r.length, c = Math.min(o, s), f = new Array(o), d = 0; d < c; ++d) {
    for (var h = t[d], g = r[d], v = h.length, y = f[d] = new Array(v), b, x = 0; x < v; ++x)(b = h[x] || g[x]) && (y[x] = b)
  } for (;d < o; ++d)f[d] = t[d]; return new ci(f, this._parents, this._name, this._id)
} function Lpe(e) { return (`${e}`).trim().split(/^|\s+/).every((t) => { const r = t.indexOf('.'); return r >= 0 && (t = t.slice(0, r)), !t || t === 'start' }) } function Ape(e, t, r) { let o; let s; const c = Lpe(t) ? tp : qr; return function () { const f = c(this, e); const d = f.on; d !== o && (s = (o = d).copy()).on(t, r), f.on = s } } function Mpe(e, t) { const r = this._id; return arguments.length < 2 ? Sr(this.node(), r).on.on(e) : this.each(Ape(r, e, t)) } function Npe(e) {
  return function () {
    const t = this.parentNode; for (const r in this.__transition) {
      if (+r !== e)
        return
    } t && t.removeChild(this)
  }
} function $pe() { return this.on('end.remove', Npe(this._id)) } function Ope(e) {
  const t = this._name; const r = this._id; typeof e != 'function' && (e = Yh(e)); for (var o = this._groups, s = o.length, c = new Array(s), f = 0; f < s; ++f) {
    for (var d = o[f], h = d.length, g = c[f] = new Array(h), v, y, b = 0; b < h; ++b)(v = d[b]) && (y = e.call(v, v.__data__, b, d)) && ('__data__' in v && (y.__data__ = v.__data__), g[b] = y, Hu(g[b], t, r, b, g, Sr(v, r)))
  } return new ci(c, this._parents, t, r)
} function Ppe(e) {
  const t = this._name; const r = this._id; typeof e != 'function' && (e = Qw(e)); for (var o = this._groups, s = o.length, c = [], f = [], d = 0; d < s; ++d) {
    for (var h = o[d], g = h.length, v, y = 0; y < g; ++y) {
      if (v = h[y]) { for (var b = e.call(v, v.__data__, y, h), x, T = Sr(v, r), E = 0, M = b.length; E < M; ++E)(x = b[E]) && Hu(x, t, r, E, b, T); c.push(b), f.push(v) }
    }
  } return new ci(c, f, t, r)
} const Rpe = va.prototype.constructor; function Dpe() { return new Rpe(this._groups, this._parents) } function zpe(e, t) { let r, o, s; return function () { const c = Ns(this, e); const f = (this.style.removeProperty(e), Ns(this, e)); return c === f ? null : c === r && f === o ? s : s = t(r = c, o = f) } } function _1(e) { return function () { this.style.removeProperty(e) } } function Ipe(e, t, r) { let o; const s = `${r}`; let c; return function () { const f = Ns(this, e); return f === s ? null : f === o ? c : c = t(o = f, r) } } function Fpe(e, t, r) { let o, s, c; return function () { const f = Ns(this, e); let d = r(this); let h = `${d}`; return d == null && (h = d = (this.style.removeProperty(e), Ns(this, e))), f === h ? null : f === o && h === s ? c : (s = h, c = t(o = f, d)) } } function Hpe(e, t) { let r; let o; let s; const c = `style.${t}`; const f = `end.${c}`; let d; return function () { const h = qr(this, e); const g = h.on; const v = h.value[c] == null ? d || (d = _1(t)) : void 0; (g !== r || s !== v) && (o = (r = g).copy()).on(f, s = v), h.on = o } } function qpe(e, t, r) { const o = (e += '') == 'transform' ? qhe : x1; return t == null ? this.styleTween(e, zpe(e, o)).on(`end.style.${e}`, _1(e)) : typeof t == 'function' ? this.styleTween(e, Fpe(e, o, np(this, `style.${e}`, t))).each(Hpe(this._id, e)) : this.styleTween(e, Ipe(e, o, t), r).on(`end.style.${e}`, null) } function Bpe(e, t, r) { return function (o) { this.style.setProperty(e, t.call(this, o), r) } } function Wpe(e, t, r) { let o, s; function c() { const f = t.apply(this, arguments); return f !== s && (o = (s = f) && Bpe(e, f, r)), o } return c._value = t, c } function Upe(e, t, r) {
  let o = `style.${e += ''}`; if (arguments.length < 2)
    return (o = this.tween(o)) && o._value; if (t == null)
    return this.tween(o, null); if (typeof t != 'function')
    throw new Error(); return this.tween(o, Wpe(e, t, r ?? ''))
} function Vpe(e) { return function () { this.textContent = e } } function jpe(e) { return function () { const t = e(this); this.textContent = t ?? '' } } function Gpe(e) { return this.tween('text', typeof e == 'function' ? jpe(np(this, 'text', e)) : Vpe(e == null ? '' : `${e}`)) } function Kpe(e) { return function (t) { this.textContent = e.call(this, t) } } function Xpe(e) { let t, r; function o() { const s = e.apply(this, arguments); return s !== r && (t = (r = s) && Kpe(s)), t } return o._value = e, o } function Ype(e) {
  let t = 'text'; if (arguments.length < 1)
    return (t = this.tween(t)) && t._value; if (e == null)
    return this.tween(t, null); if (typeof e != 'function')
    throw new Error(); return this.tween(t, Xpe(e))
} function Zpe() {
  for (var e = this._name, t = this._id, r = S1(), o = this._groups, s = o.length, c = 0; c < s; ++c) {
    for (var f = o[c], d = f.length, h, g = 0; g < d; ++g) {
      if (h = f[g]) { const v = Sr(h, t); Hu(h, e, r, g, f, { time: v.time + v.delay + v.duration, delay: 0, duration: v.duration, ease: v.ease }) }
    }
  } return new ci(o, this._parents, e, r)
} function Jpe() { let e; let t; const r = this; const o = r._id; let s = r.size(); return new Promise((c, f) => { const d = { value: f }; const h = { value() { --s === 0 && c() } }; r.each(function () { const g = qr(this, o); const v = g.on; v !== e && (t = (e = v).copy(), t._.cancel.push(d), t._.interrupt.push(d), t._.end.push(h)), g.on = t }), s === 0 && c() }) } let Qpe = 0; function ci(e, t, r, o) { this._groups = e, this._parents = t, this._name = r, this._id = o } function S1() { return ++Qpe } const Zr = va.prototype; ci.prototype = { constructor: ci, select: Ope, selectAll: Ppe, selectChild: Zr.selectChild, selectChildren: Zr.selectChildren, filter: Tpe, merge: Epe, selection: Dpe, transition: Zpe, call: Zr.call, nodes: Zr.nodes, node: Zr.node, size: Zr.size, empty: Zr.empty, each: Zr.each, on: Mpe, attr: upe, attrTween: gpe, style: qpe, styleTween: Upe, text: Gpe, textTween: Ype, remove: $pe, tween: rpe, delay: ype, duration: xpe, ease: Spe, easeVarying: Cpe, end: Jpe, [Symbol.iterator]: Zr[Symbol.iterator] }; function ege(e) { return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2 } const tge = { time: null, delay: 0, duration: 250, ease: ege }; function nge(e, t) {
  for (var r; !(r = e.__transition) || !(r = r[t]);) {
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`)
  } return r
} function rge(e) {
  let t, r; e instanceof ci ? (t = e._id, e = e._name) : (t = S1(), (r = tge).time = Qh(), e = e == null ? null : `${e}`); for (var o = this._groups, s = o.length, c = 0; c < s; ++c) {
    for (var f = o[c], d = f.length, h, g = 0; g < d; ++g)(h = f[g]) && Hu(h, e, t, g, f, r || nge(h, t))
  } return new ci(o, this._parents, e, t)
}va.prototype.interrupt = epe; va.prototype.transition = rge; const gc = e => () => e; function ige(e, { sourceEvent: t, target: r, transform: o, dispatch: s }) { Object.defineProperties(this, { type: { value: e, enumerable: !0, configurable: !0 }, sourceEvent: { value: t, enumerable: !0, configurable: !0 }, target: { value: r, enumerable: !0, configurable: !0 }, transform: { value: o, enumerable: !0, configurable: !0 }, _: { value: s } }) } function ti(e, t, r) { this.k = e, this.x = t, this.y = r }ti.prototype = { constructor: ti, scale(e) { return e === 1 ? this : new ti(this.k * e, this.x, this.y) }, translate(e, t) { return e === 0 & t === 0 ? this : new ti(this.k, this.x + this.k * e, this.y + this.k * t) }, apply(e) { return [e[0] * this.k + this.x, e[1] * this.k + this.y] }, applyX(e) { return e * this.k + this.x }, applyY(e) { return e * this.k + this.y }, invert(e) { return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k] }, invertX(e) { return (e - this.x) / this.k }, invertY(e) { return (e - this.y) / this.k }, rescaleX(e) { return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e)) }, rescaleY(e) { return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e)) }, toString() { return `translate(${this.x},${this.y}) scale(${this.k})` } }; const rp = new ti(1, 0, 0); ti.prototype; function ld(e) { e.stopImmediatePropagation() } function ml(e) { e.preventDefault(), e.stopImmediatePropagation() } function oge(e) { return (!e.ctrlKey || e.type === 'wheel') && !e.button } function sge() { let e = this; return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute('viewBox') ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]] } function k0() { return this.__zoom || rp } function lge(e) { return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 0.002) * (e.ctrlKey ? 10 : 1) } function age() { return navigator.maxTouchPoints || 'ontouchstart' in this } function cge(e, t, r) { const o = e.invertX(t[0][0]) - r[0][0]; const s = e.invertX(t[1][0]) - r[1][0]; const c = e.invertY(t[0][1]) - r[0][1]; const f = e.invertY(t[1][1]) - r[1][1]; return e.translate(s > o ? (o + s) / 2 : Math.min(0, o) || Math.max(0, s), f > c ? (c + f) / 2 : Math.min(0, c) || Math.max(0, f)) } function uge() {
  let e = oge; let t = sge; let r = cge; let o = lge; let s = age; const c = [0, 1 / 0]; const f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]]; let d = 250; let h = jhe; const g = ma('start', 'zoom', 'end'); let v; let y; let b; const x = 500; const T = 150; let E = 0; let M = 10; function N(I) { I.property('__zoom', k0).on('wheel.zoom', re, { passive: !1 }).on('mousedown.zoom', te).on('dblclick.zoom', j).filter(s).on('touchstart.zoom', ne).on('touchmove.zoom', K).on('touchend.zoom touchcancel.zoom', V).style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)') }N.transform = function (I, k, B, W) { const ie = I.selection ? I.selection() : I; ie.property('__zoom', k0), I !== ie ? H(I, k, B, W) : ie.interrupt().each(function () { z(this, arguments).event(W).start().zoom(null, typeof k == 'function' ? k.apply(this, arguments) : k).end() }) }, N.scaleBy = function (I, k, B, W) { N.scaleTo(I, function () { const ie = this.__zoom.k; const ye = typeof k == 'function' ? k.apply(this, arguments) : k; return ie * ye }, B, W) }, N.scaleTo = function (I, k, B, W) { N.transform(I, function () { const ie = t.apply(this, arguments); const ye = this.__zoom; const Ne = B == null ? A(ie) : typeof B == 'function' ? B.apply(this, arguments) : B; const We = ye.invert(Ne); const je = typeof k == 'function' ? k.apply(this, arguments) : k; return r(O(L(ye, je), Ne, We), ie, f) }, B, W) }, N.translateBy = function (I, k, B, W) { N.transform(I, function () { return r(this.__zoom.translate(typeof k == 'function' ? k.apply(this, arguments) : k, typeof B == 'function' ? B.apply(this, arguments) : B), t.apply(this, arguments), f) }, null, W) }, N.translateTo = function (I, k, B, W, ie) { N.transform(I, function () { const ye = t.apply(this, arguments); const Ne = this.__zoom; const We = W == null ? A(ye) : typeof W == 'function' ? W.apply(this, arguments) : W; return r(rp.translate(We[0], We[1]).scale(Ne.k).translate(typeof k == 'function' ? -k.apply(this, arguments) : -k, typeof B == 'function' ? -B.apply(this, arguments) : -B), ye, f) }, W, ie) }; function L(I, k) { return k = Math.max(c[0], Math.min(c[1], k)), k === I.k ? I : new ti(k, I.x, I.y) } function O(I, k, B) { const W = k[0] - B[0] * I.k; const ie = k[1] - B[1] * I.k; return W === I.x && ie === I.y ? I : new ti(I.k, W, ie) } function A(I) { return [(+I[0][0] + +I[1][0]) / 2, (+I[0][1] + +I[1][1]) / 2] } function H(I, k, B, W) {
    I.on('start.zoom', function () { z(this, arguments).event(W).start() }).on('interrupt.zoom end.zoom', function () { z(this, arguments).event(W).end() }).tween('zoom', function () {
      const ie = this; const ye = arguments; const Ne = z(ie, ye).event(W); const We = t.apply(ie, ye); const je = B == null ? A(We) : typeof B == 'function' ? B.apply(ie, ye) : B; const it = Math.max(We[1][0] - We[0][0], We[1][1] - We[0][1]); const rt = ie.__zoom; const Ze = typeof k == 'function' ? k.apply(ie, ye) : k; const Ee = h(rt.invert(je).concat(it / rt.k), Ze.invert(je).concat(it / Ze.k)); return function (X) {
        if (X === 1) {
          X = Ze
        }
        else { const ae = Ee(X); const de = it / ae[2]; X = new ti(de, je[0] - ae[0] * de, je[1] - ae[1] * de) }Ne.zoom(null, X)
      }
    })
  } function z(I, k, B) { return !B && I.__zooming || new J(I, k) } function J(I, k) { this.that = I, this.args = k, this.active = 0, this.sourceEvent = null, this.extent = t.apply(I, k), this.taps = 0 }J.prototype = { event(I) { return I && (this.sourceEvent = I), this }, start() { return ++this.active === 1 && (this.that.__zooming = this, this.emit('start')), this }, zoom(I, k) { return this.mouse && I !== 'mouse' && (this.mouse[1] = k.invert(this.mouse[0])), this.touch0 && I !== 'touch' && (this.touch0[1] = k.invert(this.touch0[0])), this.touch1 && I !== 'touch' && (this.touch1[1] = k.invert(this.touch1[0])), this.that.__zoom = k, this.emit('zoom'), this }, end() { return --this.active === 0 && (delete this.that.__zooming, this.emit('end')), this }, emit(I) { const k = Pn(this.that).datum(); g.call(I, this.that, new ige(I, { sourceEvent: this.sourceEvent, target: N, type: I, transform: this.that.__zoom, dispatch: g }), k) } }; function re(I, ...k) {
    if (!e.apply(this, arguments))
      return; const B = z(this, k).event(I); const W = this.__zoom; const ie = Math.max(c[0], Math.min(c[1], W.k * 2 ** o.apply(this, arguments))); const ye = ei(I); if (B.wheel) {
      (B.mouse[0][0] !== ye[0] || B.mouse[0][1] !== ye[1]) && (B.mouse[1] = W.invert(B.mouse[0] = ye)), clearTimeout(B.wheel)
    }
    else {
      if (W.k === ie)
        return; B.mouse = [ye, W.invert(ye)], Nc(this), B.start()
    }ml(I), B.wheel = setTimeout(Ne, T), B.zoom('mouse', r(O(L(W, ie), B.mouse[0], B.mouse[1]), B.extent, f)); function Ne() { B.wheel = null, B.end() }
  } function te(I, ...k) {
    if (b || !e.apply(this, arguments))
      return; const B = I.currentTarget; const W = z(this, k, !0).event(I); const ie = Pn(I.view).on('mousemove.zoom', je, !0).on('mouseup.zoom', it, !0); const ye = ei(I, B); const Ne = I.clientX; const We = I.clientY; u1(I.view), ld(I), W.mouse = [ye, this.__zoom.invert(ye)], Nc(this), W.start(); function je(rt) { if (ml(rt), !W.moved) { const Ze = rt.clientX - Ne; const Ee = rt.clientY - We; W.moved = Ze * Ze + Ee * Ee > E }W.event(rt).zoom('mouse', r(O(W.that.__zoom, W.mouse[0] = ei(rt, B), W.mouse[1]), W.extent, f)) } function it(rt) { ie.on('mousemove.zoom mouseup.zoom', null), f1(rt.view, W.moved), ml(rt), W.event(rt).end() }
  } function j(I, ...k) { if (e.apply(this, arguments)) { const B = this.__zoom; const W = ei(I.changedTouches ? I.changedTouches[0] : I, this); const ie = B.invert(W); const ye = B.k * (I.shiftKey ? 0.5 : 2); const Ne = r(O(L(B, ye), W, ie), t.apply(this, k), f); ml(I), d > 0 ? Pn(this).transition().duration(d).call(H, Ne, W, I) : Pn(this).call(N.transform, Ne, W, I) } } function ne(I, ...k) { if (e.apply(this, arguments)) { const B = I.touches; const W = B.length; const ie = z(this, k, I.changedTouches.length === W).event(I); let ye; let Ne; let We; let je; for (ld(I), Ne = 0; Ne < W; ++Ne)We = B[Ne], je = ei(We, this), je = [je, this.__zoom.invert(je), We.identifier], ie.touch0 ? !ie.touch1 && ie.touch0[2] !== je[2] && (ie.touch1 = je, ie.taps = 0) : (ie.touch0 = je, ye = !0, ie.taps = 1 + !!v); v && (v = clearTimeout(v)), ye && (ie.taps < 2 && (y = je[0], v = setTimeout(() => { v = null }, x)), Nc(this), ie.start()) } } function K(I, ...k) {
    if (this.__zooming) {
      const B = z(this, k).event(I); const W = I.changedTouches; const ie = W.length; let ye; let Ne; let We; let je; for (ml(I), ye = 0; ye < ie; ++ye)Ne = W[ye], We = ei(Ne, this), B.touch0 && B.touch0[2] === Ne.identifier ? B.touch0[0] = We : B.touch1 && B.touch1[2] === Ne.identifier && (B.touch1[0] = We); if (Ne = B.that.__zoom, B.touch1) { const it = B.touch0[0]; const rt = B.touch0[1]; const Ze = B.touch1[0]; const Ee = B.touch1[1]; var X = (X = Ze[0] - it[0]) * X + (X = Ze[1] - it[1]) * X; var ae = (ae = Ee[0] - rt[0]) * ae + (ae = Ee[1] - rt[1]) * ae; Ne = L(Ne, Math.sqrt(X / ae)), We = [(it[0] + Ze[0]) / 2, (it[1] + Ze[1]) / 2], je = [(rt[0] + Ee[0]) / 2, (rt[1] + Ee[1]) / 2] }
      else if (B.touch0) {
        We = B.touch0[0], je = B.touch0[1]
      }
      else {
        return
      }B.zoom('touch', r(O(Ne, We, je), B.extent, f))
    }
  } function V(I, ...k) {
    if (this.__zooming) {
      const B = z(this, k).event(I); const W = I.changedTouches; const ie = W.length; let ye; let Ne; for (ld(I), b && clearTimeout(b), b = setTimeout(() => { b = null }, x), ye = 0; ye < ie; ++ye)Ne = W[ye], B.touch0 && B.touch0[2] === Ne.identifier ? delete B.touch0 : B.touch1 && B.touch1[2] === Ne.identifier && delete B.touch1; if (B.touch1 && !B.touch0 && (B.touch0 = B.touch1, delete B.touch1), B.touch0) {
        B.touch0[1] = this.__zoom.invert(B.touch0[0])
      }
      else if (B.end(), B.taps === 2 && (Ne = ei(Ne, this), Math.hypot(y[0] - Ne[0], y[1] - Ne[1]) < M)) { const We = Pn(this).on('dblclick.zoom'); We && We.apply(this, arguments) }
    }
  } return N.wheelDelta = function (I) { return arguments.length ? (o = typeof I == 'function' ? I : gc(+I), N) : o }, N.filter = function (I) { return arguments.length ? (e = typeof I == 'function' ? I : gc(!!I), N) : e }, N.touchable = function (I) { return arguments.length ? (s = typeof I == 'function' ? I : gc(!!I), N) : s }, N.extent = function (I) { return arguments.length ? (t = typeof I == 'function' ? I : gc([[+I[0][0], +I[0][1]], [+I[1][0], +I[1][1]]]), N) : t }, N.scaleExtent = function (I) { return arguments.length ? (c[0] = +I[0], c[1] = +I[1], N) : [c[0], c[1]] }, N.translateExtent = function (I) { return arguments.length ? (f[0][0] = +I[0][0], f[1][0] = +I[1][0], f[0][1] = +I[0][1], f[1][1] = +I[1][1], N) : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]] }, N.constrain = function (I) { return arguments.length ? (r = I, N) : r }, N.duration = function (I) { return arguments.length ? (d = +I, N) : d }, N.interpolate = function (I) { return arguments.length ? (h = I, N) : h }, N.on = function () { const I = g.on.apply(g, arguments); return I === g ? N : I }, N.clickDistance = function (I) { return arguments.length ? (E = (I = +I) * I, N) : Math.sqrt(E) }, N.tapDistance = function (I) { return arguments.length ? (M = +I, N) : M }, N
} function fge(e) { const t = +this._x.call(null, e); const r = +this._y.call(null, e); return k1(this.cover(t, r), t, r, e) } function k1(e, t, r, o) {
  if (isNaN(t) || isNaN(r))
    return e; let s; let c = e._root; const f = { data: o }; let d = e._x0; let h = e._y0; let g = e._x1; let v = e._y1; let y; let b; let x; let T; let E; let M; let N; let L; if (!c)
    return e._root = f, e; for (;c.length;) {
    if ((E = t >= (y = (d + g) / 2)) ? d = y : g = y, (M = r >= (b = (h + v) / 2)) ? h = b : v = b, s = c, !(c = c[N = M << 1 | E]))
      return s[N] = f, e
  } if (x = +e._x.call(null, c.data), T = +e._y.call(null, c.data), t === x && r === T)
    return f.next = c, s ? s[N] = f : e._root = f, e; do s = s ? s[N] = Array.from({ length: 4 }) : e._root = Array.from({ length: 4 }), (E = t >= (y = (d + g) / 2)) ? d = y : g = y, (M = r >= (b = (h + v) / 2)) ? h = b : v = b; while ((N = M << 1 | E) === (L = (T >= b) << 1 | x >= y)); return s[L] = c, s[N] = f, e
} function dge(e) {
  let t; let r; const o = e.length; let s; let c; const f = new Array(o); const d = new Array(o); let h = 1 / 0; let g = 1 / 0; let v = -1 / 0; let y = -1 / 0; for (r = 0; r < o; ++r)isNaN(s = +this._x.call(null, t = e[r])) || isNaN(c = +this._y.call(null, t)) || (f[r] = s, d[r] = c, s < h && (h = s), s > v && (v = s), c < g && (g = c), c > y && (y = c)); if (h > v || g > y)
    return this; for (this.cover(h, g).cover(v, y), r = 0; r < o; ++r)k1(this, f[r], d[r], e[r]); return this
} function hge(e, t) {
  if (isNaN(e = +e) || isNaN(t = +t))
    return this; let r = this._x0; let o = this._y0; let s = this._x1; let c = this._y1; if (isNaN(r)) {
    s = (r = Math.floor(e)) + 1, c = (o = Math.floor(t)) + 1
  }
  else { for (var f = s - r || 1, d = this._root, h, g; r > e || e >= s || o > t || t >= c;) switch (g = (t < o) << 1 | e < r, h = Array.from({ length: 4 }), h[g] = d, d = h, f *= 2, g) { case 0:s = r + f, c = o + f; break; case 1:r = s - f, c = o + f; break; case 2:s = r + f, o = c - f; break; case 3:r = s - f, o = c - f; break } this._root && this._root.length && (this._root = d) } return this._x0 = r, this._y0 = o, this._x1 = s, this._y1 = c, this
} function pge() {
  const e = []; return this.visit((t) => {
    if (!t.length) {
      do e.push(t.data); while (t = t.next)
    }
  }), e
} function gge(e) { return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]] } function Sn(e, t, r, o, s) { this.node = e, this.x0 = t, this.y0 = r, this.x1 = o, this.y1 = s } function vge(e, t, r) {
  let o; let s = this._x0; let c = this._y0; let f; let d; let h; let g; let v = this._x1; let y = this._y1; const b = []; let x = this._root; let T; let E; for (x && b.push(new Sn(x, s, c, v, y)), r == null ? r = 1 / 0 : (s = e - r, c = t - r, v = e + r, y = t + r, r *= r); T = b.pop();) {
    if (!(!(x = T.node) || (f = T.x0) > v || (d = T.y0) > y || (h = T.x1) < s || (g = T.y1) < c)) {
      if (x.length) { const M = (f + h) / 2; const N = (d + g) / 2; b.push(new Sn(x[3], M, N, h, g), new Sn(x[2], f, N, M, g), new Sn(x[1], M, d, h, N), new Sn(x[0], f, d, M, N)), (E = (t >= N) << 1 | e >= M) && (T = b[b.length - 1], b[b.length - 1] = b[b.length - 1 - E], b[b.length - 1 - E] = T) }
      else { const L = e - +this._x.call(null, x.data); const O = t - +this._y.call(null, x.data); const A = L * L + O * O; if (A < r) { const H = Math.sqrt(r = A); s = e - H, c = t - H, v = e + H, y = t + H, o = x.data } }
    }
  } return o
} function mge(e) {
  if (isNaN(v = +this._x.call(null, e)) || isNaN(y = +this._y.call(null, e)))
    return this; let t; let r = this._root; let o; let s; let c; let f = this._x0; let d = this._y0; let h = this._x1; let g = this._y1; let v; let y; let b; let x; let T; let E; let M; let N; if (!r)
    return this; if (r.length) {
    for (;;) {
      if ((T = v >= (b = (f + h) / 2)) ? f = b : h = b, (E = y >= (x = (d + g) / 2)) ? d = x : g = x, t = r, !(r = r[M = E << 1 | T]))
        return this; if (!r.length)
        break; (t[M + 1 & 3] || t[M + 2 & 3] || t[M + 3 & 3]) && (o = t, N = M)
    }
  } for (;r.data !== e;) {
    if (s = r, !(r = r.next))
      return this
  } return (c = r.next) && delete r.next, s ? (c ? s.next = c : delete s.next, this) : t ? (c ? t[M] = c : delete t[M], (r = t[0] || t[1] || t[2] || t[3]) && r === (t[3] || t[2] || t[1] || t[0]) && !r.length && (o ? o[N] = r : this._root = r), this) : (this._root = c, this)
} function yge(e) { for (let t = 0, r = e.length; t < r; ++t) this.remove(e[t]); return this } function bge() { return this._root } function wge() {
  let e = 0; return this.visit((t) => {
    if (!t.length) {
      do ++e; while (t = t.next)
    }
  }), e
} function xge(e) {
  const t = []; let r; let o = this._root; let s; let c; let f; let d; let h; for (o && t.push(new Sn(o, this._x0, this._y0, this._x1, this._y1)); r = t.pop();) {
    if (!e(o = r.node, c = r.x0, f = r.y0, d = r.x1, h = r.y1) && o.length) { const g = (c + d) / 2; const v = (f + h) / 2; (s = o[3]) && t.push(new Sn(s, g, v, d, h)), (s = o[2]) && t.push(new Sn(s, c, v, g, h)), (s = o[1]) && t.push(new Sn(s, g, f, d, v)), (s = o[0]) && t.push(new Sn(s, c, f, g, v)) }
  } return this
} function _ge(e) { const t = []; const r = []; let o; for (this._root && t.push(new Sn(this._root, this._x0, this._y0, this._x1, this._y1)); o = t.pop();) { const s = o.node; if (s.length) { var c; const f = o.x0; const d = o.y0; const h = o.x1; const g = o.y1; const v = (f + h) / 2; const y = (d + g) / 2; (c = s[0]) && t.push(new Sn(c, f, d, v, y)), (c = s[1]) && t.push(new Sn(c, v, d, h, y)), (c = s[2]) && t.push(new Sn(c, f, y, v, g)), (c = s[3]) && t.push(new Sn(c, v, y, h, g)) }r.push(o) } for (;o = r.pop();)e(o.node, o.x0, o.y0, o.x1, o.y1); return this } function Sge(e) { return e[0] } function kge(e) { return arguments.length ? (this._x = e, this) : this._x } function Cge(e) { return e[1] } function Tge(e) { return arguments.length ? (this._y = e, this) : this._y } function ip(e, t, r) { const o = new op(t ?? Sge, r ?? Cge, Number.NaN, Number.NaN, Number.NaN, Number.NaN); return e == null ? o : o.addAll(e) } function op(e, t, r, o, s, c) { this._x = e, this._y = t, this._x0 = r, this._y0 = o, this._x1 = s, this._y1 = c, this._root = void 0 } function C0(e) { for (var t = { data: e.data }, r = t; e = e.next;)r = r.next = { data: e.data }; return t } const Tn = ip.prototype = op.prototype; Tn.copy = function () {
  const e = new op(this._x, this._y, this._x0, this._y0, this._x1, this._y1); let t = this._root; let r; let o; if (!t)
    return e; if (!t.length)
    return e._root = C0(t), e; for (r = [{ source: t, target: e._root = Array.from({ length: 4 }) }]; t = r.pop();) {
    for (let s = 0; s < 4; ++s)(o = t.source[s]) && (o.length ? r.push({ source: o, target: t.target[s] = Array.from({ length: 4 }) }) : t.target[s] = C0(o))
  } return e
}; Tn.add = fge; Tn.addAll = dge; Tn.cover = hge; Tn.data = pge; Tn.extent = gge; Tn.find = vge; Tn.remove = mge; Tn.removeAll = yge; Tn.root = bge; Tn.size = wge; Tn.visit = xge; Tn.visitAfter = _ge; Tn.x = kge; Tn.y = Tge; function Cn(e) { return function () { return e } } function Bi(e) { return (e() - 0.5) * 1e-6 } function Ege(e) { return e.x + e.vx } function Lge(e) { return e.y + e.vy } function Age(e) {
  let t; let r; let o; let s = 1; let c = 1; typeof e != 'function' && (e = Cn(e == null ? 1 : +e)); function f() {
    for (var g, v = t.length, y, b, x, T, E, M, N = 0; N < c; ++N) {
      for (y = ip(t, Ege, Lge).visitAfter(d), g = 0; g < v; ++g)b = t[g], E = r[b.index], M = E * E, x = b.x + b.vx, T = b.y + b.vy, y.visit(L)
    } function L(O, A, H, z, J) { const re = O.data; let te = O.r; let j = E + te; if (re) { if (re.index > b.index) { let ne = x - re.x - re.vx; let K = T - re.y - re.vy; let V = ne * ne + K * K; V < j * j && (ne === 0 && (ne = Bi(o), V += ne * ne), K === 0 && (K = Bi(o), V += K * K), V = (j - (V = Math.sqrt(V))) / V * s, b.vx += (ne *= V) * (j = (te *= te) / (M + te)), b.vy += (K *= V) * j, re.vx -= ne * (j = 1 - j), re.vy -= K * j) } return } return A > x + j || z < x - j || H > T + j || J < T - j }
  } function d(g) {
    if (g.data)
      return g.r = r[g.data.index]; for (let v = g.r = 0; v < 4; ++v)g[v] && g[v].r > g.r && (g.r = g[v].r)
  } function h() { if (t) { let g; const v = t.length; let y; for (r = new Array(v), g = 0; g < v; ++g)y = t[g], r[y.index] = +e(y, g, t) } } return f.initialize = function (g, v) { t = g, o = v, h() }, f.iterations = function (g) { return arguments.length ? (c = +g, f) : c }, f.strength = function (g) { return arguments.length ? (s = +g, f) : s }, f.radius = function (g) { return arguments.length ? (e = typeof g == 'function' ? g : Cn(+g), h(), f) : e }, f
} function Mge(e) { return e.index } function T0(e, t) {
  const r = e.get(t); if (!r)
    throw new Error(`node not found: ${t}`); return r
} function Nge(e) {
  let t = Mge; let r = y; let o; let s = Cn(30); let c; let f; let d; let h; let g; let v = 1; e == null && (e = []); function y(M) { return 1 / Math.min(d[M.source.index], d[M.target.index]) } function b(M) {
    for (let N = 0, L = e.length; N < v; ++N) {
      for (var O = 0, A, H, z, J, re, te, j; O < L; ++O)A = e[O], H = A.source, z = A.target, J = z.x + z.vx - H.x - H.vx || Bi(g), re = z.y + z.vy - H.y - H.vy || Bi(g), te = Math.sqrt(J * J + re * re), te = (te - c[O]) / te * M * o[O], J *= te, re *= te, z.vx -= J * (j = h[O]), z.vy -= re * j, H.vx += J * (j = 1 - j), H.vy += re * j
    }
  } function x() { if (f) { let M; const N = f.length; const L = e.length; const O = new Map(f.map((H, z) => [t(H, z, f), H])); let A; for (M = 0, d = new Array(N); M < L; ++M)A = e[M], A.index = M, typeof A.source != 'object' && (A.source = T0(O, A.source)), typeof A.target != 'object' && (A.target = T0(O, A.target)), d[A.source.index] = (d[A.source.index] || 0) + 1, d[A.target.index] = (d[A.target.index] || 0) + 1; for (M = 0, h = new Array(L); M < L; ++M)A = e[M], h[M] = d[A.source.index] / (d[A.source.index] + d[A.target.index]); o = new Array(L), T(), c = new Array(L), E() } } function T() {
    if (f) {
      for (let M = 0, N = e.length; M < N; ++M)o[M] = +r(e[M], M, e)
    }
  } function E() {
    if (f) {
      for (let M = 0, N = e.length; M < N; ++M)c[M] = +s(e[M], M, e)
    }
  } return b.initialize = function (M, N) { f = M, g = N, x() }, b.links = function (M) { return arguments.length ? (e = M, x(), b) : e }, b.id = function (M) { return arguments.length ? (t = M, b) : t }, b.iterations = function (M) { return arguments.length ? (v = +M, b) : v }, b.strength = function (M) { return arguments.length ? (r = typeof M == 'function' ? M : Cn(+M), T(), b) : r }, b.distance = function (M) { return arguments.length ? (s = typeof M == 'function' ? M : Cn(+M), E(), b) : s }, b
} const $ge = 1664525; const Oge = 1013904223; const E0 = 4294967296; function Pge() { let e = 1; return () => (e = ($ge * e + Oge) % E0) / E0 } function Rge(e) { return e.x } function Dge(e) { return e.y } const zge = 10; const Ige = Math.PI * (3 - Math.sqrt(5)); function Fge(e) {
  let t; let r = 1; let o = 0.001; let s = 1 - o ** (1 / 300); let c = 0; let f = 0.6; const d = new Map(); const h = ep(y); const g = ma('tick', 'end'); let v = Pge(); e == null && (e = []); function y() { b(), g.call('tick', t), r < o && (h.stop(), g.call('end', t)) } function b(E) {
    let M; const N = e.length; let L; E === void 0 && (E = 1); for (let O = 0; O < E; ++O) {
      for (r += (c - r) * s, d.forEach((A) => { A(r) }), M = 0; M < N; ++M)L = e[M], L.fx == null ? L.x += L.vx *= f : (L.x = L.fx, L.vx = 0), L.fy == null ? L.y += L.vy *= f : (L.y = L.fy, L.vy = 0)
    } return t
  } function x() { for (var E = 0, M = e.length, N; E < M; ++E) { if (N = e[E], N.index = E, N.fx != null && (N.x = N.fx), N.fy != null && (N.y = N.fy), isNaN(N.x) || isNaN(N.y)) { const L = zge * Math.sqrt(0.5 + E); const O = E * Ige; N.x = L * Math.cos(O), N.y = L * Math.sin(O) }(isNaN(N.vx) || isNaN(N.vy)) && (N.vx = N.vy = 0) } } function T(E) { return E.initialize && E.initialize(e, v), E } return x(), t = { tick: b, restart() { return h.restart(y), t }, stop() { return h.stop(), t }, nodes(E) { return arguments.length ? (e = E, x(), d.forEach(T), t) : e }, alpha(E) { return arguments.length ? (r = +E, t) : r }, alphaMin(E) { return arguments.length ? (o = +E, t) : o }, alphaDecay(E) { return arguments.length ? (s = +E, t) : +s }, alphaTarget(E) { return arguments.length ? (c = +E, t) : c }, velocityDecay(E) { return arguments.length ? (f = 1 - E, t) : 1 - f }, randomSource(E) { return arguments.length ? (v = E, d.forEach(T), t) : v }, force(E, M) { return arguments.length > 1 ? (M == null ? d.delete(E) : d.set(E, T(M)), t) : d.get(E) }, find(E, M, N) { let L = 0; const O = e.length; let A; let H; let z; let J; let re; for (N == null ? N = 1 / 0 : N *= N, L = 0; L < O; ++L)J = e[L], A = E - J.x, H = M - J.y, z = A * A + H * H, z < N && (re = J, N = z); return re }, on(E, M) { return arguments.length > 1 ? (g.on(E, M), t) : g.on(E) } }
} function Hge() {
  let e; let t; let r; let o; let s = Cn(-30); let c; let f = 1; let d = 1 / 0; let h = 0.81; function g(x) { let T; const E = e.length; const M = ip(e, Rge, Dge).visitAfter(y); for (o = x, T = 0; T < E; ++T)t = e[T], M.visit(b) } function v() { if (e) { let x; const T = e.length; let E; for (c = new Array(T), x = 0; x < T; ++x)E = e[x], c[E.index] = +s(E, x, e) } } function y(x) {
    let T = 0; let E; let M; let N = 0; let L; let O; let A; if (x.length) { for (L = O = A = 0; A < 4; ++A)(E = x[A]) && (M = Math.abs(E.value)) && (T += E.value, N += M, L += M * E.x, O += M * E.y); x.x = L / N, x.y = O / N }
    else { E = x, E.x = E.data.x, E.y = E.data.y; do T += c[E.data.index]; while (E = E.next) }x.value = T
  } function b(x, T, E, M) {
    if (!x.value)
      return !0; let N = x.x - t.x; let L = x.y - t.y; let O = M - T; let A = N * N + L * L; if (O * O / h < A)
      return A < d && (N === 0 && (N = Bi(r), A += N * N), L === 0 && (L = Bi(r), A += L * L), A < f && (A = Math.sqrt(f * A)), t.vx += N * x.value * o / A, t.vy += L * x.value * o / A), !0; if (x.length || A >= d)
      return; (x.data !== t || x.next) && (N === 0 && (N = Bi(r), A += N * N), L === 0 && (L = Bi(r), A += L * L), A < f && (A = Math.sqrt(f * A))); do x.data !== t && (O = c[x.data.index] * o / A, t.vx += N * O, t.vy += L * O); while (x = x.next)
  } return g.initialize = function (x, T) { e = x, r = T, v() }, g.strength = function (x) { return arguments.length ? (s = typeof x == 'function' ? x : Cn(+x), v(), g) : s }, g.distanceMin = function (x) { return arguments.length ? (f = x * x, g) : Math.sqrt(f) }, g.distanceMax = function (x) { return arguments.length ? (d = x * x, g) : Math.sqrt(d) }, g.theta = function (x) { return arguments.length ? (h = x * x, g) : Math.sqrt(h) }, g
} function qge(e) { let t = Cn(0.1); let r; let o; let s; typeof e != 'function' && (e = Cn(e == null ? 0 : +e)); function c(d) { for (var h = 0, g = r.length, v; h < g; ++h)v = r[h], v.vx += (s[h] - v.x) * o[h] * d } function f() { if (r) { let d; const h = r.length; for (o = new Array(h), s = new Array(h), d = 0; d < h; ++d)o[d] = isNaN(s[d] = +e(r[d], d, r)) ? 0 : +t(r[d], d, r) } } return c.initialize = function (d) { r = d, f() }, c.strength = function (d) { return arguments.length ? (t = typeof d == 'function' ? d : Cn(+d), f(), c) : t }, c.x = function (d) { return arguments.length ? (e = typeof d == 'function' ? d : Cn(+d), f(), c) : e }, c } function Bge(e) { let t = Cn(0.1); let r; let o; let s; typeof e != 'function' && (e = Cn(e == null ? 0 : +e)); function c(d) { for (var h = 0, g = r.length, v; h < g; ++h)v = r[h], v.vy += (s[h] - v.y) * o[h] * d } function f() { if (r) { let d; const h = r.length; for (o = new Array(h), s = new Array(h), d = 0; d < h; ++d)o[d] = isNaN(s[d] = +e(r[d], d, r)) ? 0 : +t(r[d], d, r) } } return c.initialize = function (d) { r = d, f() }, c.strength = function (d) { return arguments.length ? (t = typeof d == 'function' ? d : Cn(+d), f(), c) : t }, c.y = function (d) { return arguments.length ? (e = typeof d == 'function' ? d : Cn(+d), f(), c) : e }, c } const Wge = Object.defineProperty; const Uge = (e, t, r) => t in e ? Wge(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r; const Dt = (e, t, r) => Uge(e, typeof t != 'symbol' ? `${t}` : t, r); function Vge() { return { drag: { end: 0, start: 0.1 }, filter: { link: 1, type: 0.1, unlinked: { include: 0.1, exclude: 0.1 } }, focus: { acquire: () => 0.1, release: () => 0.1 }, initialize: 1, labels: { links: { hide: 0, show: 0 }, nodes: { hide: 0, show: 0 } }, resize: 0.5 } } function L0(e) { if (typeof e == 'object' && e !== null) { if (typeof Object.getPrototypeOf == 'function') { const t = Object.getPrototypeOf(e); return t === Object.prototype || t === null } return Object.prototype.toString.call(e) === '[object Object]' } return !1 } function Wi(...e) {
  return e.reduce((t, r) => {
    if (Array.isArray(r))
      throw new TypeError('Arguments provided to deepmerge must be objects, not arrays.'); return Object.keys(r).forEach((o) => { ['__proto__', 'constructor', 'prototype'].includes(o) || (Array.isArray(t[o]) && Array.isArray(r[o]) ? t[o] = Wi.options.mergeArrays ? Array.from(new Set(t[o].concat(r[o]))) : r[o] : L0(t[o]) && L0(r[o]) ? t[o] = Wi(t[o], r[o]) : t[o] = r[o]) }), t
  }, {})
} const C1 = { mergeArrays: !0 }; Wi.options = C1; Wi.withOptions = (e, ...t) => { Wi.options = { mergeArrays: !0, ...e }; const r = Wi(...t); return Wi.options = C1, r }; function jge() { return { centering: { enabled: !0, strength: 0.1 }, charge: { enabled: !0, strength: -1 }, collision: { enabled: !0, strength: 1, radiusMultiplier: 2 }, link: { enabled: !0, strength: 1, length: 128 } } } function Gge() { return { includeUnlinked: !0, linkFilter: () => !0, nodeTypeFilter: void 0, showLinkLabels: !0, showNodeLabels: !0 } } function T1(e) { e.preventDefault(), e.stopPropagation() } function E1(e) { return typeof e == 'number' } function Qi(e, t) { return E1(e.nodeRadius) ? e.nodeRadius : e.nodeRadius(t) } function Kge(e) { return `${e.source.id}-${e.target.id}` } function L1(e) { return `link-arrow-${e}`.replace(/[()]/g, '~') } function Xge(e) { return `url(#${L1(e.color)})` } function Yge(e) { return { size: e, padding: (t, r) => Qi(r, t) + 2 * e, ref: [e / 2, e / 2], path: [[0, 0], [0, e], [e, e / 2]], viewBox: [0, 0, e, e].join(',') } } const A1 = { Arrow: e => Yge(e) }; const Zge = (e, t, r) => [t / 2, r / 2]; const M1 = (e, t, r) => [A0(0, t), A0(0, r)]; function A0(e, t) { return Math.random() * (t - e) + e } function Jge(e) { const t = Object.fromEntries(e.nodes.map(r => [r.id, [r.x, r.y]])); return (r, o, s) => { const [c, f] = t[r.id] ?? []; return !c || !f ? M1(r, o, s) : [c, f] } } const Jd = { Centered: Zge, Randomized: M1, Stable: Jge }; function Qge() { return { autoResize: !1, callbacks: {}, hooks: {}, initial: Gge(), nodeRadius: 16, marker: A1.Arrow(4), modifiers: {}, positionInitializer: Jd.Centered, simulation: { alphas: Vge(), forces: jge() }, zoom: { initial: 1, min: 0.1, max: 2 } } } function eve(e = {}) { return Wi.withOptions({ mergeArrays: !1 }, Qge(), e) } function tve({ applyZoom: e, container: t, onDoubleClick: r, onPointerMoved: o, onPointerUp: s, offset: [c, f], scale: d, zoom: h }) { const g = t.classed('graph', !0).append('svg').attr('height', '100%').attr('width', '100%').call(h).on('contextmenu', v => T1(v)).on('dblclick', v => r == null ? void 0 : r(v)).on('dblclick.zoom', null).on('pointermove', v => o == null ? void 0 : o(v)).on('pointerup', v => s == null ? void 0 : s(v)).style('cursor', 'grab'); return e && g.call(h.transform, rp.translate(c, f).scale(d)), g.append('g') } function nve({ canvas: e, scale: t, xOffset: r, yOffset: o }) { e == null || e.attr('transform', `translate(${r},${o})scale(${t})`) } function rve({ config: e, onDragStart: t, onDragEnd: r }) { let o, s; const c = whe().filter(f => f.type === 'mousedown' ? f.button === 0 : f.type === 'touchstart' ? f.touches.length === 1 : !1).on('start', (f, d) => { f.active === 0 && t(f, d), Pn(f.sourceEvent.target).classed('grabbed', !0), d.fx = d.x, d.fy = d.y }).on('drag', (f, d) => { d.fx = f.x, d.fy = f.y }).on('end', (f, d) => { f.active === 0 && r(f, d), Pn(f.sourceEvent.target).classed('grabbed', !1), d.fx = void 0, d.fy = void 0 }); return (s = (o = e.modifiers).drag) == null || s.call(o, c), c } function ive({ graph: e, filter: t, focusedNode: r, includeUnlinked: o, linkFilter: s }) { const c = e.links.filter(h => t.includes(h.source.type) && t.includes(h.target.type) && s(h)); const f = h => c.find(g => g.source.id === h.id || g.target.id === h.id) !== void 0; const d = e.nodes.filter(h => t.includes(h.type) && (o || f(h))); return r === void 0 || !t.includes(r.type) ? { nodes: d, links: c } : ove({ nodes: d, links: c }, r) } function ove(e, t) { const r = [...sve(e, t), ...lve(e, t)]; const o = r.flatMap(s => [s.source, s.target]); return { nodes: [...new Set([...o, t])], links: [...new Set(r)] } } function sve(e, t) { return N1(e, t, (r, o) => r.target.id === o.id) } function lve(e, t) { return N1(e, t, (r, o) => r.source.id === o.id) } function N1(e, t, r) {
  const o = new Set(e.links); const s = new Set([t]); const c = []; for (;o.size > 0;) {
    const f = [...o].filter(d => [...s].some(h => r(d, h))); if (f.length === 0)
      return c; f.forEach((d) => { s.add(d.source), s.add(d.target), c.push(d), o.delete(d) })
  } return c
} function Qd(e) { return e.x ?? 0 } function eh(e) { return e.y ?? 0 } function sp({ source: e, target: t }) { const r = new _n(Qd(e), eh(e)); const o = new _n(Qd(t), eh(t)); const s = o.subtract(r); const c = s.length(); const f = s.normalize(); const d = f.multiply(-1); return { s: r, t: o, dist: c, norm: f, endNorm: d } } function $1({ center: e, node: t }) { const r = new _n(Qd(t), eh(t)); let o = e; return r.x === o.x && r.y === o.y && (o = o.add(new _n(0, 1))), { n: r, c: o } } function O1({ config: e, source: t, target: r }) { const { s: o, t: s, norm: c } = sp({ config: e, source: t, target: r }); const f = o.add(c.multiply(Qi(e, t) - 1)); const d = s.subtract(c.multiply(e.marker.padding(r, e))); return { start: f, end: d } } function ave(e) {
  const { start: t, end: r } = O1(e); return `M${t.x},${t.y}
          L${r.x},${r.y}`
} function cve(e) { const { start: t, end: r } = O1(e); const o = r.subtract(t).multiply(0.5); const s = t.add(o); return `translate(${s.x - 8},${s.y - 4})` } function uve({ config: e, source: t, target: r }) {
  const { s: o, t: s, dist: c, norm: f, endNorm: d } = sp({ config: e, source: t, target: r }); const h = 10; const g = f.rotateByDegrees(-h).multiply(Qi(e, t) - 1).add(o); const v = d.rotateByDegrees(h).multiply(Qi(e, r)).add(s).add(d.rotateByDegrees(h).multiply(2 * e.marker.size)); const y = 1.2 * c; return `M${g.x},${g.y}
          A${y},${y},0,0,1,${v.x},${v.y}`
} function fve({ center: e, config: t, node: r }) {
  const { n: o, c: s } = $1({ center: e, config: t, node: r }); const c = Qi(t, r); const f = o.subtract(s); const d = f.multiply(1 / f.length()); const h = 40; const g = d.rotateByDegrees(h).multiply(c - 1).add(o); const v = d.rotateByDegrees(-h).multiply(c).add(o).add(d.rotateByDegrees(-h).multiply(2 * t.marker.size)); return `M${g.x},${g.y}
          A${c},${c},0,1,0,${v.x},${v.y}`
} function dve({ config: e, source: t, target: r }) { const { t: o, dist: s, endNorm: c } = sp({ config: e, source: t, target: r }); const f = c.rotateByDegrees(10).multiply(0.5 * s).add(o); return `translate(${f.x},${f.y})` } function hve({ center: e, config: t, node: r }) { const { n: o, c: s } = $1({ center: e, config: t, node: r }); const c = o.subtract(s); const f = c.multiply(1 / c.length()).multiply(3 * Qi(t, r) + 8).add(o); return `translate(${f.x},${f.y})` } const xs = { line: { labelTransform: cve, path: ave }, arc: { labelTransform: dve, path: uve }, reflexive: { labelTransform: hve, path: fve } }; function pve(e) { return e.append('g').classed('links', !0).selectAll('path') } function gve({ config: e, graph: t, selection: r, showLabels: o }) { const s = r == null ? void 0 : r.data(t.links, c => Kge(c)).join((c) => { let f, d, h, g; const v = c.append('g'); const y = v.append('path').classed('link', !0).style('marker-end', x => Xge(x)).style('stroke', x => x.color); (d = (f = e.modifiers).link) == null || d.call(f, y); const b = v.append('text').classed('link__label', !0).style('fill', x => x.label ? x.label.color : null).style('font-size', x => x.label ? x.label.fontSize : null).text(x => x.label ? x.label.text : null); return (g = (h = e.modifiers).linkLabel) == null || g.call(h, b), v }); return s == null || s.select('.link__label').attr('opacity', c => c.label && o ? 1 : 0), s } function vve(e) { mve(e), yve(e) } function mve({ center: e, config: t, graph: r, selection: o }) { o == null || o.selectAll('path').attr('d', s => s.source.x === void 0 || s.source.y === void 0 || s.target.x === void 0 || s.target.y === void 0 ? '' : s.source.id === s.target.id ? xs.reflexive.path({ config: t, node: s.source, center: e }) : P1(r, s.source, s.target) ? xs.arc.path({ config: t, source: s.source, target: s.target }) : xs.line.path({ config: t, source: s.source, target: s.target })) } function yve({ config: e, center: t, graph: r, selection: o }) { o == null || o.select('.link__label').attr('transform', s => s.source.x === void 0 || s.source.y === void 0 || s.target.x === void 0 || s.target.y === void 0 ? 'translate(0, 0)' : s.source.id === s.target.id ? xs.reflexive.labelTransform({ config: e, node: s.source, center: t }) : P1(r, s.source, s.target) ? xs.arc.labelTransform({ config: e, source: s.source, target: s.target }) : xs.line.labelTransform({ config: e, source: s.source, target: s.target })) } function P1(e, t, r) { return t.id !== r.id && e.links.some(o => o.target.id === t.id && o.source.id === r.id) && e.links.some(o => o.target.id === r.id && o.source.id === t.id) } function bve(e) { return e.append('defs').selectAll('marker') } function wve({ config: e, graph: t, selection: r }) { return r == null ? void 0 : r.data(xve(t), o => o).join((o) => { const s = o.append('marker').attr('id', c => L1(c)).attr('markerHeight', 4 * e.marker.size).attr('markerWidth', 4 * e.marker.size).attr('markerUnits', 'userSpaceOnUse').attr('orient', 'auto').attr('refX', e.marker.ref[0]).attr('refY', e.marker.ref[1]).attr('viewBox', e.marker.viewBox).style('fill', c => c); return s.append('path').attr('d', _ve(e.marker.path)), s }) } function xve(e) { return [...new Set(e.links.map(t => t.color))] } function _ve(e) {
  const [t, ...r] = e; if (!t)
    return 'M0,0'; const [o, s] = t; return r.reduce((c, [f, d]) => `${c}L${f},${d}`, `M${o},${s}`)
} function Sve(e) { return e.append('g').classed('nodes', !0).selectAll('circle') } function kve({ config: e, drag: t, graph: r, onNodeContext: o, onNodeSelected: s, selection: c, showLabels: f }) { const d = c == null ? void 0 : c.data(r.nodes, h => h.id).join((h) => { let g, v, y, b; const x = h.append('g'); t !== void 0 && x.call(t); const T = x.append('circle').classed('node', !0).attr('r', M => Qi(e, M)).on('contextmenu', (M, N) => { T1(M), o(N) }).on('pointerdown', (M, N) => Tve(M, N, s ?? o)).style('fill', M => M.color); (v = (g = e.modifiers).node) == null || v.call(g, T); const E = x.append('text').classed('node__label', !0).attr('dy', '0.33em').style('fill', M => M.label ? M.label.color : null).style('font-size', M => M.label ? M.label.fontSize : null).style('stroke', 'none').text(M => M.label ? M.label.text : null); return (b = (y = e.modifiers).nodeLabel) == null || b.call(y, E), x }); return d == null || d.select('.node').classed('focused', h => h.isFocused), d == null || d.select('.node__label').attr('opacity', f ? 1 : 0), d } const Cve = 500; function Tve(e, t, r) {
  if (e.button !== void 0 && e.button !== 0)
    return; const o = t.lastInteractionTimestamp; const s = Date.now(); if (o === void 0 || s - o > Cve) { t.lastInteractionTimestamp = s; return }t.lastInteractionTimestamp = void 0, r(t)
} function Eve(e) { e == null || e.attr('transform', t => `translate(${t.x ?? 0},${t.y ?? 0})`) } function Lve({ center: e, config: t, graph: r, onTick: o }) { let s, c; const f = Fge(r.nodes); const d = t.simulation.forces.centering; if (d && d.enabled) { const y = d.strength; f.force('x', qge(() => e().x).strength(y)).force('y', Bge(() => e().y).strength(y)) } const h = t.simulation.forces.charge; h && h.enabled && f.force('charge', Hge().strength(h.strength)); const g = t.simulation.forces.collision; g && g.enabled && f.force('collision', Age().radius(y => g.radiusMultiplier * Qi(t, y))); const v = t.simulation.forces.link; return v && v.enabled && f.force('link', Nge(r.links).id(y => y.id).distance(t.simulation.forces.link.length).strength(v.strength)), f.on('tick', () => o()), (c = (s = t.modifiers).simulation) == null || c.call(s, f), f } function Ave({ canvasContainer: e, config: t, min: r, max: o, onZoom: s }) { let c, f; const d = uge().scaleExtent([r, o]).filter((h) => { let g; return h.button === 0 || ((g = h.touches) == null ? void 0 : g.length) >= 2 }).on('start', () => e().classed('grabbed', !0)).on('zoom', h => s(h)).on('end', () => e().classed('grabbed', !1)); return (f = (c = t.modifiers).zoom) == null || f.call(c, d), d } class Mve {
  constructor(t, r, o) { if (Dt(this, 'nodeTypes'), Dt(this, '_nodeTypeFilter'), Dt(this, '_includeUnlinked', !0), Dt(this, '_linkFilter', () => !0), Dt(this, '_showLinkLabels', !0), Dt(this, '_showNodeLabels', !0), Dt(this, 'filteredGraph'), Dt(this, 'width', 0), Dt(this, 'height', 0), Dt(this, 'simulation'), Dt(this, 'canvas'), Dt(this, 'linkSelection'), Dt(this, 'nodeSelection'), Dt(this, 'markerSelection'), Dt(this, 'zoom'), Dt(this, 'drag'), Dt(this, 'xOffset', 0), Dt(this, 'yOffset', 0), Dt(this, 'scale'), Dt(this, 'focusedNode'), Dt(this, 'resizeObserver'), this.container = t, this.graph = r, this.config = o, this.scale = o.zoom.initial, this.resetView(), this.graph.nodes.forEach((s) => { const [c, f] = o.positionInitializer(s, this.effectiveWidth, this.effectiveHeight); s.x = s.x ?? c, s.y = s.y ?? f }), this.nodeTypes = [...new Set(r.nodes.map(s => s.type))], this._nodeTypeFilter = [...this.nodeTypes], o.initial) { const { includeUnlinked: s, nodeTypeFilter: c, linkFilter: f, showLinkLabels: d, showNodeLabels: h } = o.initial; this._includeUnlinked = s ?? this._includeUnlinked, this._showLinkLabels = d ?? this._showLinkLabels, this._showNodeLabels = h ?? this._showNodeLabels, this._nodeTypeFilter = c ?? this._nodeTypeFilter, this._linkFilter = f ?? this._linkFilter } this.filterGraph(void 0), this.initGraph(), this.restart(o.simulation.alphas.initialize), o.autoResize && (this.resizeObserver = new ResizeObserver($fe(() => this.resize())), this.resizeObserver.observe(this.container)) } get nodeTypeFilter() { return this._nodeTypeFilter } get includeUnlinked() { return this._includeUnlinked } set includeUnlinked(t) { this._includeUnlinked = t, this.filterGraph(this.focusedNode); const { include: r, exclude: o } = this.config.simulation.alphas.filter.unlinked; const s = t ? r : o; this.restart(s) } set linkFilter(t) { this._linkFilter = t, this.filterGraph(this.focusedNode), this.restart(this.config.simulation.alphas.filter.link) } get linkFilter() { return this._linkFilter } get showNodeLabels() { return this._showNodeLabels } set showNodeLabels(t) { this._showNodeLabels = t; const { hide: r, show: o } = this.config.simulation.alphas.labels.nodes; const s = t ? o : r; this.restart(s) } get showLinkLabels() { return this._showLinkLabels } set showLinkLabels(t) { this._showLinkLabels = t; const { hide: r, show: o } = this.config.simulation.alphas.labels.links; const s = t ? o : r; this.restart(s) } get effectiveWidth() { return this.width / this.scale } get effectiveHeight() { return this.height / this.scale } get effectiveCenter() { return _n.of([this.width, this.height]).divide(2).subtract(_n.of([this.xOffset, this.yOffset])).divide(this.scale) }resize() {
    const t = this.width; const r = this.height; const o = this.container.getBoundingClientRect().width; const s = this.container.getBoundingClientRect().height; const c = t.toFixed() !== o.toFixed(); const f = r.toFixed() !== s.toFixed(); if (!c && !f)
      return; this.width = this.container.getBoundingClientRect().width, this.height = this.container.getBoundingClientRect().height; const d = this.config.simulation.alphas.resize; this.restart(E1(d) ? d : d({ oldWidth: t, oldHeight: r, newWidth: o, newHeight: s }))
  }

  restart(t) { let r; this.markerSelection = wve({ config: this.config, graph: this.filteredGraph, selection: this.markerSelection }), this.linkSelection = gve({ config: this.config, graph: this.filteredGraph, selection: this.linkSelection, showLabels: this._showLinkLabels }), this.nodeSelection = kve({ config: this.config, drag: this.drag, graph: this.filteredGraph, onNodeContext: o => this.toggleNodeFocus(o), onNodeSelected: this.config.callbacks.nodeClicked, selection: this.nodeSelection, showLabels: this._showNodeLabels }), (r = this.simulation) == null || r.stop(), this.simulation = Lve({ center: () => this.effectiveCenter, config: this.config, graph: this.filteredGraph, onTick: () => this.onTick() }).alpha(t).restart() }filterNodesByType(t, r) { t ? this._nodeTypeFilter.push(r) : this._nodeTypeFilter = this._nodeTypeFilter.filter(o => o !== r), this.filterGraph(this.focusedNode), this.restart(this.config.simulation.alphas.filter.type) }shutdown() { let t, r; this.focusedNode !== void 0 && (this.focusedNode.isFocused = !1, this.focusedNode = void 0), (t = this.resizeObserver) == null || t.unobserve(this.container), (r = this.simulation) == null || r.stop() }initGraph() { this.zoom = Ave({ config: this.config, canvasContainer: () => Pn(this.container).select('svg'), min: this.config.zoom.min, max: this.config.zoom.max, onZoom: t => this.onZoom(t) }), this.canvas = tve({ applyZoom: this.scale !== 1, container: Pn(this.container), offset: [this.xOffset, this.yOffset], scale: this.scale, zoom: this.zoom }), this.applyZoom(), this.linkSelection = pve(this.canvas), this.nodeSelection = Sve(this.canvas), this.markerSelection = bve(this.canvas), this.drag = rve({ config: this.config, onDragStart: () => { let t; return (t = this.simulation) == null ? void 0 : t.alphaTarget(this.config.simulation.alphas.drag.start).restart() }, onDragEnd: () => { let t; return (t = this.simulation) == null ? void 0 : t.alphaTarget(this.config.simulation.alphas.drag.end).restart() } }) }onTick() { Eve(this.nodeSelection), vve({ config: this.config, center: this.effectiveCenter, graph: this.filteredGraph, selection: this.linkSelection }) }resetView() { let t; (t = this.simulation) == null || t.stop(), Pn(this.container).selectChildren().remove(), this.zoom = void 0, this.canvas = void 0, this.linkSelection = void 0, this.nodeSelection = void 0, this.markerSelection = void 0, this.simulation = void 0, this.width = this.container.getBoundingClientRect().width, this.height = this.container.getBoundingClientRect().height }onZoom(t) { let r, o, s; this.xOffset = t.transform.x, this.yOffset = t.transform.y, this.scale = t.transform.k, this.applyZoom(), (o = (r = this.config.hooks).afterZoom) == null || o.call(r, this.scale, this.xOffset, this.yOffset), (s = this.simulation) == null || s.restart() }applyZoom() { nve({ canvas: this.canvas, scale: this.scale, xOffset: this.xOffset, yOffset: this.yOffset }) }toggleNodeFocus(t) { t.isFocused ? (this.filterGraph(void 0), this.restart(this.config.simulation.alphas.focus.release(t))) : this.focusNode(t) }focusNode(t) { this.filterGraph(t), this.restart(this.config.simulation.alphas.focus.acquire(t)) }filterGraph(t) { this.focusedNode !== void 0 && (this.focusedNode.isFocused = !1, this.focusedNode = void 0), t !== void 0 && this._nodeTypeFilter.includes(t.type) && (t.isFocused = !0, this.focusedNode = t), this.filteredGraph = ive({ graph: this.graph, filter: this._nodeTypeFilter, focusedNode: this.focusedNode, includeUnlinked: this._includeUnlinked, linkFilter: this._linkFilter }) }
} function M0({ nodes: e, links: t }) { return { nodes: e ?? [], links: t ?? [] } } function Nve(e) { return { ...e } } function R1(e) { return { ...e, isFocused: !1, lastInteractionTimestamp: void 0 } } const $ve = { 'h-full': '', 'min-h-75': '', 'flex-1': '', 'overflow': 'hidden' }; const Ove = { 'flex': '', 'items-center': '', 'gap-4': '', 'px-3': '', 'py-2': '' }; const Pve = ['id', 'checked', 'onChange']; const Rve = ['for']; const Dve = Y('div', { 'flex-auto': '' }, null, -1); const zve = ft({ __name: 'ViewModuleGraph', props: { graph: {}, projectName: {} }, setup(e) {
  const t = e; const { graph: r } = LS(t); const o = Be(); const s = Be(!1); const c = Be(); const f = Be(); Ch(() => { s.value === !1 && setTimeout(() => c.value = void 0, 300) }, { flush: 'post' }), Os(() => { g() }), bu(() => { let y; (y = f.value) == null || y.shutdown() }), Ht(r, g); function d(y, b) { let x; (x = f.value) == null || x.filterNodesByType(b, y) } function h(y) { c.value = y, s.value = !0 } function g() { let y; (y = f.value) == null || y.shutdown(), !(!r.value || !o.value) && (f.value = new Mve(o.value, r.value, eve({ nodeRadius: 10, autoResize: !0, simulation: { alphas: { initialize: 1, resize: ({ newHeight: b, newWidth: x }) => b === 0 && x === 0 ? 0 : 0.25 }, forces: { collision: { radiusMultiplier: 10 }, link: { length: 240 } } }, marker: A1.Arrow(2), modifiers: { node: v }, positionInitializer: r.value.nodes.length > 1 ? Jd.Randomized : Jd.Centered, zoom: { min: 0.5, max: 2 } }))) } function v(y) {
    if (Pr)
      return; const b = M => M.button === 0; let x = 0; let T = 0; let E = 0; y.on('pointerdown', (M, N) => { N.type !== 'external' && (!N.x || !N.y || !b(M) || (x = N.x, T = N.y, E = Date.now())) }).on('pointerup', (M, N) => {
      if (N.type === 'external' || !N.x || !N.y || !b(M) || Date.now() - E > 500)
        return; const L = N.x - x; const O = N.y - T; L ** 2 + O ** 2 < 100 && h(N.id)
    })
  } return (y, b) => { let N; const x = hi; const T = Nfe; const E = Xw; const M = Hr('tooltip'); return oe(), me('div', $ve, [Y('div', null, [Y('div', Ove, [(oe(!0), me(ut, null, si((N = q(f)) == null ? void 0 : N.nodeTypes.sort(), (L) => { let O; return oe(), me('div', { 'key': L, 'flex': '~ gap-1', 'items-center': '', 'select-none': '' }, [Y('input', { id: `type-${L}`, type: 'checkbox', checked: (O = q(f)) == null ? void 0 : O.nodeTypeFilter.includes(L), onChange: A => d(L, A.target.checked) }, null, 40, Pve), Y('label', { 'font-light': '', 'text-sm': '', 'ws-nowrap': '', 'overflow-hidden': '', 'capitalize': '', 'truncate': '', 'for': `type-${L}`, 'border-b-2': '', 'style': Zt({ 'border-color': `var(--color-node-${L})` }) }, `${qe(L)} Modules`, 13, Rve)]) }), 128)), Dve, Y('div', null, [_t(Oe(x, { icon: 'i-carbon-reset', onClick: g }, null, 512), [[M, 'Reset', void 0, { bottom: !0 }]])])])]), Y('div', { ref_key: 'el', ref: o }, null, 512), Oe(E, { 'modelValue': q(s), 'onUpdate:modelValue': b[1] || (b[1] = L => Ot(s) ? s.value = L : null), 'direction': 'right' }, { default: st(() => [q(c) ? (oe(), ot(zy, { key: 0 }, { default: st(() => [Oe(T, { 'id': q(c), 'project-name': y.projectName, 'onClose': b[0] || (b[0] = L => s.value = !1) }, null, 8, ['id', 'project-name'])]), _: 1 })) : et('', !0)]), _: 1 }, 8, ['modelValue'])]) }
} }); const Ive = { 'key': 0, 'text-green-500': '', 'flex-shrink-0': '', 'i-carbon:checkmark': '' }; const Fve = { 'key': 1, 'text-red-500': '', 'flex-shrink-0': '', 'i-carbon:compare': '' }; const Hve = { 'key': 2, 'text-red-500': '', 'flex-shrink-0': '', 'i-carbon:close': '' }; const qve = { 'key': 3, 'text-gray-500': '', 'flex-shrink-0': '', 'i-carbon:document-blank': '' }; const Bve = { 'key': 4, 'text-gray-500': '', 'flex-shrink-0': '', 'i-carbon:redo': '', 'rotate-90': '' }; const Wve = { 'key': 5, 'text-yellow-500': '', 'flex-shrink-0': '', 'i-carbon:circle-dash': '', 'animate-spin': '' }; const D1 = ft({ __name: 'StatusIcon', props: { state: {}, mode: {}, failedSnapshot: { type: Boolean } }, setup(e) { return (t, r) => { const o = Hr('tooltip'); return t.state === 'pass' ? (oe(), me('div', Ive)) : t.failedSnapshot ? _t((oe(), me('div', Fve, null, 512)), [[o, 'Contains failed snapshot', void 0, { right: !0 }]]) : t.state === 'fail' ? (oe(), me('div', Hve)) : t.mode === 'todo' ? _t((oe(), me('div', qve, null, 512)), [[o, 'Todo', void 0, { right: !0 }]]) : t.mode === 'skip' || t.state === 'skip' ? _t((oe(), me('div', Bve, null, 512)), [[o, 'Skipped', void 0, { right: !0 }]]) : (oe(), me('div', Wve)) } } }); function Uve(e) {
  const t = new Map(); const r = new Map(); const o = []; for (;;) {
    let s = 0; if (e.forEach((c, f) => { let v; const { splits: d, finished: h } = c; if (h) { s++; const { raw: y, candidate: b } = c; t.set(y, b); return } if (d.length === 0) { c.finished = !0; return } const g = d[0]; r.has(g) ? (c.candidate += c.candidate === '' ? g : `/${g}`, (v = r.get(g)) == null || v.push(f), d.shift()) : (r.set(g, [f]), o.push(f)) }), o.forEach((c) => { const f = e[c]; const d = f.splits.shift(); f.candidate += f.candidate === '' ? d : `/${d}` }), r.forEach((c) => { if (c.length === 1) { const f = c[0]; e[f].finished = !0 } }), r.clear(), o.length = 0, s === e.length)
      break
  } return t
} function Vve(e) { let t = e; t.includes('/node_modules/') && (t = e.split(/\/node_modules\//g).pop()); const r = t.split(/\//g); return { raw: t, splits: r, candidate: '', finished: !1, id: e } } function jve(e) { const t = e.map(o => Vve(o)); const r = Uve(t); return t.map(({ raw: o, id: s }) => R1({ color: 'var(--color-node-external)', label: { color: 'var(--color-node-external)', fontSize: '0.875rem', text: r.get(o) ?? '' }, isFocused: !1, id: s, type: 'external' })) } function Gve(e, t) { return R1({ color: t ? 'var(--color-node-root)' : 'var(--color-node-inline)', label: { color: t ? 'var(--color-node-root)' : 'var(--color-node-inline)', fontSize: '0.875rem', text: e.split(/\//g).pop() }, isFocused: !1, id: e, type: 'inline' }) } function Kve(e, t) {
  if (!e)
    return M0({}); const r = jve(e.externalized); const o = e.inlined.map(d => Gve(d, d === t)) ?? []; const s = [...r, ...o]; const c = Object.fromEntries(s.map(d => [d.id, d])); const f = Object.entries(e.graph).flatMap(([d, h]) => h.map((g) => {
    const v = c[d]; const y = c[g]; if (!(v === void 0 || y === void 0))
      return Nve({ source: v, target: y, color: 'var(--color-link)', label: !1 })
  }).filter(g => g !== void 0)); return M0({ nodes: s, links: f })
} const Xve = { 'key': 0, 'flex': '', 'flex-col': '', 'h-full': '', 'max-h-full': '', 'overflow-hidden': '', 'data-testid': 'file-detail' }; const Yve = { 'p': '2', 'h-10': '', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b base' }; const Zve = { 'flex-1': '', 'font-light': '', 'op-50': '', 'ws-nowrap': '', 'truncate': '', 'text-sm': '' }; const Jve = { class: 'flex text-lg' }; const Qve = { 'flex': '~', 'items-center': '', 'bg-header': '', 'border': 'b-2 base', 'text-sm': '', 'h-41px': '' }; const eme = Y('span', { class: 'block w-1.4em h-1.4em i-carbon:report' }, null, -1); const tme = { key: 0, class: 'block w-1.4em h-1.4em i-carbon:circle-dash animate-spin animate-2s' }; const nme = { key: 1, class: 'block w-1.4em h-1.4em i-carbon:chart-relationship' }; const rme = Y('span', { class: 'block w-1.4em h-1.4em i-carbon:code' }, null, -1); const ime = Y('span', { class: 'block w-1.4em h-1.4em i-carbon:terminal-3270' }, null, -1); const ome = { 'flex': '', 'flex-col': '', 'flex-1': '', 'overflow': 'hidden' }; const sme = ['flex-1']; const lme = ft({ __name: 'FileDetails', setup(e) {
  const t = Be({ nodes: [], links: [] }); const r = Be(!1); const o = Be(!1); const s = Be(!1); const c = Be(void 0); const f = Me(() => {
    const x = Xt.value; if (!(!x || !x.filepath))
      return { filepath: x.filepath, projectName: x.file.projectName || '' }
  }); const d = Me(() => Xt.value && Fh(Xt.value)); function h() { let T; const x = (T = Xt.value) == null ? void 0 : T.filepath; x && fetch(`/__open-in-editor?file=${encodeURIComponent(x)}`) } function g(x) { x === 'graph' && (o.value = !0), Bn.value = x } const v = Me(() => { let x; return ((x = jw.value) == null ? void 0 : x.reduce((T, { size: E }) => T + E, 0)) ?? 0 }); function y(x) { r.value = x } async function b() {
    let x; if (!(s.value || ((x = f.value) == null ? void 0 : x.filepath) === c.value)) {
      s.value = !0, await ln(); try {
        const T = f.value; if (!T)
          return; (!c.value || T.filepath !== c.value || !t.value.nodes.length && !t.value.links.length) && (t.value = Kve(await yt.rpc.getModuleGraph(T.projectName, T.filepath, !!No), T.filepath), c.value = T.filepath), g('graph')
      }
      finally { await new Promise(T => setTimeout(T, 100)), s.value = !1 }
    }
  } return xw(() => [f.value, Bn.value], ([,x]) => { x === 'graph' && b() }, { debounce: 100, immediate: !0 }), (x, T) => { let z, J, re, te, j, ne; const E = D1; const M = hi; const N = zve; const L = wfe; const O = ffe; const A = ife; const H = Hr('tooltip'); return q(Xt) ? (oe(), me('div', Xve, [Y('div', null, [Y('div', Yve, [Oe(E, { 'state': (z = q(Xt).result) == null ? void 0 : z.state, 'mode': q(Xt).mode, 'failed-snapshot': q(d) }, null, 8, ['state', 'mode', 'failed-snapshot']), (J = q(Xt)) != null && J.file.projectName ? (oe(), me('div', { 'key': 0, 'font-light': '', 'op-50': '', 'text-sm': '', 'style': Zt({ color: q(Iw)((re = q(Xt)) == null ? void 0 : re.file.projectName) }) }, ` [${qe(((te = q(Xt)) == null ? void 0 : te.file.projectName) || '')}] `, 5)) : et('', !0), Y('div', Zve, qe((j = q(Xt)) == null ? void 0 : j.name), 1), Y('div', Jve, [q(Pr) ? et('', !0) : _t((oe(), ot(M, { key: 0, title: 'Open in editor', icon: 'i-carbon-launch', disabled: !((ne = q(Xt)) != null && ne.filepath), onClick: h }, null, 8, ['disabled'])), [[H, 'Open in editor', void 0, { bottom: !0 }]])])]), Y('div', Qve, [Y('button', { 'tab-button': '', 'class': lt(['flex items-center gap-2', { 'tab-button-active': q(Bn) == null }]), 'data-testid': 'btn-report', 'onClick': T[0] || (T[0] = K => g(null)) }, [eme, gt(' Report ')], 2), Y('button', { 'tab-button': '', 'data-testid': 'btn-graph', 'class': lt(['flex items-center gap-2', { 'tab-button-active': q(Bn) === 'graph' }]), 'onClick': T[1] || (T[1] = K => g('graph')) }, [q(s) ? (oe(), me('span', tme)) : (oe(), me('span', nme)), gt(' Module Graph ')], 2), Y('button', { 'tab-button': '', 'data-testid': 'btn-code', 'class': lt(['flex items-center gap-2', { 'tab-button-active': q(Bn) === 'editor' }]), 'onClick': T[2] || (T[2] = K => g('editor')) }, [rme, gt(` ${qe(q(r) ? '*' : '')}Code `, 1)], 2), Y('button', { 'tab-button': '', 'data-testid': 'btn-console', 'class': lt(['flex items-center gap-2', { 'tab-button-active': q(Bn) === 'console', 'op20': q(Bn) !== 'console' && q(v) === 0 }]), 'onClick': T[3] || (T[3] = K => g('console')) }, [ime, gt(` Console (${qe(q(v))}) `, 1)], 2)])]), Y('div', ome, [q(o) ? (oe(), me('div', { 'key': 0, 'flex-1': q(Bn) === 'graph' && '' }, [_t(Oe(N, { 'graph': q(t), 'data-testid': 'graph', 'project-name': q(Xt).file.projectName || '' }, null, 8, ['graph', 'project-name']), [[bl, q(Bn) === 'graph' && !q(s)]])], 8, sme)) : et('', !0), q(Bn) === 'editor' ? (oe(), ot(L, { 'key': q(Xt).filepath, 'file': q(Xt), 'data-testid': 'editor', 'onDraft': y }, null, 8, ['file'])) : q(Bn) === 'console' ? (oe(), ot(O, { 'key': 2, 'file': q(Xt), 'data-testid': 'console' }, null, 8, ['file'])) : q(Bn) ? et('', !0) : (oe(), ot(A, { 'key': 3, 'file': q(Xt), 'data-testid': 'report' }, null, 8, ['file']))])])) : et('', !0) }
} }); const ame = { h: 'full', flex: '~ col' }; const cme = Y('div', { 'p': '3', 'h-10': '', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b base' }, [Y('div', { class: 'i-carbon:folder-details-reference' }), Y('span', { 'pl-1': '', 'font-bold': '', 'text-sm': '', 'flex-auto': '', 'ws-nowrap': '', 'overflow-hidden': '', 'truncate': '' }, 'Coverage')], -1); const ume = { 'flex-auto': '', 'py-1': '', 'bg-white': '' }; const fme = ['src']; const dme = ft({ __name: 'Coverage', props: { src: {} }, setup(e) { return (t, r) => (oe(), me('div', ame, [cme, Y('div', ume, [Y('iframe', { id: 'vitest-ui-coverage', src: t.src }, null, 8, fme)])])) } }); const hme = { 'bg': 'red500/10', 'p-1': '', 'mb-1': '', 'mt-2': '', 'rounded': '' }; const pme = { 'font-bold': '' }; const gme = { 'key': 0, 'class': 'scrolls', 'text': 'xs', 'font-mono': '', 'mx-1': '', 'my-2': '', 'pb-2': '', 'overflow-auto': '' }; const vme = ['font-bold']; const mme = { text: 'red500/70' }; const yme = Y('br', null, null, -1); const bme = { 'key': 1, 'text': 'sm', 'mb-2': '' }; const wme = { 'font-bold': '' }; const xme = { 'key': 2, 'text': 'sm', 'mb-2': '' }; const _me = { 'font-bold': '' }; const Sme = Y('br', null, null, -1); const kme = Y('ul', null, [Y('li', null, ' The error was thrown, while Vitest was running this test. '), Y('li', null, ' If the error occurred after the test had been completed, this was the last documented test before it was thrown. ')], -1); const Cme = { 'key': 3, 'text': 'sm', 'font-thin': '' }; const Tme = Y('br', null, null, -1); const Eme = Y('ul', null, [Y('li', null, ' Cancel timeouts using clearTimeout and clearInterval. '), Y('li', null, ' Wait for promises to resolve using the await keyword. ')], -1); const Lme = ft({ __name: 'ErrorEntry', props: { error: {} }, setup(e) { return (t, r) => { let o; return oe(), me(ut, null, [Y('h4', hme, [Y('span', pme, [gt(qe(t.error.name || t.error.nameStr || 'Unknown Error'), 1), t.error.message ? (oe(), me(ut, { key: 0 }, [gt(':')], 64)) : et('', !0)]), gt(` ${qe(t.error.message)}`, 1)]), (o = t.error.stacks) != null && o.length ? (oe(), me('p', gme, [(oe(!0), me(ut, null, si(t.error.stacks, (s, c) => (oe(), me('span', { 'key': c, 'whitespace-pre': '', 'font-bold': c === 0 ? '' : null }, [gt(` ${qe(s.method)} ${qe(s.file)}:`, 1), Y('span', mme, `${qe(s.line)}:${qe(s.column)}`, 1), yme], 8, vme))), 128))])) : et('', !0), t.error.VITEST_TEST_PATH ? (oe(), me('p', bme, [gt(' This error originated in '), Y('span', wme, qe(t.error.VITEST_TEST_PATH), 1), gt(' test file. It doesn\'t mean the error was thrown inside the file itself, but while it was running. ')])) : et('', !0), t.error.VITEST_TEST_NAME ? (oe(), me('p', xme, [gt(' The latest test that might\'ve caused the error is '), Y('span', _me, qe(t.error.VITEST_TEST_NAME), 1), gt('. It might mean one of the following:'), Sme, kme])) : et('', !0), t.error.VITEST_AFTER_ENV_TEARDOWN ? (oe(), me('p', Cme, [gt(' This error was caught after test environment was torn down. Make sure to cancel any running tasks before test finishes:'), Tme, Eme])) : et('', !0)], 64) } } }); const En = e => (la('data-v-0178ddee'), e = e(), aa(), e); const Ame = { 'data-testid': 'test-files-entry', 'grid': '~ cols-[min-content_1fr_min-content]', 'items-center': '', 'gap': 'x-2 y-3', 'p': 'x4', 'relative': '', 'font-light': '', 'w-80': '', 'op80': '' }; const Mme = En(() => Y('div', { 'i-carbon-document': '' }, null, -1)); const Nme = En(() => Y('div', null, 'Files', -1)); const $me = { 'class': 'number', 'data-testid': 'num-files' }; const Ome = En(() => Y('div', { 'i-carbon-checkmark': '' }, null, -1)); const Pme = En(() => Y('div', null, 'Pass', -1)); const Rme = { class: 'number' }; const Dme = En(() => Y('div', { 'i-carbon-close': '' }, null, -1)); const zme = En(() => Y('div', null, ' Fail ', -1)); const Ime = { 'class': 'number', 'text-red5': '' }; const Fme = En(() => Y('div', { 'i-carbon-compare': '' }, null, -1)); const Hme = En(() => Y('div', null, ' Snapshot Fail ', -1)); const qme = { 'class': 'number', 'text-red5': '' }; const Bme = En(() => Y('div', { 'i-carbon-checkmark-outline-error': '' }, null, -1)); const Wme = En(() => Y('div', null, ' Errors ', -1)); const Ume = { 'class': 'number', 'text-red5': '' }; const Vme = En(() => Y('div', { 'i-carbon-timer': '' }, null, -1)); const jme = En(() => Y('div', null, 'Time', -1)); const Gme = { 'class': 'number', 'data-testid': 'run-time' }; const Kme = { 'key': 0, 'bg': 'red500/10', 'text': 'red500', 'p': 'x3 y2', 'max-w-xl': '', 'm-2': '', 'rounded': '' }; const Xme = En(() => Y('h3', { 'text-center': '', 'mb-2': '' }, ' Unhandled Errors ', -1)); const Yme = { 'text': 'sm', 'font-thin': '', 'mb-2': '', 'data-testid': 'unhandled-errors' }; const Zme = En(() => Y('br', null, null, -1)); const Jme = { 'data-testid': 'unhandled-errors-details', 'class': 'scrolls unhandled-errors', 'text': 'sm', 'font-thin': '', 'pe-2.5': '', 'open:max-h-52': '', 'overflow-auto': '' }; const Qme = En(() => Y('summary', { 'font-bold': '', 'cursor-pointer': '' }, ' Errors ', -1)); const e0e = ft({ __name: 'TestFilesEntry', setup(e) { return (t, r) => { const o = Lme; return oe(), me(ut, null, [Y('div', Ame, [Mme, Nme, Y('div', $me, qe(q(Ce).summary.files), 1), q(Ce).summary.filesSuccess ? (oe(), me(ut, { key: 0 }, [Ome, Pme, Y('div', Rme, qe(q(Ce).summary.filesSuccess), 1)], 64)) : et('', !0), q(Ce).summary.filesFailed ? (oe(), me(ut, { key: 1 }, [Dme, zme, Y('div', Ime, qe(q(Ce).summary.filesFailed), 1)], 64)) : et('', !0), q(Ce).summary.filesSnapshotFailed ? (oe(), me(ut, { key: 2 }, [Fme, Hme, Y('div', qme, qe(q(Ce).summary.filesSnapshotFailed), 1)], 64)) : et('', !0), q(Ii).length ? (oe(), me(ut, { key: 3 }, [Bme, Wme, Y('div', Ume, qe(q(Ii).length), 1)], 64)) : et('', !0), Vme, jme, Y('div', Gme, qe(q(Ce).summary.time), 1)]), q(Ii).length ? (oe(), me('div', Kme, [Xme, Y('p', Yme, [gt(` Vitest caught ${qe(q(Ii).length)} error${qe(q(Ii).length > 1 ? 's' : '')} during the test run.`, 1), Zme, gt(' This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected. ')]), Y('details', Jme, [Qme, (oe(!0), me(ut, null, si(q(Ii), (s, c) => (oe(), ot(o, { key: c, error: s }, null, 8, ['error']))), 128))])])) : et('', !0)], 64) } } }); const t0e = di(e0e, [['__scopeId', 'data-v-0178ddee']]); const n0e = { 'p-2': '', 'text-center': '', 'flex': '' }; const r0e = { 'text-4xl': '', 'min-w-2em': '' }; const i0e = { 'text-md': '' }; const o0e = ft({ __name: 'DashboardEntry', setup(e) { return (t, r) => (oe(), me('div', n0e, [Y('div', null, [Y('div', r0e, [dn(t.$slots, 'body')]), Y('div', i0e, [dn(t.$slots, 'header')])])])) } }); const s0e = { 'flex': '~ wrap', 'justify-evenly': '', 'gap-2': '', 'p': 'x-4', 'relative': '' }; const l0e = ft({ __name: 'TestsEntry', setup(e) { return (t, r) => { const o = o0e; return oe(), me('div', s0e, [Oe(o, { 'text-green5': '', 'data-testid': 'pass-entry' }, { header: st(() => [gt(' Pass ')]), body: st(() => [gt(qe(q(Ce).summary.testsSuccess), 1)]), _: 1 }), Oe(o, { 'class': lt({ 'text-red5': q(Ce).summary.testsFailed, 'op50': !q(Ce).summary.testsFailed }), 'data-testid': 'fail-entry' }, { header: st(() => [gt(' Fail ')]), body: st(() => [gt(qe(q(Ce).summary.testsFailed), 1)]), _: 1 }, 8, ['class']), q(Ce).summary.testsSkipped ? (oe(), ot(o, { 'key': 0, 'op50': '', 'data-testid': 'skipped-entry' }, { header: st(() => [gt(' Skip ')]), body: st(() => [gt(qe(q(Ce).summary.testsSkipped), 1)]), _: 1 })) : et('', !0), q(Ce).summary.testsTodo ? (oe(), ot(o, { 'key': 1, 'op50': '', 'data-testid': 'todo-entry' }, { header: st(() => [gt(' Todo ')]), body: st(() => [gt(qe(q(Ce).summary.testsTodo), 1)]), _: 1 })) : et('', !0), Oe(o, { 'tail': !0, 'data-testid': 'total-entry' }, { header: st(() => [gt(' Total ')]), body: st(() => [gt(qe(q(Ce).summary.totalTests), 1)]), _: 1 })]) } } }); const a0e = {}; const c0e = { 'gap-0': '', 'flex': '~ col gap-4', 'h-full': '', 'justify-center': '', 'items-center': '' }; const u0e = { 'aria-labelledby': 'tests', 'm': 'y-4 x-2' }; function f0e(e, t) { const r = l0e; const o = t0e; return oe(), me('div', c0e, [Y('section', u0e, [Oe(r)]), Oe(o)]) } const d0e = di(a0e, [['render', f0e]]); const h0e = {}; const p0e = { h: 'full', flex: '~ col' }; const g0e = Y('div', { 'p': '3', 'h-10': '', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b base' }, [Y('div', { class: 'i-carbon-dashboard' }), Y('span', { 'pl-1': '', 'font-bold': '', 'text-sm': '', 'flex-auto': '', 'ws-nowrap': '', 'overflow-hidden': '', 'truncate': '' }, 'Dashboard')], -1); const v0e = { 'class': 'scrolls', 'flex-auto': '', 'py-1': '' }; function m0e(e, t) { const r = d0e; return oe(), me('div', p0e, [g0e, Y('div', v0e, [Oe(r)])]) } const y0e = di(h0e, [['render', m0e]]); const b0e = ['open']; const w0e = Y('div', { 'flex-1': '', 'h-1px': '', 'border': 'base b', 'op80': '' }, null, -1); const x0e = Y('div', { 'flex-1': '', 'h-1px': '', 'border': 'base b', 'op80': '' }, null, -1); const _0e = ft({ __name: 'DetailsPanel', props: { color: {} }, setup(e) { const t = Be(!0); return (r, o) => (oe(), me('div', { 'open': q(t), 'class': 'details-panel', 'data-testid': 'details-panel', 'onToggle': o[0] || (o[0] = s => t.value = s.target.open) }, [Y('div', { 'p': 'y1', 'text-sm': '', 'bg-base': '', 'items-center': '', 'z-5': '', 'gap-2': '', 'class': lt(r.color), 'w-full': '', 'flex': '', 'select-none': '', 'sticky': '', 'top': '-1' }, [w0e, dn(r.$slots, 'summary', { open: q(t) }), x0e], 2), dn(r.$slots, 'default')], 40, b0e)) } }); const S0e = { 'type': 'button', 'dark': 'op75', 'bg': 'gray-200 dark:#111', 'hover': 'op100', 'rounded-1': '', 'p-0.5': '' }; const k0e = { __name: 'IconAction', props: { icon: String }, setup(e) { return (t, r) => (oe(), me('button', S0e, [Y('span', { block: '', class: lt([e.icon, 'dark:op85 hover:op100']), op65: '' }, null, 2)])) } }; const lp = e => (la('data-v-96b36737'), e = e(), aa(), e); const C0e = ['aria-label', 'data-current']; const T0e = { 'key': 1, 'w-4': '' }; const E0e = { 'key': 2, 'class': 'i-logos:typescript-icon', 'flex-shrink-0': '', 'mr-2': '' }; const L0e = ['text']; const A0e = { 'text-sm': '', 'truncate': '', 'font-light': '' }; const M0e = ['innerHTML']; const N0e = { key: 0, text: 'xs', op20: '', style: { 'white-space': 'nowrap' } }; const $0e = { 'gap-1': '', 'justify-end': '', 'flex-grow-1': '', 'pl-1': '', 'class': 'test-actions' }; const O0e = { key: 0, class: 'op100 gap-1 p-y-1', grid: '~ items-center cols-[1.5em_1fr]' }; const P0e = lp(() => Y('div', { class: 'i-carbon:information-square w-1.5em h-1.5em' }, null, -1)); const R0e = lp(() => Y('span', { class: 'text-[#add467]' }, 'includeTaskLocation', -1)); const D0e = lp(() => Y('div', { style: { 'grid-column': '2' } }, ' Clicking this button the code tab will position the cursor at first line in the source code since the UI doesn\'t have the information available. ', -1)); const z0e = { key: 1 }; const I0e = ft({ __name: 'ExplorerItem', props: { taskId: {}, name: {}, indent: {}, typecheck: { type: Boolean }, duration: {}, state: {}, current: { type: Boolean }, type: {}, opened: { type: Boolean }, expandable: { type: Boolean }, search: {}, projectName: {}, projectNameColor: {}, disableTaskLocation: { type: Boolean }, onItemClick: { type: Function } }, setup(e) {
  const t = Me(() => yt.state.idMap.get(e.taskId)); const r = Me(() => {
    if (Pr)
      return !1; const T = t.value; return T && Fh(T)
  }); function o() { e.expandable && (e.opened ? Ce.collapseNode(e.taskId) : Ce.expandNode(e.taskId)) } async function s(T) { let E; (E = e.onItemClick) == null || E.call(e, T), fs.value && (tu.value = !0, await ln()), await Kh([T.file]) } function c(T) { return yt.rpc.updateSnapshot(T.file) } const f = Me(() => e.indent <= 0 ? [] : Array.from({ length: e.indent }, (T, E) => `${e.taskId}-${E}`)); const d = Me(() => { const T = f.value; const E = []; return (e.type === 'file' || e.type === 'suite') && E.push('min-content'), E.push('min-content'), e.type === 'suite' && e.typecheck && E.push('min-content'), E.push('minmax(0, 1fr)'), E.push('min-content'), `grid-template-columns: ${T.map(() => '1rem').join(' ')} ${E.join(' ')};` }); const h = Me(() => Dw(e.name)); const g = Me(() => { const T = Wce.value; const E = h.value; return T ? E.replace(T, M => `<span class="highlight">${M}</span>`) : E }); const v = Me(() => e.type !== 'file' && e.disableTaskLocation); const y = Me(() => e.type === 'file' ? 'Open test details' : e.type === 'suite' ? 'View Suite Source Code' : 'View Test Source Code'); const b = Me(() => v.value ? 'color-red5 dark:color-#f43f5e' : null); function x() { let E; const T = t.value; e.type === 'file' ? (E = e.onItemClick) == null || E.call(e, T) : yfe(T) } return (T, E) => { const M = D1; const N = k0e; const L = hi; const O = Hr('tooltip'); return q(t) ? (oe(), me('div', { 'key': 0, 'items-center': '', 'p': 'x-2 y-1', 'grid': '~ rows-1 items-center gap-x-2', 'w-full': '', 'h-28px': '', 'border-rounded': '', 'hover': 'bg-active', 'cursor-pointer': '', 'class': 'item-wrapper', 'style': Zt(q(d)), 'aria-label': T.name, 'data-current': T.current, 'onClick': E[2] || (E[2] = A => o()) }, [T.indent > 0 ? (oe(!0), me(ut, { key: 0 }, si(q(f), A => (oe(), me('div', { 'key': A, 'border': 'solid gray-500 dark:gray-400', 'class': 'vertical-line', 'h-28px': '', 'inline-flex': '', 'mx-2': '', 'op20': '' }))), 128)) : et('', !0), T.type === 'file' || T.type === 'suite' ? (oe(), me('div', T0e, [Y('div', { class: lt(T.opened ? 'i-carbon:chevron-down' : 'i-carbon:chevron-right op20'), op20: '' }, null, 2)])) : et('', !0), Oe(M, { 'state': T.state, 'mode': q(t).mode, 'failed-snapshot': q(r), 'w-4': '' }, null, 8, ['state', 'mode', 'failed-snapshot']), T.type === 'suite' && T.typecheck ? (oe(), me('div', E0e)) : et('', !0), Y('div', { 'flex': '', 'items-end': '', 'gap-2': '', 'text': T.state === 'fail' ? 'red-500' : '', 'overflow-hidden': '' }, [Y('span', A0e, [T.type === 'file' && T.projectName ? (oe(), me('span', { key: 0, style: Zt({ color: T.projectNameColor }) }, ` [${qe(T.projectName)}] `, 5)) : et('', !0), Y('span', { innerHTML: q(g) }, null, 8, M0e)]), typeof T.duration == 'number' ? (oe(), me('span', N0e, `${qe(T.duration > 0 ? T.duration : '< 1')}ms `, 1)) : et('', !0)], 8, L0e), Y('div', $0e, [!q(Pr) && q(r) ? _t((oe(), ot(N, { 'key': 0, 'data-testid': 'btn-fix-snapshot', 'title': 'Fix failed snapshot(s)', 'icon': 'i-carbon:result-old', 'onClick': E[0] || (E[0] = _c(A => c(q(t)), ['prevent', 'stop'])) }, null, 512)), [[O, 'Fix failed snapshot(s)', void 0, { bottom: !0 }]]) : et('', !0), Oe(q(Rb), { placement: 'bottom', class: lt(['w-1.4em h-1.4em op100 rounded flex', q(b)]) }, { popper: st(() => [q(v) ? (oe(), me('div', O0e, [P0e, Y('div', null, [gt(`${qe(q(y))}: this feature is not available, you have disabled `, 1), R0e, gt(' in your configuration file.')]), D0e])) : (oe(), me('div', z0e, qe(q(y)), 1))]), default: st(() => [Oe(L, { 'data-testid': 'btn-open-details', 'icon': 'i-carbon:intrusion-prevention', 'onClick': _c(x, ['prevent', 'stop']) })]), _: 1 }, 8, ['class']), q(Pr) ? et('', !0) : _t((oe(), ot(L, { 'key': 1, 'data-testid': 'btn-run-test', 'title': 'Run current test', 'icon': 'i-carbon:play-filled-alt', 'text-green5': '', 'disabled': T.type !== 'file', 'onClick': E[1] || (E[1] = _c(A => s(q(t)), ['prevent', 'stop'])) }, null, 8, ['disabled'])), [[O, 'Run current test', void 0, { bottom: !0 }]])])], 12, C0e)) : et('', !0) }
} }); const F0e = di(I0e, [['__scopeId', 'data-v-96b36737']]); const H0e = { 'flex-1': '', 'ms-2': '', 'select-none': '' }; const q0e = ft({ __name: 'FilterStatus', props: Ic({ label: {} }, { modelValue: { type: [Boolean, null] }, modelModifiers: {} }), emits: ['update:modelValue'], setup(e) { const t = Th(e, 'modelValue'); return (r, o) => (oe(), me('label', ii({ class: 'font-light text-sm checkbox flex items-center cursor-pointer py-1 text-sm w-full gap-y-1 mb-1px' }, r.$attrs, { onClick: o[1] || (o[1] = _c(s => t.value = !t.value, ['prevent'])) }), [Y('span', { 'class': lt([t.value ? 'i-carbon:checkbox-checked-filled' : 'i-carbon:checkbox']), 'text-lg': '', 'aria-hidden': 'true' }, null, 2), _t(Y('input', { 'onUpdate:modelValue': o[0] || (o[0] = s => t.value = s), 'type': 'checkbox', 'sr-only': '' }, null, 512), [[mC, t.value]]), Y('span', H0e, qe(r.label), 1)], 16)) } }); function B0e() {
  const e = window.navigator.userAgent; const t = e.indexOf('MSIE '); if (t > 0)
    return Number.parseInt(e.substring(t + 5, e.indexOf('.', t)), 10); const r = e.indexOf('Trident/'); if (r > 0) { const o = e.indexOf('rv:'); return Number.parseInt(e.substring(o + 3, e.indexOf('.', o)), 10) } const s = e.indexOf('Edge/'); return s > 0 ? Number.parseInt(e.substring(s + 5, e.indexOf('.', s)), 10) : -1
} let $c; function th() { th.init || (th.init = !0, $c = B0e() !== -1) } const qu = { name: 'ResizeObserver', props: { emitOnMount: { type: Boolean, default: !1 }, ignoreWidth: { type: Boolean, default: !1 }, ignoreHeight: { type: Boolean, default: !1 } }, emits: ['notify'], mounted() { th(), ln(() => { this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize() }); const e = document.createElement('object'); this._resizeObject = e, e.setAttribute('aria-hidden', 'true'), e.setAttribute('tabindex', -1), e.onload = this.addResizeHandlers, e.type = 'text/html', $c && this.$el.appendChild(e), e.data = 'about:blank', $c || this.$el.appendChild(e) }, beforeUnmount() { this.removeResizeHandlers() }, methods: { compareAndNotify() { (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize()) }, emitSize() { this.$emit('notify', { width: this._w, height: this._h }) }, addResizeHandlers() { this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify), this.compareAndNotify() }, removeResizeHandlers() { this._resizeObject && this._resizeObject.onload && (!$c && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null) } } }; const W0e = dy(); la('data-v-b329ee4c'); const U0e = { class: 'resize-observer', tabindex: '-1' }; aa(); const V0e = W0e((e, t, r, o, s, c) => (oe(), ot('div', U0e))); qu.render = V0e; qu.__scopeId = 'data-v-b329ee4c'; qu.__file = 'src/components/ResizeObserver.vue'; function Oc(e) { '@babel/helpers - typeof'; return typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol' ? Oc = function (t) { return typeof t } : Oc = function (t) { return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t }, Oc(e) } function j0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError('Cannot call a class as a function')
} function G0e(e, t) { for (let r = 0; r < t.length; r++) { const o = t[r]; o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o) } } function K0e(e, t, r) { return t && G0e(e.prototype, t), e } function N0(e) { return X0e(e) || Y0e(e) || Z0e(e) || J0e() } function X0e(e) {
  if (Array.isArray(e))
    return nh(e)
} function Y0e(e) {
  if (typeof Symbol < 'u' && Symbol.iterator in Object(e))
    return Array.from(e)
} function Z0e(e, t) {
  if (e) {
    if (typeof e == 'string')
      return nh(e, t); let r = Object.prototype.toString.call(e).slice(8, -1); if (r === 'Object' && e.constructor && (r = e.constructor.name), r === 'Map' || r === 'Set')
      return Array.from(e); if (r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return nh(e, t)
  }
} function nh(e, t) { (t == null || t > e.length) && (t = e.length); for (var r = 0, o = new Array(t); r < t; r++)o[r] = e[r]; return o } function J0e() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} function Q0e(e) { let t; return typeof e == 'function' ? t = { callback: e } : t = e, t } function eye(e, t) { const r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; let o; let s; let c; const f = function (h) { for (var g = arguments.length, v = Array.from({ length: g > 1 ? g - 1 : 0 }), y = 1; y < g; y++)v[y - 1] = arguments[y]; if (c = v, !(o && h === s)) { let b = r.leading; typeof b == 'function' && (b = b(h, s)), (!o || h !== s) && b && e.apply(void 0, [h].concat(N0(c))), s = h, clearTimeout(o), o = setTimeout(() => { e.apply(void 0, [h].concat(N0(c))), o = 0 }, t) } }; return f._clear = function () { clearTimeout(o), o = null }, f } function z1(e, t) {
  if (e === t)
    return !0; if (Oc(e) === 'object') {
    for (const r in e) {
      if (!z1(e[r], t[r]))
        return !1
    } return !0
  } return !1
} const tye = (function () {
  function e(t, r, o) { j0e(this, e), this.el = t, this.observer = null, this.frozen = !1, this.createObserver(r, o) } return K0e(e, [{ key: 'createObserver', value(r, o) {
    const s = this; if (this.observer && this.destroyObserver(), !this.frozen) {
      if (this.options = Q0e(r), this.callback = function (d, h) { s.options.callback(d, h), d && s.options.once && (s.frozen = !0, s.destroyObserver()) }, this.callback && this.options.throttle) { const c = this.options.throttleOptions || {}; const f = c.leading; this.callback = eye(this.callback, this.options.throttle, { leading(h) { return f === 'both' || f === 'visible' && h || f === 'hidden' && !h } }) } this.oldResult = void 0, this.observer = new IntersectionObserver((d) => {
        let h = d[0]; if (d.length > 1) { const g = d.find((y) => { return y.isIntersecting }); g && (h = g) } if (s.callback) {
          const v = h.isIntersecting && h.intersectionRatio >= s.threshold; if (v === s.oldResult)
            return; s.oldResult = v, s.callback(v, h)
        }
      }, this.options.intersection), ln(() => { s.observer && s.observer.observe(s.el) })
    }
  } }, { key: 'destroyObserver', value() { this.observer && (this.observer.disconnect(), this.observer = null), this.callback && this.callback._clear && (this.callback._clear(), this.callback = null) } }, { key: 'threshold', get() { return this.options.intersection && typeof this.options.intersection.threshold == 'number' ? this.options.intersection.threshold : 0 } }]), e
}()); function I1(e, t, r) {
  const o = t.value; if (o) {
    if (typeof IntersectionObserver > 'u') {
      console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill')
    }
    else { const s = new tye(e, o, r); e._vue_visibilityState = s }
  }
} function nye(e, t, r) { const o = t.value; const s = t.oldValue; if (!z1(o, s)) { const c = e._vue_visibilityState; if (!o) { F1(e); return }c ? c.createObserver(o, r) : I1(e, { value: o }, r) } } function F1(e) { const t = e._vue_visibilityState; t && (t.destroyObserver(), delete e._vue_visibilityState) } const rye = { beforeMount: I1, updated: nye, unmounted: F1 }; const iye = { itemsLimit: 1e3 }; const oye = /(auto|scroll)/; function H1(e, t) { return e.parentNode === null ? t : H1(e.parentNode, t.concat([e])) } const ad = function (t, r) { return getComputedStyle(t, null).getPropertyValue(r) }; const sye = function (t) { return ad(t, 'overflow') + ad(t, 'overflow-y') + ad(t, 'overflow-x') }; const lye = function (t) { return oye.test(sye(t)) }; function $0(e) {
  if (e instanceof HTMLElement || e instanceof SVGElement) {
    for (let t = H1(e.parentNode, []), r = 0; r < t.length; r += 1) {
      if (lye(t[r]))
        return t[r]
    } return document.scrollingElement || document.documentElement
  }
} function rh(e) { '@babel/helpers - typeof'; return rh = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol' ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t }, rh(e) } const aye = { items: { type: Array, required: !0 }, keyField: { type: String, default: 'id' }, direction: { type: String, default: 'vertical', validator(t) { return ['vertical', 'horizontal'].includes(t) } }, listTag: { type: String, default: 'div' }, itemTag: { type: String, default: 'div' } }; function cye() { return this.items.length && rh(this.items[0]) !== 'object' } let ih = !1; if (typeof window < 'u') {
  ih = !1; try { const uye = Object.defineProperty({}, 'passive', { get() { ih = !0 } }); window.addEventListener('test', null, uye) }
  catch {}
} let fye = 0; const ap = { name: 'RecycleScroller', components: { ResizeObserver: qu }, directives: { ObserveVisibility: rye }, props: { ...aye, itemSize: { type: Number, default: null }, gridItems: { type: Number, default: void 0 }, itemSecondarySize: { type: Number, default: void 0 }, minItemSize: { type: [Number, String], default: null }, sizeField: { type: String, default: 'size' }, typeField: { type: String, default: 'type' }, buffer: { type: Number, default: 200 }, pageMode: { type: Boolean, default: !1 }, prerender: { type: Number, default: 0 }, emitUpdate: { type: Boolean, default: !1 }, updateInterval: { type: Number, default: 0 }, skipHover: { type: Boolean, default: !1 }, listTag: { type: String, default: 'div' }, itemTag: { type: String, default: 'div' }, listClass: { type: [String, Object, Array], default: '' }, itemClass: { type: [String, Object, Array], default: '' } }, emits: ['resize', 'visible', 'hidden', 'update', 'scroll-start', 'scroll-end'], data() { return { pool: [], totalSize: 0, ready: !1, hoverKey: null } }, computed: { sizes() { if (this.itemSize === null) { const e = { '-1': { accumulator: 0 } }; const t = this.items; const r = this.sizeField; const o = this.minItemSize; let s = 1e4; let c = 0; let f; for (let d = 0, h = t.length; d < h; d++)f = t[d][r] || o, f < s && (s = f), c += f, e[d] = { accumulator: c, size: f }; return this.$_computedMinItemSize = s, e } return [] }, simpleArray: cye, itemIndexByKey() { const { keyField: e, items: t } = this; const r = {}; for (let o = 0, s = t.length; o < s; o++)r[t[o][e]] = o; return r } }, watch: { items() { this.updateVisibleItems(!0) }, pageMode() { this.applyPageMode(), this.updateVisibleItems(!1) }, sizes: { handler() { this.updateVisibleItems(!1) }, deep: !0 }, gridItems() { this.updateVisibleItems(!0) }, itemSecondarySize() { this.updateVisibleItems(!0) } }, created() { this.$_startIndex = 0, this.$_endIndex = 0, this.$_views = new Map(), this.$_unusedViews = new Map(), this.$_scrollDirty = !1, this.$_lastUpdateScrollPosition = 0, this.prerender && (this.$_prerender = !0, this.updateVisibleItems(!1)), this.gridItems && !this.itemSize && console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems') }, mounted() { this.applyPageMode(), this.$nextTick(() => { this.$_prerender = !1, this.updateVisibleItems(!0), this.ready = !0 }) }, activated() { const e = this.$_lastUpdateScrollPosition; typeof e == 'number' && this.$nextTick(() => { this.scrollToPosition(e) }) }, beforeUnmount() { this.removeListeners() }, methods: { addView(e, t, r, o, s) { const c = vh({ id: fye++, index: t, used: !0, key: o, type: s }); const f = ph({ item: r, position: 0, nr: c }); return e.push(f), f }, unuseView(e, t = !1) { const r = this.$_unusedViews; const o = e.nr.type; let s = r.get(o); s || (s = [], r.set(o, s)), s.push(e), t || (e.nr.used = !1, e.position = -9999) }, handleResize() { this.$emit('resize'), this.ready && this.updateVisibleItems(!1) }, handleScroll(e) {
  if (!this.$_scrollDirty) {
    if (this.$_scrollDirty = !0, this.$_updateTimeout)
      return; const t = () => requestAnimationFrame(() => { this.$_scrollDirty = !1; const { continuous: r } = this.updateVisibleItems(!1, !0); r || (clearTimeout(this.$_refreshTimout), this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)) }); t(), this.updateInterval && (this.$_updateTimeout = setTimeout(() => { this.$_updateTimeout = 0, this.$_scrollDirty && t() }, this.updateInterval))
  }
}, handleVisibilityChange(e, t) { this.ready && (e || t.boundingClientRect.width !== 0 || t.boundingClientRect.height !== 0 ? (this.$emit('visible'), requestAnimationFrame(() => { this.updateVisibleItems(!1) })) : this.$emit('hidden')) }, updateVisibleItems(e, t = !1) {
  const r = this.itemSize; const o = this.gridItems || 1; const s = this.itemSecondarySize || r; const c = this.$_computedMinItemSize; const f = this.typeField; const d = this.simpleArray ? null : this.keyField; const h = this.items; const g = h.length; const v = this.sizes; const y = this.$_views; const b = this.$_unusedViews; const x = this.pool; const T = this.itemIndexByKey; let E, M, N, L, O; if (!g) {
    E = M = L = O = N = 0
  }
  else if (this.$_prerender) {
    E = L = 0, M = O = Math.min(this.prerender, h.length), N = null
  }
  else {
    const j = this.getScroll(); if (t) {
      let V = j.start - this.$_lastUpdateScrollPosition; if (V < 0 && (V = -V), r === null && V < c || V < r)
        return { continuous: !0 }
    } this.$_lastUpdateScrollPosition = j.start; const ne = this.buffer; j.start -= ne, j.end += ne; let K = 0; if (this.$refs.before && (K = this.$refs.before.scrollHeight, j.start -= K), this.$refs.after) { const V = this.$refs.after.scrollHeight; j.end += V } if (r === null) { let V; let I = 0; let k = g - 1; let B = ~~(g / 2); let W; do W = B, V = v[B].accumulator, V < j.start ? I = B : B < g - 1 && v[B + 1].accumulator > j.start && (k = B), B = ~~((I + k) / 2); while (B !== W); for (B < 0 && (B = 0), E = B, N = v[g - 1].accumulator, M = B; M < g && v[M].accumulator < j.end; M++);for (M === -1 ? M = h.length - 1 : (M++, M > g && (M = g)), L = E; L < g && K + v[L].accumulator < j.start; L++);for (O = L; O < g && K + v[O].accumulator < j.end; O++); }
    else { E = ~~(j.start / r * o); const V = E % o; E -= V, M = Math.ceil(j.end / r * o), L = Math.max(0, Math.floor((j.start - K) / r * o)), O = Math.floor((j.end - K) / r * o), E < 0 && (E = 0), M > g && (M = g), L < 0 && (L = 0), O > g && (O = g), N = Math.ceil(g / o) * r }
  }M - E > iye.itemsLimit && this.itemsLimitError(), this.totalSize = N; let A; const H = E <= this.$_endIndex && M >= this.$_startIndex; if (H) {
    for (let j = 0, ne = x.length; j < ne; j++)A = x[j], A.nr.used && (e && (A.nr.index = T[A.item[d]]), (A.nr.index == null || A.nr.index < E || A.nr.index >= M) && this.unuseView(A))
  } const z = H ? null : new Map(); let J, re, te; for (let j = E; j < M; j++) {
    J = h[j]; const ne = d ? J[d] : J; if (ne == null)
      throw new Error(`Key is ${ne} on item (keyField is '${d}')`); if (A = y.get(ne), !r && !v[j].size) { A && this.unuseView(A); continue }re = J[f]; let K = b.get(re); let V = !1; if (!A) {
      H ? K && K.length ? A = K.pop() : A = this.addView(x, j, J, ne, re) : (te = z.get(re) || 0, (!K || te >= K.length) && (A = this.addView(x, j, J, ne, re), this.unuseView(A, !0), K = b.get(re)), A = K[te], z.set(re, te + 1)), y.delete(A.nr.key), A.nr.used = !0, A.nr.index = j, A.nr.key = ne, A.nr.type = re, y.set(ne, A), V = !0
    }
    else if (!A.nr.used && (A.nr.used = !0, V = !0, K)) { const I = K.indexOf(A); I !== -1 && K.splice(I, 1) }A.item = J, V && (j === h.length - 1 && this.$emit('scroll-end'), j === 0 && this.$emit('scroll-start')), r === null ? (A.position = v[j - 1].accumulator, A.offset = 0) : (A.position = Math.floor(j / o) * r, A.offset = j % o * s)
  } return this.$_startIndex = E, this.$_endIndex = M, this.emitUpdate && this.$emit('update', E, M, L, O), clearTimeout(this.$_sortTimer), this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300), { continuous: H }
}, getListenerTarget() { let e = $0(this.$el); return window.document && (e === window.document.documentElement || e === window.document.body) && (e = window), e }, getScroll() {
  const { $el: e, direction: t } = this; const r = t === 'vertical'; let o; if (this.pageMode) { const s = e.getBoundingClientRect(); const c = r ? s.height : s.width; let f = -(r ? s.top : s.left); let d = r ? window.innerHeight : window.innerWidth; f < 0 && (d += f, f = 0), f + d > c && (d = c - f), o = { start: f, end: f + d } }
  else {
    r ? o = { start: e.scrollTop, end: e.scrollTop + e.clientHeight } : o = { start: e.scrollLeft, end: e.scrollLeft + e.clientWidth }
  } return o
}, applyPageMode() { this.pageMode ? this.addListeners() : this.removeListeners() }, addListeners() { this.listenerTarget = this.getListenerTarget(), this.listenerTarget.addEventListener('scroll', this.handleScroll, ih ? { passive: !0 } : !1), this.listenerTarget.addEventListener('resize', this.handleResize) }, removeListeners() { this.listenerTarget && (this.listenerTarget.removeEventListener('scroll', this.handleScroll), this.listenerTarget.removeEventListener('resize', this.handleResize), this.listenerTarget = null) }, scrollToItem(e) { let t; const r = this.gridItems || 1; this.itemSize === null ? t = e > 0 ? this.sizes[e - 1].accumulator : 0 : t = Math.floor(e / r) * this.itemSize, this.scrollToPosition(t) }, scrollToPosition(e) {
  const t = this.direction === 'vertical' ? { scroll: 'scrollTop', start: 'top' } : { scroll: 'scrollLeft', start: 'left' }; let r, o, s; if (this.pageMode) { const c = $0(this.$el); const f = c.tagName === 'HTML' ? 0 : c[t.scroll]; const d = c.getBoundingClientRect(); const g = this.$el.getBoundingClientRect()[t.start] - d[t.start]; r = c, o = t.scroll, s = e + f + g }
  else {
    r = this.$el, o = t.scroll, s = e
  }r[o] = s
}, itemsLimitError() { throw setTimeout(() => { console.log('It seems the scroller element isn\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el), console.log('Make sure the scroller has a fixed height (or width) and \'overflow-y\' (or \'overflow-x\') set to \'auto\' so it can scroll correctly and only render the items visible in the scroll viewport.') }), new Error('Rendered items limit reached') }, sortViews() { this.pool.sort((e, t) => e.nr.index - t.nr.index) } } }; const dye = { key: 0, ref: 'before', class: 'vue-recycle-scroller__slot' }; const hye = { key: 1, ref: 'after', class: 'vue-recycle-scroller__slot' }; function pye(e, t, r, o, s, c) { const f = Ao('ResizeObserver'); const d = Hr('observe-visibility'); return _t((oe(), me('div', { class: lt(['vue-recycle-scroller', { 'ready': s.ready, 'page-mode': r.pageMode, [`direction-${e.direction}`]: !0 }]), onScrollPassive: t[0] || (t[0] = (...h) => c.handleScroll && c.handleScroll(...h)) }, [e.$slots.before ? (oe(), me('div', dye, [dn(e.$slots, 'before')], 512)) : et('v-if', !0), (oe(), ot(wv(r.listTag), { ref: 'wrapper', style: Zt({ [e.direction === 'vertical' ? 'minHeight' : 'minWidth']: `${s.totalSize}px` }), class: lt(['vue-recycle-scroller__item-wrapper', r.listClass]) }, { default: st(() => [(oe(!0), me(ut, null, si(s.pool, h => (oe(), ot(wv(r.itemTag), ii({ key: h.nr.id, style: s.ready ? { transform: `translate${e.direction === 'vertical' ? 'Y' : 'X'}(${h.position}px) translate${e.direction === 'vertical' ? 'X' : 'Y'}(${h.offset}px)`, width: r.gridItems ? `${e.direction === 'vertical' && r.itemSecondarySize || r.itemSize}px` : void 0, height: r.gridItems ? `${e.direction === 'horizontal' && r.itemSecondarySize || r.itemSize}px` : void 0 } : null, class: ['vue-recycle-scroller__item-view', [r.itemClass, { hover: !r.skipHover && s.hoverKey === h.nr.key }]] }, YS(r.skipHover ? {} : { mouseenter: () => { s.hoverKey = h.nr.key }, mouseleave: () => { s.hoverKey = null } })), { default: st(() => [dn(e.$slots, 'default', { item: h.item, index: h.nr.index, active: h.nr.used })]), _: 2 }, 1040, ['style', 'class']))), 128)), dn(e.$slots, 'empty')]), _: 3 }, 8, ['style', 'class'])), e.$slots.after ? (oe(), me('div', hye, [dn(e.$slots, 'after')], 512)) : et('v-if', !0), Oe(f, { onNotify: c.handleResize }, null, 8, ['onNotify'])], 34)), [[d, c.handleVisibilityChange]]) }ap.render = pye; ap.__file = 'src/components/RecycleScroller.vue'; function gye(e) { const t = Me(() => Fd.value ? !1 : !Qe.onlyTests); const r = Me(() => On.value === ''); const o = Be(On.value); xw(On, (h) => { o.value = (h == null ? void 0 : h.trim()) ?? '' }, { debounce: 256 }); function s(h) { let g; On.value = '', h && ((g = e.value) == null || g.focus()) } function c(h) { let g; Qe.failed = !1, Qe.success = !1, Qe.skipped = !1, Qe.onlyTests = !1, h && ((g = e.value) == null || g.focus()) } function f() { c(!1), s(!0) } function d(h, g, v, y, b) { As.value && (on.value.search = (h == null ? void 0 : h.trim()) ?? '', on.value.failed = g, on.value.success = v, on.value.skipped = y, on.value.onlyTests = b) } return Ht(() => [o.value, Qe.failed, Qe.success, Qe.skipped, Qe.onlyTests], ([h, g, v, y, b]) => { d(h, g, v, y, b), Ce.filterNodes() }, { flush: 'post' }), Ht(() => _r.value.length, (h) => { h && (on.value.expandAll = void 0) }, { flush: 'post' }), { initialized: As, filter: Qe, search: On, disableFilter: t, isFiltered: zw, isFilteredByStatus: Fd, disableClearSearch: r, clearAll: f, clearSearch: s, clearFilter: c, filteredFiles: Ru, testsTotal: Uce, uiEntries: In } } const vye = { 'p': '2', 'h-10': '', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b base' }; const mye = { 'p': 'l3 y2 r2', 'flex': '~ gap-2', 'items-center': '', 'bg-header': '', 'border': 'b-2 base' }; const yye = Y('div', { 'class': 'i-carbon:search', 'flex-shrink-0': '' }, null, -1); const bye = ['op']; const wye = Y('div', { 'aria-hidden': 'true', 'class': 'i-carbon:filter' }, null, -1); const xye = Y('div', { 'flex-grow-1': '', 'text-sm': '' }, ' Filter ', -1); const _ye = { grid: '~ items-center gap-x-1 cols-[auto_min-content_auto] rows-[min-content_min-content]' }; const Sye = { 'text-red5': '' }; const kye = Y('span', null, '/', -1); const Cye = { 'text-yellow5': '' }; const Tye = { 'text-green5': '' }; const Eye = Y('span', null, '/', -1); const Lye = { class: 'text-purple5:50' }; const Aye = { 'key': 0, 'flex': '~ col', 'items-center': '', 'p': 'x4 y4', 'font-light': '' }; const Mye = Y('div', { op30: '' }, ' No matched test ', -1); const Nye = ['disabled']; const $ye = ['disabled']; const Oye = { 'key': 1, 'flex': '~ col', 'items-center': '', 'p': 'x4 y4', 'font-light': '' }; const Pye = Y('div', { class: 'i-carbon:circle-dash animate-spin' }, null, -1); const Rye = Y('div', { op30: '' }, ' Loading... ', -1); const Dye = [Pye, Rye]; const zye = ft({ inheritAttrs: !1, __name: 'Explorer', props: { onItemClick: { type: Function } }, emits: ['item-click', 'run'], setup(e, { emit: t }) { const r = t; const o = Me(() => zu.value.includeTaskLocation); const s = Be(); const { initialized: c, filter: f, search: d, disableFilter: h, isFiltered: g, isFilteredByStatus: v, disableClearSearch: y, clearAll: b, clearSearch: x, clearFilter: T, filteredFiles: E, testsTotal: M, uiEntries: N } = gye(s); const L = Be('grid-cols-2'); const O = Be('grid-col-span-2'); const A = Be(); return Lw(A, (H) => { const { width: z } = H[0].contentRect; z < 420 ? (L.value = 'grid-cols-2', O.value = 'grid-col-span-2') : (L.value = 'grid-cols-4', O.value = 'grid-col-span-4') }), (H, z) => { const J = hi; const re = q0e; const te = F0e; const j = _0e; const ne = Hr('tooltip'); return oe(), me('div', { ref_key: 'testExplorerRef', ref: A, h: 'full', flex: '~ col' }, [Y('div', null, [Y('div', vye, [dn(H.$slots, 'header', { filteredFiles: q(g) || q(v) ? q(E) : void 0 })]), Y('div', mye, [yye, _t(Y('input', { 'ref_key': 'searchBox', 'ref': s, 'onUpdate:modelValue': z[0] || (z[0] = K => Ot(d) ? d.value = K : null), 'placeholder': 'Search...', 'outline': 'none', 'bg': 'transparent', 'font': 'light', 'text': 'sm', 'flex-1': '', 'pl-1': '', 'op': q(d).length ? '100' : '50', 'onKeydown': [z[1] || (z[1] = kd(K => q(x)(!1), ['esc'])), z[2] || (z[2] = kd(K => r('run', q(g) || q(v) ? q(E) : void 0), ['enter']))] }, null, 40, bye), [[vC, q(d)]]), _t(Oe(J, { disabled: q(y), title: 'Clear search', icon: 'i-carbon:filter-remove', onClickPassive: z[3] || (z[3] = K => q(x)(!0)) }, null, 8, ['disabled']), [[ne, 'Clear search', void 0, { bottom: !0 }]])]), Y('div', { 'p': 'l3 y2 r2', 'items-center': '', 'bg-header': '', 'border': 'b-2 base', 'grid': '~ items-center gap-x-2 rows-[auto_auto]', 'class': lt(q(L)) }, [Y('div', { class: lt(q(O)), flex: '~ gap-2 items-center' }, [wye, xye, _t(Oe(J, { disabled: q(h), title: 'Clear search', icon: 'i-carbon:filter-remove', onClickPassive: z[4] || (z[4] = K => q(T)(!1)) }, null, 8, ['disabled']), [[ne, 'Clear Filter', void 0, { bottom: !0 }]])], 2), Oe(re, { 'modelValue': q(f).failed, 'onUpdate:modelValue': z[5] || (z[5] = K => q(f).failed = K), 'label': 'Fail' }, null, 8, ['modelValue']), Oe(re, { 'modelValue': q(f).success, 'onUpdate:modelValue': z[6] || (z[6] = K => q(f).success = K), 'label': 'Pass' }, null, 8, ['modelValue']), Oe(re, { 'modelValue': q(f).skipped, 'onUpdate:modelValue': z[7] || (z[7] = K => q(f).skipped = K), 'label': 'Skip' }, null, 8, ['modelValue']), Oe(re, { 'modelValue': q(f).onlyTests, 'onUpdate:modelValue': z[8] || (z[8] = K => q(f).onlyTests = K), 'label': 'Only Tests' }, null, 8, ['modelValue'])], 2)]), Y('div', { 'class': 'scrolls', 'flex-auto': '', 'py-1': '', 'onScrollPassive': z[12] || (z[12] = (...K) => q(Am) && q(Am)(...K)) }, [Oe(j, null, XS({ default: st(() => [(q(g) || q(v)) && q(N).length === 0 ? (oe(), me(ut, { key: 0 }, [q(c) ? (oe(), me('div', Aye, [Mye, Y('button', { 'type': 'button', 'font-light': '', 'text-sm': '', 'border': '~ gray-400/50 rounded', 'p': 'x2 y0.5', 'm': 't2', 'op': '50', 'class': lt(q(y) ? null : 'hover:op100'), 'disabled': q(y), 'onClickPassive': z[9] || (z[9] = K => q(x)(!0)) }, ' Clear Search ', 42, Nye), Y('button', { 'type': 'button', 'font-light': '', 'text-sm': '', 'border': '~ gray-400/50 rounded', 'p': 'x2 y0.5', 'm': 't2', 'op': '50', 'class': lt(q(h) ? null : 'hover:op100'), 'disabled': q(h), 'onClickPassive': z[10] || (z[10] = K => q(T)(!0)) }, ' Clear Filter ', 42, $ye), Y('button', { 'type': 'button', 'font-light': '', 'op': '50 hover:100', 'text-sm': '', 'border': '~ gray-400/50 rounded', 'p': 'x2 y0.5', 'm': 't2', 'onClickPassive': z[11] || (z[11] = (...K) => q(b) && q(b)(...K)) }, ' Clear All ', 32)])) : (oe(), me('div', Oye, Dye))], 64)) : (oe(), ot(q(ap), { 'key': 1, 'page-mode': '', 'key-field': 'id', 'item-size': 28, 'items': q(N), 'buffer': 100 }, { default: st(({ item: K }) => [Oe(te, { 'class': lt(['h-28px m-0 p-0', q(Zi) === K.id ? 'bg-active' : '']), 'task-id': K.id, 'expandable': K.expandable, 'type': K.type, 'current': q(Zi) === K.id, 'indent': K.indent, 'name': K.name, 'typecheck': K.typecheck === !0, 'project-name': K.projectName ?? '', 'project-name-color': K.projectNameColor ?? '', 'state': K.state, 'duration': K.duration, 'opened': K.expanded, 'disable-task-location': !q(o), 'on-item-click': H.onItemClick }, null, 8, ['task-id', 'expandable', 'type', 'current', 'indent', 'name', 'typecheck', 'project-name', 'project-name-color', 'state', 'duration', 'opened', 'disable-task-location', 'class', 'on-item-click'])]), _: 1 }, 8, ['items']))]), _: 2 }, [q(c) ? { name: 'summary', fn: st(() => [Y('div', _ye, [Y('span', Sye, ` FAIL (${qe(q(M).failed)}) `, 1), kye, Y('span', Cye, ` RUNNING (${qe(q(M).running)}) `, 1), Y('span', Tye, ` PASS (${qe(q(M).success)}) `, 1), Eye, Y('span', Lye, ` SKIP (${qe(q(f).onlyTests ? q(M).skipped : '--')}) `, 1)])]), key: '0' } : void 0]), 1024)], 32)], 512) } } }); const Iye = `${new URL('../favicon.svg', import.meta.url).href}`; const Fye = Y('img', { 'w-6': '', 'h-6': '', 'src': Iye, 'alt': 'Vitest logo' }, null, -1); const Hye = Y('span', { 'font-light': '', 'text-sm': '', 'flex-1': '' }, 'Vitest', -1); const qye = { class: 'flex text-lg' }; const Bye = Y('div', { class: 'i-carbon:folder-off ma' }, null, -1); const Wye = Y('div', { class: 'op100 gap-1 p-y-1', grid: '~ items-center cols-[1.5em_1fr]' }, [Y('div', { class: 'i-carbon:information-square w-1.5em h-1.5em' }), Y('div', null, 'Coverage enabled but missing html reporter.'), Y('div', { style: { 'grid-column': '2' } }, ' Add html reporter to your configuration to see coverage here. ')], -1); const Uye = ft({ __name: 'Navigation', setup(e) { function t() { return yt.rpc.updateSnapshot() } const r = Me(() => ga.value ? 'light' : 'dark'); async function o(f) { fs.value && (tu.value = !0, await ln(), Ji.value && (nu(!0), await ln())), f != null && f.length ? await Kh(f) : await wue() } function s() { Ce.collapseAllNodes() } function c() { Ce.expandAllNodes() } return (f, d) => { const h = hi; const g = zye; const v = Hr('tooltip'); return oe(), ot(g, { 'border': 'r base', 'on-item-click': q(Gw), 'nested': !0, 'onRun': o }, { header: st(({ filteredFiles: y }) => [Fye, Hye, Y('div', qye, [_t(Oe(h, { 'title': 'Collapse tests', 'disabled': !q(As), 'data-testid': 'collapse-all', 'icon': 'i-carbon:collapse-all', 'onClick': d[0] || (d[0] = b => s()) }, null, 8, ['disabled']), [[bl, !q(n0)], [v, 'Collapse tests', void 0, { bottom: !0 }]]), _t(Oe(h, { 'disabled': !q(As), 'title': 'Expand tests', 'data-testid': 'expand-all', 'icon': 'i-carbon:expand-all', 'onClick': d[1] || (d[1] = b => c()) }, null, 8, ['disabled']), [[bl, q(n0)], [v, 'Expand tests', void 0, { bottom: !0 }]]), _t(Oe(h, { 'title': 'Show dashboard', 'class': '!animate-100ms', 'animate-count-1': '', 'icon': 'i-carbon:dashboard', 'onClick': d[2] || (d[2] = b => q(nu)(!0)) }, null, 512), [[bl, q(Wd) && !q(fs) || !q(ys)], [v, 'Dashboard', void 0, { bottom: !0 }]]), q(Wd) && !q(fs) ? (oe(), ot(q(Rb), { key: 0, title: 'Coverage enabled but missing html reporter', class: 'w-1.4em h-1.4em op100 rounded flex color-red5 dark:color-#f43f5e cursor-help' }, { popper: st(() => [Wye]), default: st(() => [Bye]), _: 1 })) : et('', !0), q(fs) ? _t((oe(), ot(h, { 'key': 1, 'disabled': q(tu), 'title': 'Show coverage', 'class': '!animate-100ms', 'animate-count-1': '', 'icon': 'i-carbon:folder-details-reference', 'onClick': d[3] || (d[3] = b => q(Eue)()) }, null, 8, ['disabled'])), [[bl, !q(Ji)], [v, 'Coverage', void 0, { bottom: !0 }]]) : et('', !0), q(Ce).summary.failedSnapshot && !q(Pr) ? _t((oe(), ot(h, { key: 2, icon: 'i-carbon:result-old', disabled: !q(Ce).summary.failedSnapshotEnabled, onClick: d[4] || (d[4] = b => q(Ce).summary.failedSnapshotEnabled && t()) }, null, 8, ['disabled'])), [[v, 'Update all failed snapshot(s)', void 0, { bottom: !0 }]]) : et('', !0), q(Pr) ? et('', !0) : _t((oe(), ot(h, { key: 3, disabled: (y == null ? void 0 : y.length) === 0, icon: 'i-carbon:play', onClick: b => o(y) }, null, 8, ['disabled', 'onClick'])), [[v, y ? y.length === 0 ? 'No test to run (clear filter)' : 'Rerun filtered' : 'Rerun all', void 0, { bottom: !0 }]]), _t(Oe(h, { icon: 'dark:i-carbon-moon i-carbon:sun', onClick: d[5] || (d[5] = b => q(jue)()) }, null, 512), [[v, `Toggle to ${q(r)} mode`, void 0, { bottom: !0 }]])])]), _: 1 }, 8, ['on-item-click']) } } }); const Vye = { 'h-3px': '', 'relative': '', 'overflow-hidden': '', 'class': 'px-0', 'w-screen': '' }; const jye = ft({ __name: 'ProgressBar', setup(e) { const { width: t } = bce(); const r = Me(() => Ce.summary.files === 0 ? '!bg-gray-4 !dark:bg-gray-7 in-progress' : qce.value ? null : 'in-progress'); const o = Me(() => { const d = Ce.summary.files; return d > 0 ? t.value * Ce.summary.filesSuccess / d : 0 }); const s = Me(() => { const d = Ce.summary.files; return d > 0 ? t.value * Ce.summary.filesFailed / d : 0 }); const c = Me(() => Ce.summary.files - Ce.summary.filesFailed - Ce.summary.filesSuccess); const f = Me(() => { const d = Ce.summary.files; return d > 0 ? t.value * c.value / d : 0 }); return (d, h) => (oe(), me('div', { 'absolute': '', 't-0': '', 'l-0': '', 'r-0': '', 'z-index-1031': '', 'pointer-events-none': '', 'p-0': '', 'h-3px': '', 'grid': '~ auto-cols-max', 'justify-items-center': '', 'w-screen': '', 'class': lt(q(r)) }, [Y('div', Vye, [Y('div', { 'absolute': '', 'l-0': '', 't-0': '', 'bg-red5': '', 'h-3px': '', 'class': lt(q(r)), 'style': Zt(`width: ${q(s)}px;`) }, '  ', 6), Y('div', { 'absolute': '', 'l-0': '', 't-0': '', 'bg-green5': '', 'h-3px': '', 'class': lt(q(r)), 'style': Zt(`left: ${q(s)}px; width: ${q(o)}px;`) }, '  ', 6), Y('div', { 'absolute': '', 'l-0': '', 't-0': '', 'bg-yellow5': '', 'h-3px': '', 'class': lt(q(r)), 'style': Zt(`left: ${q(o) + q(s)}px; width: ${q(f)}px;`) }, '  ', 6)])], 2)) } }); const Gye = di(jye, [['__scopeId', 'data-v-38451300']]); const O0 = { name: 'splitpanes', emits: ['ready', 'resize', 'resized', 'pane-click', 'pane-maximize', 'pane-add', 'pane-remove', 'splitter-click'], props: { horizontal: { type: Boolean }, pushOtherPanes: { type: Boolean, default: !0 }, dblClickSplitter: { type: Boolean, default: !0 }, rtl: { type: Boolean, default: !1 }, firstSplitter: { type: Boolean } }, provide() { return { requestUpdate: this.requestUpdate, onPaneAdd: this.onPaneAdd, onPaneRemove: this.onPaneRemove, onPaneClick: this.onPaneClick } }, data: () => ({ container: null, ready: !1, panes: [], touch: { mouseDown: !1, dragging: !1, activeSplitter: null }, splitterTaps: { splitter: null, timeoutId: null } }), computed: { panesCount() { return this.panes.length }, indexedPanes() { return this.panes.reduce((e, t) => (e[t.id] = t) && e, {}) } }, methods: { updatePaneComponents() { this.panes.forEach((e) => { e.update && e.update({ [this.horizontal ? 'height' : 'width']: `${this.indexedPanes[e.id].size}%` }) }) }, bindEvents() { document.addEventListener('mousemove', this.onMouseMove, { passive: !1 }), document.addEventListener('mouseup', this.onMouseUp), 'ontouchstart' in window && (document.addEventListener('touchmove', this.onMouseMove, { passive: !1 }), document.addEventListener('touchend', this.onMouseUp)) }, unbindEvents() { document.removeEventListener('mousemove', this.onMouseMove, { passive: !1 }), document.removeEventListener('mouseup', this.onMouseUp), 'ontouchstart' in window && (document.removeEventListener('touchmove', this.onMouseMove, { passive: !1 }), document.removeEventListener('touchend', this.onMouseUp)) }, onMouseDown(e, t) { this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = t }, onMouseMove(e) { this.touch.mouseDown && (e.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(e)), this.$emit('resize', this.panes.map(t => ({ min: t.min, max: t.max, size: t.size })))) }, onMouseUp() { this.touch.dragging && this.$emit('resized', this.panes.map(e => ({ min: e.min, max: e.max, size: e.size }))), this.touch.mouseDown = !1, setTimeout(() => { this.touch.dragging = !1, this.unbindEvents() }, 100) }, onSplitterClick(e, t) { 'ontouchstart' in window && (e.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === t ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e, t), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = t, this.splitterTaps.timeoutId = setTimeout(() => { this.splitterTaps.splitter = null }, 500)))), this.touch.dragging || this.$emit('splitter-click', this.panes[t]) }, onSplitterDblClick(e, t) { let r = 0; this.panes = this.panes.map((o, s) => (o.size = s === t ? o.max : o.min, s !== t && (r += o.min), o)), this.panes[t].size -= r, this.$emit('pane-maximize', this.panes[t]), this.$emit('resized', this.panes.map(o => ({ min: o.min, max: o.max, size: o.size }))) }, onPaneClick(e, t) { this.$emit('pane-click', this.indexedPanes[t]) }, getCurrentMouseDrag(e) { const t = this.container.getBoundingClientRect(); const { clientX: r, clientY: o } = 'ontouchstart' in window && e.touches ? e.touches[0] : e; return { x: r - t.left, y: o - t.top } }, getCurrentDragPercentage(e) { e = e[this.horizontal ? 'y' : 'x']; const t = this.container[this.horizontal ? 'clientHeight' : 'clientWidth']; return this.rtl && !this.horizontal && (e = t - e), e * 100 / t }, calculatePanesSize(e) {
  const t = this.touch.activeSplitter; let r = { prevPanesSize: this.sumPrevPanesSize(t), nextPanesSize: this.sumNextPanesSize(t), prevReachedMinPanes: 0, nextReachedMinPanes: 0 }; const o = 0 + (this.pushOtherPanes ? 0 : r.prevPanesSize); const s = 100 - (this.pushOtherPanes ? 0 : r.nextPanesSize); const c = Math.max(Math.min(this.getCurrentDragPercentage(e), s), o); let f = [t, t + 1]; let d = this.panes[f[0]] || null; let h = this.panes[f[1]] || null; const g = d.max < 100 && c >= d.max + r.prevPanesSize; const v = h.max < 100 && c <= 100 - (h.max + this.sumNextPanesSize(t + 1)); if (g || v) { g ? (d.size = d.max, h.size = Math.max(100 - d.max - r.prevPanesSize - r.nextPanesSize, 0)) : (d.size = Math.max(100 - h.max - r.prevPanesSize - this.sumNextPanesSize(t + 1), 0), h.size = h.max); return } if (this.pushOtherPanes) {
    const y = this.doPushOtherPanes(r, c); if (!y)
      return; ({ sums: r, panesToResize: f } = y), d = this.panes[f[0]] || null, h = this.panes[f[1]] || null
  }d !== null && (d.size = Math.min(Math.max(c - r.prevPanesSize - r.prevReachedMinPanes, d.min), d.max)), h !== null && (h.size = Math.min(Math.max(100 - c - r.nextPanesSize - r.nextReachedMinPanes, h.min), h.max))
}, doPushOtherPanes(e, t) { const r = this.touch.activeSplitter; const o = [r, r + 1]; return t < e.prevPanesSize + this.panes[o[0]].min && (o[0] = this.findPrevExpandedPane(r).index, e.prevReachedMinPanes = 0, o[0] < r && this.panes.forEach((s, c) => { c > o[0] && c <= r && (s.size = s.min, e.prevReachedMinPanes += s.min) }), e.prevPanesSize = this.sumPrevPanesSize(o[0]), o[0] === void 0) ? (e.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((s, c) => { c > 0 && c <= r && (s.size = s.min, e.prevReachedMinPanes += s.min) }), this.panes[o[1]].size = 100 - e.prevReachedMinPanes - this.panes[0].min - e.prevPanesSize - e.nextPanesSize, null) : t > 100 - e.nextPanesSize - this.panes[o[1]].min && (o[1] = this.findNextExpandedPane(r).index, e.nextReachedMinPanes = 0, o[1] > r + 1 && this.panes.forEach((s, c) => { c > r && c < o[1] && (s.size = s.min, e.nextReachedMinPanes += s.min) }), e.nextPanesSize = this.sumNextPanesSize(o[1] - 1), o[1] === void 0) ? (e.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((s, c) => { c < this.panesCount - 1 && c >= r + 1 && (s.size = s.min, e.nextReachedMinPanes += s.min) }), this.panes[o[0]].size = 100 - e.prevPanesSize - e.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e.nextPanesSize, null) : { sums: e, panesToResize: o } }, sumPrevPanesSize(e) { return this.panes.reduce((t, r, o) => t + (o < e ? r.size : 0), 0) }, sumNextPanesSize(e) { return this.panes.reduce((t, r, o) => t + (o > e + 1 ? r.size : 0), 0) }, findPrevExpandedPane(e) { return [...this.panes].reverse().find(t => t.index < e && t.size > t.min) || {} }, findNextExpandedPane(e) { return this.panes.find(t => t.index > e + 1 && t.size > t.min) || {} }, checkSplitpanesNodes() { Array.from(this.container.children).forEach((e) => { const t = e.classList.contains('splitpanes__pane'); const r = e.classList.contains('splitpanes__splitter'); !t && !r && (e.parentNode.removeChild(e), console.warn('Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.')) }) }, addSplitter(e, t, r = !1) { const o = e - 1; const s = document.createElement('div'); s.classList.add('splitpanes__splitter'), r || (s.onmousedown = c => this.onMouseDown(c, o), typeof window < 'u' && 'ontouchstart' in window && (s.ontouchstart = c => this.onMouseDown(c, o)), s.onclick = c => this.onSplitterClick(c, o + 1)), this.dblClickSplitter && (s.ondblclick = c => this.onSplitterDblClick(c, o + 1)), t.parentNode.insertBefore(s, t) }, removeSplitter(e) { e.onmousedown = void 0, e.onclick = void 0, e.ondblclick = void 0, e.parentNode.removeChild(e) }, redoSplitters() { const e = Array.from(this.container.children); e.forEach((r) => { r.className.includes('splitpanes__splitter') && this.removeSplitter(r) }); let t = 0; e.forEach((r) => { r.className.includes('splitpanes__pane') && (!t && this.firstSplitter ? this.addSplitter(t, r, !0) : t && this.addSplitter(t, r), t++) }) }, requestUpdate({ target: e, ...t }) { const r = this.indexedPanes[e._.uid]; Object.entries(t).forEach(([o, s]) => r[o] = s) }, onPaneAdd(e) { let t = -1; Array.from(e.$el.parentNode.children).some(s => (s.className.includes('splitpanes__pane') && t++, s === e.$el)); const r = Number.parseFloat(e.minSize); const o = Number.parseFloat(e.maxSize); this.panes.splice(t, 0, { id: e._.uid, index: t, min: isNaN(r) ? 0 : r, max: isNaN(o) ? 100 : o, size: e.size === null ? null : Number.parseFloat(e.size), givenSize: e.size, update: e.update }), this.panes.forEach((s, c) => s.index = c), this.ready && this.$nextTick(() => { this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[t] }), this.$emit('pane-add', { index: t, panes: this.panes.map(s => ({ min: s.min, max: s.max, size: s.size })) }) }) }, onPaneRemove(e) { const t = this.panes.findIndex(o => o.id === e._.uid); const r = this.panes.splice(t, 1)[0]; this.panes.forEach((o, s) => o.index = s), this.$nextTick(() => { this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...r, index: t } }), this.$emit('pane-remove', { removed: r, panes: this.panes.map(o => ({ min: o.min, max: o.max, size: o.size })) }) }) }, resetPaneSizes(e = {}) { !e.addedPane && !e.removedPane ? this.initialPanesSizing() : this.panes.some(t => t.givenSize !== null || t.min || t.max < 100) ? this.equalizeAfterAddOrRemove(e) : this.equalize(), this.ready && this.$emit('resized', this.panes.map(t => ({ min: t.min, max: t.max, size: t.size }))) }, equalize() { const e = 100 / this.panesCount; let t = 0; const r = []; const o = []; this.panes.forEach((s) => { s.size = Math.max(Math.min(e, s.max), s.min), t -= s.size, s.size >= s.max && r.push(s.id), s.size <= s.min && o.push(s.id) }), t > 0.1 && this.readjustSizes(t, r, o) }, initialPanesSizing() { let e = 100; const t = []; const r = []; let o = 0; this.panes.forEach((c) => { e -= c.size, c.size !== null && o++, c.size >= c.max && t.push(c.id), c.size <= c.min && r.push(c.id) }); let s = 100; e > 0.1 && (this.panes.forEach((c) => { c.size === null && (c.size = Math.max(Math.min(e / (this.panesCount - o), c.max), c.min)), s -= c.size }), s > 0.1 && this.readjustSizes(e, t, r)) }, equalizeAfterAddOrRemove({ addedPane: e, removedPane: t } = {}) { let r = 100 / this.panesCount; let o = 0; const s = []; const c = []; e && e.givenSize !== null && (r = (100 - e.givenSize) / (this.panesCount - 1)), this.panes.forEach((f) => { o -= f.size, f.size >= f.max && s.push(f.id), f.size <= f.min && c.push(f.id) }), !(Math.abs(o) < 0.1) && (this.panes.forEach((f) => { e && e.givenSize !== null && e.id === f.id || (f.size = Math.max(Math.min(r, f.max), f.min)), o -= f.size, f.size >= f.max && s.push(f.id), f.size <= f.min && c.push(f.id) }), o > 0.1 && this.readjustSizes(o, s, c)) }, readjustSizes(e, t, r) {
  let o; e > 0 ? o = e / (this.panesCount - t.length) : o = e / (this.panesCount - r.length), this.panes.forEach((s, c) => {
    if (e > 0 && !t.includes(s.id)) { const f = Math.max(Math.min(s.size + o, s.max), s.min); const d = f - s.size; e -= d, s.size = f }
    else if (!r.includes(s.id)) { const f = Math.max(Math.min(s.size + o, s.max), s.min); const d = f - s.size; e -= d, s.size = f }s.update({ [this.horizontal ? 'height' : 'width']: `${this.indexedPanes[s.id].size}%` })
  }), Math.abs(e) > 0.1 && this.$nextTick(() => { this.ready && console.warn('Splitpanes: Could not resize panes correctly due to their constraints.') })
} }, watch: { panes: { deep: !0, immediate: !1, handler() { this.updatePaneComponents() } }, horizontal() { this.updatePaneComponents() }, firstSplitter() { this.redoSplitters() }, dblClickSplitter(e) { [...this.container.querySelectorAll('.splitpanes__splitter')].forEach((t, r) => { t.ondblclick = e ? o => this.onSplitterDblClick(o, r) : void 0 }) } }, beforeUnmount() { this.ready = !1 }, mounted() { this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit('ready'), this.ready = !0 }, render() { return fa('div', { ref: 'container', class: ['splitpanes', `splitpanes--${this.horizontal ? 'horizontal' : 'vertical'}`, { 'splitpanes--dragging': this.touch.dragging }] }, this.$slots.default()) } }; function Kye(e, t) { const r = e.__vccOpts || e; for (const [o, s] of t)r[o] = s; return r } const Xye = { name: 'pane', inject: ['requestUpdate', 'onPaneAdd', 'onPaneRemove', 'onPaneClick'], props: { size: { type: [Number, String], default: null }, minSize: { type: [Number, String], default: 0 }, maxSize: { type: [Number, String], default: 100 } }, data: () => ({ style: {} }), mounted() { this.onPaneAdd(this) }, beforeUnmount() { this.onPaneRemove(this) }, methods: { update(e) { this.style = e } }, computed: { sizeNumber() { return this.size || this.size === 0 ? Number.parseFloat(this.size) : null }, minSizeNumber() { return Number.parseFloat(this.minSize) }, maxSizeNumber() { return Number.parseFloat(this.maxSize) } }, watch: { sizeNumber(e) { this.requestUpdate({ target: this, size: e }) }, minSizeNumber(e) { this.requestUpdate({ target: this, min: e }) }, maxSizeNumber(e) { this.requestUpdate({ target: this, max: e }) } } }; function Yye(e, t, r, o, s, c) { return oe(), me('div', { class: 'splitpanes__pane', onClick: t[0] || (t[0] = f => c.onPaneClick(f, e._.uid)), style: Zt(e.style) }, [dn(e.$slots, 'default')], 4) } const vc = Kye(Xye, [['render', Yye]]); const Zye = { 'h-screen': '', 'w-screen': '', 'overflow': 'hidden' }; const Jye = ft({ __name: 'index', setup(e) { const t = Tue(); const r = Pu('vitest-ui_splitpanes-mainSizes', [33, 67], { initOnMounted: !0 }); const o = e0((f) => { f.forEach((d, h) => { r.value[h] = d.size }) }, 0); const s = e0((f) => { f.forEach((d, h) => { Ec.value[h] = d.size }), rd(!1) }, 0); function c() { const f = window.innerWidth; const d = Math.min(f / 3, 300); r.value[0] = 100 * d / f, r.value[1] = 100 - r.value[0] } return (f, d) => { const h = Gye; const g = Uye; const v = y0e; const y = dme; const b = lme; const x = Pue; const T = kue; return oe(), me(ut, null, [Oe(h), Y('div', Zye, [Oe(q(O0), { class: 'pt-4px', onResized: q(o), onResize: d[2] || (d[2] = E => q(rd)(!0)), onReady: c }, { default: st(() => [Oe(q(vc), { size: q(r)[0] }, { default: st(() => [Oe(g)]), _: 1 }, 8, ['size']), Oe(q(vc), { size: q(r)[1] }, { default: st(() => [q(No) ? (oe(), ot(q(O0), { id: 'details-splitpanes', key: 'browser-detail', onResize: d[1] || (d[1] = E => q(rd)(!0)), onResized: q(s) }, { default: st(() => [Oe(q(vc), { 'size': q(Ec)[0], 'min-size': '10' }, { default: st(() => [d[0] || (Hc(-1), (d[0] = Oe(x)).cacheIndex = 0, Hc(1), d[0])]), _: 1 }, 8, ['size']), Oe(q(vc), { 'size': q(Ec)[1], 'min-size': '5' }, { default: st(() => [q(t) ? (oe(), ot(v, { key: 'summary' })) : q(Ji) ? (oe(), ot(y, { key: 'coverage', src: q(s0) }, null, 8, ['src'])) : (oe(), ot(b, { key: 'details' }))]), _: 1 }, 8, ['size'])]), _: 1 }, 8, ['onResized'])) : (oe(), ot(Ah, { key: 'ui-detail' }, { default: st(() => [q(t) ? (oe(), ot(v, { key: 'summary' })) : q(Ji) ? (oe(), ot(y, { key: 'coverage', src: q(s0) }, null, 8, ['src'])) : (oe(), ot(b, { key: 'details' }))]), _: 1 }))]), _: 1 }, 8, ['size'])]), _: 1 }, 8, ['onResized'])]), Oe(T)], 64) } } }); const Qye = [{ name: 'index', path: '/', component: Jye, props: !0 }]; const ebe = { tooltip: ME }; Db.options.instantMove = !0; Db.options.distance = 10; function tbe() { return $T({ history: sT(), routes: Qye }) } const nbe = [tbe]; const cp = Xy(LC); nbe.forEach((e) => { cp.use(e()) }); Object.entries(ebe).forEach(([e, t]) => { cp.directive(e, t) }); cp.mount('#app')
